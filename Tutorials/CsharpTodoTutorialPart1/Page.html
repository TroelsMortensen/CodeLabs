<!DOCTYPE html>
<html>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link href="https://fonts.googleapis.com/css?family=Raleway" rel="stylesheet">
<link href="./../../Resources/Style.css" rel="stylesheet">
<link href="./../../Resources/prism.css" rel="stylesheet">
<script src="./../../Resources/TabNavigavtor.js"></script>
<link  rel="shortcut icon"  href="./../../Resources/CodeIcon.png">
<title>VIA Codelabs</title>
<body>
<script src="./../../Resources/prism.js"></script>

<div>
    <a href="./../../index.html" class="homelink">HOME</a>
</div>
<div  style="display:flex;width:100%;height:100%;padding-top:64px">
    <div>
        <ol>
            <li class="step" onclick="setTab(0)">1 Introduction</li>
<li class="step" onclick="setTab(1)">2 New solution</li>
<li class="step" onclick="setTab(2)">3 Project structure</li>
<li class="step" onclick="setTab(3)">4 Domain component</li>
<li class="step" onclick="setTab(4)">5 Model classes</li>
<li class="step" onclick="setTab(5)">6 Two new components</li>
<li class="step" onclick="setTab(6)">7 Blazor component</li>
<li class="step" onclick="setTab(7)">8 File data component</li>
<li class="step" onclick="setTab(8)">9 File context</li>
<li class="step" onclick="setTab(9)">10 Data access interfaces</li>
<li class="step" onclick="setTab(10)">11 Data access implementation</li>

        </ol>
    </div>
    <div id="container" action="/action_page.php">
        <div style="overflow:auto;">

            <div style="float:right;">
                <button type="button" id="prevBtn" onclick="nextPrev(-1)">&lt; Previous</button>
                <button type="button" id="nextBtn" onclick="nextPrev(1)">Next &gt;</button>
            </div>
        </div>

        <!-- One "tab" for each step in the form: -->

        <div class="tab">
<h1>Introduction</h1>
<p><img src="Resources/TodoIcon.png" alt="Todo list" /></p>
<p>This tutorial will initially introduce you to Blazor-server. You will create a web app to manage todo items. You can consider it a very simple Trello clone.</p>
<p>You will create basic features, such as</p>
<ul>
<li>creating a Todo</li>
<li>viewing all</li>
<li>searching</li>
<li>modifying</li>
<li>deleting</li>
</ul>
<p>Initially the data will be saved in a file, as json format.</p>
<p>In later sessions, we will expand upon the tutorial, changing it to a client server system using REST, and lastly adding a real database, using Entity Framework Core (EFC).</p>
<p>The entire collection of Todo tutorials aim to perfectly prepare you for the exam.</p>
<p>All source code will be on GitHub, so you always have a reference, if you're stuck.<br />
<strong>Find it here</strong> <a href="https://github.com/TroelsMortensen/BlazorTodoApp/tree/Part1">App On GitHub</a></p>
<p>Different parts of the tutorial in the future, will be in different branches:</p>
<p><img src="Resources/img_4.png" alt="img_4.png" /></p>

</div>
<div class="tab">
<h1>Creating a new solution</h1>
<p>For previous exercises, you have most likely put them all in the same solution, and created a new project for each exercise.</p>
<p>This tutorial will be a slightly larger exercise, perhaps sort of a mini-SEP. As such, we wish to have a better code-structure for our application. You have been taught the SOLID design principles. They usually apply to single methods, or classes. In this project we will attempt to apply <em>Clean Architecture</em>, which is basically applying the SOLID principles on a larger scale.</p>
<p>Therefore, we're going to need a new, <strong>empty solution</strong>. You can name it TodoApp.</p>
<p>Follow the steps below to create a new solution:</p>
<p><img src="Resources/File-New.png" alt="" /></p>
<p>Clicking <strong>New...</strong> will open the dialog for creating a new solution, see below.</p>
<ol>
<li>Select Empty Solution</li>
<li>Give your solution a name. I have multiple Todo apps by now, so I have called mine <em>BlazorTodoApp</em></li>
<li>You can choose to add a git repository, if you wish.</li>
</ol>
<p><img src="Resources/EmptySolution.png" alt="" /></p>
<p>Your new empty solution should now look like this:</p>
<p><img src="Resources/SolutionCreated.png" alt="" /></p>
<p>I.e. it's pretty empty. Next up, we will talk about the solution structure.</p>

</div>
<div class="tab">
<h1>Project structure</h1>
<p>You have previously heard about layered systems on second semester, a simple example could look like this:</p>
<p><img src="Resources/SimpleArch.png" alt="img.png" /></p>
<p>The above would be a basic structure for a local desktop app. In SEP2 you expanded to a client/server system, using JFX. Such a system could be diagrammed like below:</p>
<p><img src="Resources/CSArch.png" alt="img_1.png" /></p>
<p>The same approach applies: Layers have different responsibilites, and each layer is separated by interfaces. In SEP2 you probably divided layers into different packages.
The next step is to separate into <em>components</em>. In Java it's called a module, in .NET it's called a <em>project</em>. This means your .NET app will be structured using an approach like below:</p>
<p><img src="Resources/FinalAppStructure.png" alt="" /></p>
<p>This could be an example of your entire solution. You will have at least 4 components: Blazor, WebAPI, Domain, DataAccess (we have some side-steps along the way, though). Each component may contain multiple layers.<br />
In this first part we will start with Blazor and DataAccess. You may notice there is no component for business logic, simply because this app is rather simple. The final structure of your Todo app at the end of the semester may look slightly different.</p>
<p>In your SEP3 you're going to need a component for logic.</p>
<p>The point is that these projects (components) are separated, each handling their own responsibilities. There are different approaches on how to structure these components. We will do by layer, because that is simpler. However, in your professional career, you will probably encounter a separation by feature. This is the recommended approach, however much more complicated.</p>
<p>This may seem a bit overwhelming, but we will take it step by step, holding hands along the way. You will be safe.</p>

</div>
<div class="tab">
<h1>The Domain component</h1>
<p>First, we need the model classes. In this first iteration of the tutorial, we will just need a Todo object. Later we will add Users.</p>
<h3>New project (component)</h3>
<p>Create a new Library project, by right-clicking your solution:</p>
<p><img src="Resources/CreateLibrary1.png" alt="img.png" /></p>
<p>This will open a familiar dialog, where you can create a Class Library (1). Give the project a name (2), I have called mine <em>Domain</em>. In your case, you can probably only select net6.0 (3). Finally press Create (4).</p>
<p><img src="Resources/img.png" alt="img.png" /></p>
<p>A Class Library is a type of project which cannot be run, it instead contains functionality. All NuGet packages are generally libraries with functionality, you can import into your system. Your Domain component will just contain the domain model classes, there is nothing to <em>run</em>. If you make custom Exceptions, they could also go here.</p>

</div>
<div class="tab">
<h1>Todo model class</h1>
<p>You can start by deleting the default class that comes with the project: Class1.cs.</p>
<p>Inside your Domain project, create a new directory, name it Models. In here we put the model classes.</p>
<p>Create a new class, call it <code>Todo</code>:</p>
<p><img src="Resources/img_1.png" alt="img_1.png" /></p>
<p>The <code>Todo</code> class needs properties for the data, a Todo should hold:</p>
<pre><code class="line-numbers language-csharp">public class Todo
{
    public int Id { get; set; }
    public int OwnerId { get; set; }
    public string Title { get; set; }
    public bool IsCompleted { get; set; }

    public Todo(int ownerId, string title)
    {
        OwnerId = ownerId;
        Title = title;
    }
}
</code></pre>
<p>We have created a constructor, which only takes two of the four properties as arguments. The intention is that the Id should be set automatically by whatever class persists the data, and you cannot create a Todo, which is initially already completed.</p>

</div>
<div class="tab">
<h1>A tale of  two components</h1>
<p>We are going to need two more components for this first part of the tutorial: a Blazor-server component, and another component to save data to a file. The relationship between the two components will be like below:</p>
<p><img src="Resources/img_2.png" alt="img_2.png" /></p>
<p>This means the interface, which the UI depends on, is located in the Blazor component. The FileData component will reference the Blazor component, to get access to the interfaces, so that data access classes in the FileData component can implement the interfaces.</p>
<p>This is because, in a later part of the tutorial, the Blazor app should contact a server for data, instead of getting the data from a local file. By keeping the interface in the Blazor component, we shouldn't need to modify this app, when we change out, where the data comes from.</p>

</div>
<div class="tab">
<h1>Creating blazor-server component</h1>
<p>First, we create the blazor-server component. Right-click your solution folder again, to add a new project:</p>
<p><img src="Resources/img_3.png" alt="img_3.png" /></p>
<ol>
<li>ASP.NET contains everything web, within .NET</li>
<li>Give your project a name</li>
<li>Select the type. There is also something called Blazor wasm. But we use <strong>Blazor Server</strong></li>
<li>No authentication, we will create our own later</li>
<li>No docker support</li>
<li>Create the project</li>
</ol>
<p>Wonderful.</p>
<p>Start by creating a new directory in your blazor project, call it Services. Here we will eventually put all interfaces, the blazor app needs, to get data from somewhere.</p>
<p>Next, the file data component.</p>

</div>
<div class="tab">
<h1>File data component</h1>
<p>Create a new project again, this time a library:</p>
<p><img src="Resources/img_5.png" alt="img_5.png" /></p>
<p>Again, delete the Class1.cs.</p>
<p>We then need to add dependencies to other components, so that the FileData component can use classes from other components.
Inside the FileData component, right-click the Dependencies:</p>
<p><img src="Resources/img_7.png" alt="img_7.png" /></p>
<p>Then select both Blazor and Domain components.</p>
<p><img src="Resources/img_8.png" alt="img_8.png" /></p>
<p>This means your FileData component can now access namespaces and classes in those two components.</p>

</div>
<div class="tab">
<h1>FileContext</h1>
<p>We will now create the class, which can save and retrieve data. We'll be serializing objects to JSON, and write to a
file. It's a pretty simple substitute for a database.</p>
<p>Create a new directory, DataAccess, inside the FileData component.</p>
<p>Inside this directory, create a new class, call it FileContext:</p>
<p><img src="Resources/img_6.png" alt="img_6.png" /></p>
<p>Below, the content of the FileContext will be explained.
The final version of the class can be found <a href="https://github.com/TroelsMortensen/BlazorTodoApp/blob/Part1/FileData/DataAccess/FileContext.cs">here</a></p>
<h3>Fields</h3>
<p>You need to define the file, which should hold the data. And we need a collection of Todo objects:</p>
<pre><code class="line-numbers language-csharp">private string todoFilePath = &quot;todos.json&quot;;
private ICollection&lt;Todo&gt; todos;
</code></pre>
<p>We use a collection, because this class does not have get-methods to access objects at an index. This is to simulate how you will work with a database in the future.</p>
<h3>Constructor</h3>
<p>Then we need a constructor. We wish to insert some dummy data into the file, if nothing exists, just so we have
something to work with. The constructor looks like this:</p>
<pre><code class="line-numbers language-csharp">public FileContext()
{
    if (!File.Exists(todoFilePath))
    {
        Seed();
    }
}
</code></pre>
<p>What's going on?</p>
<p>Lines:<br />
3 Here we check if there is already a file at the given path.<br />
5 If there's no file, we call the <code>Seed()</code>method. This will be implemented shortly. Its purpose is to insert dummy data.</p>
<p>We now need the <code>Seed()</code> method. It looks like this:</p>
<pre><code class="line-numbers language-csharp">private void Seed()
{
    Todo[] ts = {
        new Todo(1, &quot;Dishes&quot;) {
            Id = 1,
        },
        new Todo(1, &quot;Walk the dog&quot;) {
            Id = 1,
        },
        new Todo(2, &quot;Do DNP homework&quot;) {
            Id = 3,
        },
        new Todo(3, &quot;Eat breakfast&quot;) {
            Id = 4,
        },
        new Todo(4, &quot;Mow lawn&quot;) {
            Id = 5,
        },
    };
    todos = ts.ToList();
    SaveChanges();
}
</code></pre>
<p>In the above method an array of Todos are created. Notice here, we manually set the Id of each todo. We only do this for this specific dummy data.
In the end the array is stored in the <code>todos</code> field variable. And then we call a currently-non-existing method, <code>SaveChanges</code>.</p>
<h3>Save changes</h3>
<p>The purpose of this method is to take the content of the <code>todos</code> field, and put into the file.</p>
<pre><code class="line-numbers language-csharp">public void SaveChanges()
{
    string serialize = JsonSerializer.Serialize(todos);
    File.WriteAllText(todoFilePath,serialize);
}
</code></pre>
<p>Later, when we work with databases through Entity Framework Core, you will also need to call SaveChanges after interacting with the database. So, we practice the workflow here.</p>
<h3>Load data</h3>
<p>We need a method to read from the file, so we can retrieve data.</p>
<pre><code class="line-numbers language-csharp">private void LoadData()
{
    string content = File.ReadAllText(todoFilePath);
    todos = JsonSerializer.Deserialize&lt;List&lt;Todo&gt;&gt;(content);
}
</code></pre>
<p>What's going on here?</p>
<p>The method is private, because this class should be responsible for determining when to load data.<br />
We read all the content of the file, it returns a string.<br />
Then that string is deserialized into a <code>List&lt;Todo&gt;</code>, and assigned to the field variable.</p>
<h3>Accessing data</h3>
<p>Finally, we need a way to actually get the data. We'll make a property, not a get-method. This is, again, to simulate the way you'll interact with the database in the future.</p>
<pre><code class="line-numbers language-csharp">public ICollection&lt;Todo&gt; Todos
{
    get
    {
        LoadData();
        return todos;
    }
}
</code></pre>
<p>Here, whenever someone wants to get the collection of Todos, they will call the <code>Todos</code> property. This will call <code>LoadData()</code> to instantiate the collection, and then return it.</p>
<p>The next step will be to add a Data Access Object with the usual <a href="https://en.wikipedia.org/wiki/Create,_read,_update_and_delete">CRUD</a> operations.</p>
<p>The final version of the class can be found <a href="https://github.com/TroelsMortensen/BlazorTodoApp/blob/Part1/FileData/DataAccess/FileContext.cs">here</a></p>

</div>
<div class="tab">
<h1>Data access interfaces</h1>
<p>As mentioned previously, our Blazor app will initially get data from the just created FileContext.
Later we wish to change this, so the data comes from a server.
I.e. we wish to swap out the implementation of these interfaces.</p>
<p>In order to not have to change the dependencies of the Blazor component, we put the interfaces in the Blazor component.
It will eventually look something like this:</p>
<p><img src="Resources/img_9.png" alt="img_9.png" /></p>
<p>We currently have the Blazor component, and the FileData component. In a later tutorial, we will expand with the HttpServices component. At that point, we wish to swap out which implementation the Blazor component uses.</p>
<p>Because we have applied the dependency inversion principle,
it should be little work to swap from using file storage,
to using a client to get data from a server.</p>
<p>But first, we need to define the interfaces.</p>
<h3>Blazor -&gt; Domain dependency</h3>
<p>First, we need to let the Blazor app know about the Domain component, so that it can use the Todo class.</p>
<p><img src="Resources/img_10.png" alt="img_10.png" /></p>
<p>Add a reference to Domain.</p>
<h3>ITodoService</h3>
<p>In the Blazor component, inside the Services directory, create a new interface, ITodoService:</p>
<pre><code class="line-numbers language-csharp">using System.Collections.Generic;
using System.Threading.Tasks;

namespace Blazor.Services;

public interface ITodoService
{
    public Task&lt;ICollection&lt;Todo&gt;&gt; GetAsync();
    public Task&lt;Todo&gt; GetById(int id);
    public Task&lt;Todo&gt; AddAsync(Todo todo);
    public Task DeleteAsync(int id);
    public Task UpdateAsync(Todo todo);
}
</code></pre>
<p>We are using asynchronous programming, so all methods returns a Task, and method names are suffixed 'Async'.</p>
<p>We have here the standard CRUD operations. Notice how the <code>AddAsync</code> method returns a Todo object. This is because the Todo object is finalized when storing it, i.e. it gets an Id assigned from the FileData component, at some later point. We return it, so the finalized object can be displayed to the user, should we want to.</p>
<p>Next up, we need the adapters to let the Blazor app get data from the FileContext. These are our Data Access Objects.</p>

</div>
<div class="tab">
<h1>Data Access Object</h1>
<p>We currently only have one type of domain object, so we just need a single DAO to provide CRUD operations.</p>
<p>This DAO should be located in the FileData component, either put it in the DataAccess directory or create a new.</p>
<p><img src="Resources/img_11.png" alt="img_11.png" /></p>
<p>This class should implement the <code>ITodoService</code> interface from the Blazor component, and provide implementations for the methods.</p>
<p>First, we need a FileContext. We will just instantiate this in the constructor:</p>
<pre><code class="line-numbers language-csharp">public class TodoFileDAO : ITodoService
{
    private FileContext fileContext;

    public TodoFileDAO(FileContext fileContext)
    {
        this.fileContext = fileContext;
    }
    
    // ...
</code></pre>
<p>We use constructor dependency injection for the FileContext,
so we don't have to manually create a new instance.
This is generally a good approach. Remember SDJ2 and MVVM:
Controllers, VMs, Models got what they needed through constructors.
We will get the framework to handle this dependency injection for us.</p>

</div>



    </div>
</div>
<script>
    showTab(currentTab);
</script>

</body>
</html>
