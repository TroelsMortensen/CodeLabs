<!DOCTYPE html>
<html>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link href="https://fonts.googleapis.com/css?family=Raleway" rel="stylesheet">
<link href="./../../Resources/Style.css" rel="stylesheet">
<link href="./../../Resources/prism.css" rel="stylesheet">
<script src="./../../Resources/TabNavigavtor.js"></script>
<link rel="shortcut icon" href="./../../Resources/CodeIcon.png">
<title>VIA Codelabs</title>
<body>
<script src="./../../Resources/prism.js"></script>

<div>
    <a href="./../../index.html" class="homelink">HOME</a>
</div>
<div style="display:flex;width:100%;height:100%;padding-top:64px">
    <div id="steps-list">
        <ol>
            <li class="step" onclick="setTab(0)">1 Introduction</li>
<li class="step" onclick="setTab(1)">2 Overview</li>
<li class="step" onclick="setTab(2)">3 Shared project</li>
<li class="step" onclick="setTab(3)">4 Web API</li>
<li class="step" onclick="setTab(4)">5 UserService</li>
<li class="step" onclick="setTab(5)">6 AuthController</li>
<li class="step" onclick="setTab(6)">7 Test login</li>
<li class="step" onclick="setTab(7)">8 Policy guarding</li>
<li class="step" onclick="setTab(8)">9 More guarding</li>
<li class="step" onclick="setTab(9)">10 The WeatherForecast</li>
<li class="step" onclick="setTab(10)">11 Blazor</li>
<li class="step" onclick="setTab(11)">12 Wrap in auth</li>
<li class="step" onclick="setTab(12)">13 AuthService</li>
<li class="step" onclick="setTab(13)">14 AuthenticationStateProvider</li>
<li class="step" onclick="setTab(14)">15 Login page</li>
<li class="step" onclick="setTab(15)">16 Login buttons</li>
<li class="step" onclick="setTab(16)">17 Test login</li>
<li class="step" onclick="setTab(17)">18 Auth functionality</li>
<li class="step" onclick="setTab(18)">19 Block page access</li>
<li class="step" onclick="setTab(19)">20 The auth context</li>
<li class="step" onclick="setTab(20)">21 The auth state</li>
<li class="step" onclick="setTab(21)">22 Conclusion</li>
<li class="step" onclick="setTab(22)">23 Optimization</li>

        </ol>
    </div>
    <div id="container" action="/action_page.php">
        <div style="overflow:auto;">

            <div style="float:right; margin:10px">
                <button type="button" id="prevBtn" class="prev-button" onclick="nextPrev(-1)">Previous</button>
                <button type="button" id="nextBtn" class="next-button" onclick="nextPrev(1)">Next</button>
            </div>
        </div>

        <!-- One "tab" for each step in the form: -->

        <div class="tab">
<hr/><h1 id="welcome">Welcome</h1><hr/>
<p>This is a first draft. If you have comments, input, feedback, whatever, send me an email: trmo@via.dk.</p>
<p>This tutorial will take you through how to set up a simple login system for Blazor-WASM in combination with a Web API.</p>
<p>This approach will use your own User/Profile/Account type, or whatever you call it. You will manage storage of the users.
We will use the built in <code>AuthenticationStateProvider</code> class, extend it to provide the necessary authorization information.</p>
<p>We will not be using the Identity framework. That's a different approach.</p>
<p>We will go through how to set it up from a new default Blazor-WASM project.
Later, you can then reuse the steps to add login/authorization functionality to other Blazor-WASM apps.</p>
<h2 id="overview">Overview</h2>
<p>We are going to use an approach called JWT authentication.</p>
<p>This means that when logging in through the front end, the request is sent to the Web API, and (if the credentials are valid) a JSON Web Token (JWT) is sent back again, containing various information, including information about the User profile.</p>
<p>So, we are going to use a Web API for the back-end and Blazor-WASM for the front end.<br />
We will use various built-in tools in Blazor to manage authentication and authorization of various sites of the app.<br />
We will secure our Web API endpoints with authentication and authorization too, so that other programmers don't just create their own app and abuse our endpoints.</p>
<h3 id="disclaimer">Disclaimer</h3>
<p>The purpose of this tutorial is to get a login-system up and running, but not necessarily understand every detail. There will be black box magic moments, where the interested reader can do further research.</p>
<h3 id="result">Result</h3>
<p>The final project can be found on GitHub <a href="https://github.com/TroelsMortensen/JwtAuth">here</a></p>

</div>
<div class="tab">
<hr/><h1 id="overview">Overview</h1><hr/>
<p>First, an overview of the resulting system is presented.</p>
<p>We are going to need 3 libraries,</p>
<ol>
<li>The Web API</li>
<li>Blazor WASM</li>
<li>A shared library for classes/functionality needed by both projects.</li>
</ol>
<p>The various endpoints on the Web API will be secured by policies and whether the endpoint, when called, is given a valid JWT.
So, un-authorized/un-authenticated requests to the Web API will automatically be refused.</p>
<p>For the Blazor app, the authentication/authorization will be used to show/hide various parts of the UI, i.e. you can only see certain pages, tabs, buttons, etc, if your logged in user has the correct privileges.</p>
<h3 id="component-diagram">Component diagram</h3>
<p>The below diagram shows the dependencies between our three projects.</p>
<p><img src="Resources/ComponentDiagram.png" alt="img.png" /></p>
<p>You could put an arrow from BlazorWASM to WebAPI, as HTTP requests are made from Blazor to the endpoints in the Web API.
But as that dependency is not explicit in the solution, it is left out.</p>
<h3 id="class-diagram">Class diagram</h3>
<p>The below class diagram shows the end result. It may not be an exact match, as the last part of this tutorial will contain some optimizations, resulting in changes to the system.</p>
<p>First the overview is provided. Below, various parts of the diagram will be explained in detail.</p>
<p><img src="Resources/ClassDiagram.svg" alt="dia" /></p>
<p>The grey boxes are projects (components). Below, each project is discussed.</p>
<h4 id="blazor-app">Blazor app</h4>
<p>This is the Blazor app.</p>
<p><img src="Resources/BlazorAppClassDiagram.png" alt="dia" /></p>
<p>Notice how Blazor pages are marked as the stereotype <code>&lt;&lt;page&gt;&gt;</code>. Similarly, components are marked <code>&lt;&lt;comp&gt;&gt;</code>.</p>
<p>Most of the pages don't do much in themselves, they are just there to demonstrate how to show/hide parts of the UI based on the authorization state. These &quot;dumb&quot; pages include: BlockPageWithPolicy, MustBeLoggedInToView, PolicyExampleManual, PolicyExampleWithComponent, ShowCredentialsAuthState, ShowCredentialsContext.</p>
<p>The <code>Login</code> page is used by the user to log in. The credentials are forwarded to the <code>IAuthService</code>, and the implementation, <code>JwtAuthService</code> will make a request to the Web API. Once the response is received, a notification is sent to the CustomAuthProvider, which will cause a reaction in the UI according to the new authorization state. I.e., the dotted arrow from JwtAuthService to CustomAuthProvider does not in this case mean a &quot;dependency&quot;, I have abused notation a little. It just means a notification is sent. Think observer design pattern.</p>
<p>The <code>FetchData</code> page is included in the Blazor template, i.e. it is there upon creation. We keep it to show how to get data from the Web API, by using the <code>IWeatherService</code>, and its implementation, <code>HttpWeatherService</code>.</p>
<p>The <code>LoginButtons</code> is a component used by the MainLayout to give a little login-icon on the top-right of the app. This will be elaborated upon later.</p>
<p>Finally, the <code>CustomAuthProvider</code> is the class responsible for providing the Blazor app auth functionality with the authorization state. You may notice the method <code>GetAuthenticationStateAsync()</code>.
This method is called by the Blazor framework, whenever there is something in the UI which needs to know about the authorization state. If you wish to show/hide a button, the Blazor framework will ask this class, through this method, about the currently logged in user, and based on that user's credentials, the button will be either shown or hidden.<br />
CustomAuthProvider does not know about the user itself, but asks the IAuthService about the credentials every time.</p>
<h4 id="shared">Shared</h4>
<p>This component contains classes and features which both the Blazor app and the Web API needs to know about.</p>
<p><img src="Resources/SharedClassDiagram.png" alt="dia" /></p>
<p>All model classes are put here, so that we do not need to have copies of <code>User</code> in both Web API and Blazor projects.</p>
<p>We have the Data Transfer Objects here. Whenever you need to log in, you just need to provide a username and a password. We could have used the User class to send this information from Blazor to Web API, and just leave most properties empty.
But it is common practice to create specialized Data Transfer Objects, which contains just the properties needed. It is up to you, which approach you will use.</p>
<p>The <code>AuthorizationPolicies</code> is a class, where we define policies. The policies are the same on both Blazor and Web API, so they are defined here.</p>
<p>Policies are set of rules to be used to either provide or block access, based on a users credentials. For example:</p>
<ul>
<li>You can only view this image, if you are older than 18</li>
<li>You can only click this button, if your email is from VIA</li>
<li>You can only access this page, if your security level is above 3</li>
</ul>
<p>The same applies for the Web API:</p>
<ul>
<li>You can only call this endpoint, if you are older than 18</li>
<li>You can only call this endpoint, if your email is from VIA</li>
</ul>
<p>So, we can use policies to control our UI, and we can use policies to control who can call our Web API endpoints, so they are not just open to the entire world. That is potentially very dangerous, as anyone can create and delete our data.</p>
<h4 id="web-api">Web API</h4>
<p>This is the Web API:</p>
<p><img src="Resources/WebAPIClassDiagram.png" alt="dia" /></p>
<p>The <code>AuthController</code> is used to login, and receive a JWT. You can also register a new <code>User</code> here, however, that is not really included in this tutorial, and instead left to the reader, to implement. If they wish.<br />
This class will use the <code>IUserService</code> to validate the login credentials, and if valid, will generate a JWT and return it to the caller, i.e. the Blazor app.</p>
<p>The <code>TestController</code> has a few dummy endpoints to demonstrate how to use policies and other approaches, to block access if the caller is un-authorized.</p>
<p>The <code>WeatherForecastController</code> just returns a set of random <code>WeatherForecast</code> objects to be displayed on the page <code>FetchData</code>.</p>
<h3 id="now-lets-get-started-on-implementation">Now, let's get started on implementation.</h3>

</div>
<div class="tab">
<hr/><h1 id="shared-project">Shared project</h1><hr/>
<p>We will start here, as this project does not depend on the others.</p>
<p>First, create a new class library, call it <code>Shared</code>:</p>
<p><img src="Resources/CreateLibrary.gif" alt="createlib" /></p>
<p>Delete the <code>Class1.cs</code> file.</p>
<h3 id="nuget-packages">NuGet packages</h3>
<p>Next, we must add a package to this project, to get access to various functionality regarding authorization and policies.</p>
<p>Add the package &quot;Microsoft.AspNetCore.Authorization&quot;. <strong>Pick the latest non-preview version!</strong>.</p>
<p><img src="Resources/AddAuthPackage.gif" alt="createlib" /></p>
<h3 id="directories">Directories</h3>
<p>Create three directories inside the Shared project:</p>
<ul>
<li>Auth</li>
<li>Dtos</li>
<li>Models</li>
</ul>
<p><img src="Resources/SharedDirs.png" alt="img.png" /></p>
<h3 id="model-classes">Model classes</h3>
<p>Inside the Models directory create a User class:</p>
<pre><code class="line-numbers language-csharp">public class User
{
    public string Username { get; set; }
    public string Password { get; set; }
    public string Email { get; set; }
    public string Domain { get; set; }
    public string Name { get; set; }
    public string Role { get; set; }
    public int Age { get; set; }
    public int SecurityLevel { get; set; }
}
</code></pre>
<p>These properties are just to demonstrate various ways to use auth policies. You may not need them for you own project, but in this tutorial they are useful.</p>
<p>Inside the Models directory create a WeatherForecast class:</p>
<pre><code class="line-numbers language-csharp">public class WeatherForecast
{
    public DateTime Date { get; set; }

    public int TemperatureC { get; set; }

    public int TemperatureF =&gt; 32 + (int)(TemperatureC / 0.5556);

    public string? Summary { get; set; }
}
</code></pre>
<p>This class will later also be defined by default in Blazor and Web API projects, which must then be deleted. You will be told when.</p>
<h3 id="dto">Dto</h3>
<p>Inside the Dtos directory create a UserLoginDto class:</p>
<pre><code class="line-numbers language-csharp">public class UserLoginDto
{
    public string Username { get; init; }
    public string Password { get; init; }
}
</code></pre>
<p>Notice the <code>init;</code>. This is a specific kind of <code>set;</code>, meaning you can only set this values, when the object is created, but not later modify it. It is not strictly necessary, but in general it is good practice to only allow what is supposed to be available. We don't intend to change the values after creation, so we don't allow that.
It is just a minor detail.</p>
<h3 id="auth">Auth</h3>
<p>Finally, the class which will define the policies.</p>
<p>Inside the Auth directory create a class called <code>AuthorizationPolicies</code>:</p>
<pre><code class="line-numbers language-csharp">public static class AuthorizationPolicies
{
    public static void AddPolicies(IServiceCollection services)
    {
        services.AddAuthorizationCore(options =&gt;
        {
            options.AddPolicy(&quot;MustBeVia&quot;, a =&gt;
                a.RequireAuthenticatedUser().RequireClaim(&quot;Domain&quot;, &quot;via&quot;));
    
            options.AddPolicy(&quot;SecurityLevel4&quot;, a =&gt;
                a.RequireAuthenticatedUser().RequireClaim(&quot;SecurityLevel&quot;, &quot;4&quot;, &quot;5&quot;));
    
            options.AddPolicy(&quot;MustBeTeacher&quot;, a =&gt;
                a.RequireAuthenticatedUser().RequireClaim(&quot;Role&quot;, &quot;Teacher&quot;));
    
            options.AddPolicy(&quot;SecurityLevel2OrAbove&quot;, a =&gt;
                a.RequireAuthenticatedUser().RequireAssertion(context =&gt;
                {
                    Claim? levelClaim = context.User.FindFirst(claim =&gt; claim.Type.Equals(&quot;SecurityLevel&quot;));
                    if (levelClaim == null) return false;
                    return int.Parse(levelClaim.Value) &gt;= 2;
                }));
        });
    }
}
</code></pre>
<p>You must import:</p>
<ul>
<li>using Microsoft.Extensions.DependencyInjection;</li>
<li>using System.Security.Claims;</li>
</ul>
<p>to fix compiler errors.</p>
<p>Now, what's going on here? This static method will be called from the <code>Program.cs</code> classes in both Web API and Blazor, and it will add authorization policies to the framework.</p>
<p>Each line starting with <code>options.AddPolicy...</code> adds a new policy, which can then be used to guard UI elements or Web API endpoints.</p>
<p><strong>The first policy</strong> is called &quot;MustBeVia&quot;, that's the name of it, and this name is used for reference. Then the lambda expression says:</p>
<ul>
<li><code>RequireAuthenticatedUser()</code>, meaning to fulfill this policy the user is logged in, and authenticated.</li>
<li><code>RequireClaim(&quot;Domain&quot;, &quot;via&quot;)</code>, meaning the user must have a claim, where the type is &quot;Domain&quot;, and the value is &quot;via&quot;. So, the Domain property of that specific user object must have the value &quot;via&quot;.</li>
</ul>
<p><strong>The next policy</strong>, called &quot;SecurityLevel4&quot; also requires an authenticated user, and that the &quot;SecurityLevel&quot; is <em>either</em> &quot;4&quot; or &quot;5&quot;. This illustrates you can add any number of valid values. The RequireClaim method takes first the Claim name, and then any number of arguments.</p>
<p><strong>The third policy</strong>, &quot;MustBeTeacher&quot; says that the &quot;Role&quot; of the user must be &quot;Teacher&quot;.</p>
<p><strong>The fourth policy</strong> is an example of slightly more complicated logic. We use the method <code>RequireAssertion()</code>, and if the logic inside returns &quot;true&quot;, the user fulfills this policy.<br />
The <code>context</code> contains a User property, of the type <code>ClaimsPrincipal</code>. This is a type of object, which the Authentication framework understands, it contains information about the user.<br />
We use <code>FindFirst()</code> to find the first Claim with the Type of &quot;SecurityLevel&quot;. If no such claim exists, the user has no security level, and we return &quot;false&quot;. If the claim is found, we check if the security level is above a certain value, in this case level 2.</p>
<h3 id="what-is-a-claimsprincipal">What is a ClaimsPrincipal?</h3>
<p>In your project, either this tutorial, or other projects like SEP3, you will probably define some kind of User object, maybe you call it User, Account, or something else. But it is a class you define to hold information about a user.<br />
This is a custom object, and the Authentication functionality of Blazor and Web API obviously does not know about your specific user type.</p>
<p>Therefore we must convert our custom User into a class which the framework understands. That class is the ClaimsPrincipal. How it's done will be covered later.</p>

</div>
<div class="tab">
<hr/><h1 id="the-web-api">The Web API</h1><hr/>
<p>Next up is the Web API. We will do the Blazor app last.</p>
<p>Create a new Web API project, give it a name, e.g. &quot;WebAPI&quot;:</p>
<p><img src="Resources/CreateWebAPI.gif" alt="" /></p>
<h3 id="add-inter-project-dependency">Add inter-project dependency</h3>
<p>We must add a dependency from <strong>Web API</strong> project to <strong>Shared</strong> Project, so that the Web API can use classes and functionality defined in the Shared project.</p>
<p>Right click the &quot;Dependencies&quot; inside WebApi project:</p>
<p><img src="Resources/AddRef.png" alt="img.png" /></p>
<p>Then in the opened window select the Shared project and click <kbd>Add</kbd>.</p>
<p><img src="Resources/SelectShared.png" alt="img_1.png" /></p>
<h3 id="clean-up">Clean up</h3>
<p>The Web API template project comes with a <code>WeatherForecast.cs</code> class. Delete it.</p>
<p>Open Controllers/WeatherForecastController.cs, and quick fix (<kbd>alt</kbd> + <kbd>enter</kbd>) the compile error, i.e. import the WeatherForecast class from the Shared/Models.</p>
<h3 id="add-nuget-packages">Add NuGet packages</h3>
<p>This project also needs a package to handle JWT creation and authorization.</p>
<p>Similarly to how you added a package to the Shared project, add the following package to the Web API project:</p>
<ul>
<li>Microsoft.AspNetCore.Authentication.JwtBearer</li>
</ul>
<p>At the time of writing, the version of the package is 6.0.8. Pick the latest non-preview package.</p>
<p><img src="Resources/AddJwtPackage.png" alt="" /></p>
<h2 id="modify-program.cs">Modify Program.cs</h2>
<p>Open the Program.cs class.</p>
<h3 id="tell-the-app-to-use-authentication">Tell the app to use authentication</h3>
<p>Add the following line anywhere above <code>app.Run()</code>, and below <code>var app = builder.Build();</code>:</p>
<pre><code class="line-numbers language-csharp">app.UseAuthentication();
</code></pre>
<p>This adds authentication middleware, i.e. somewhere between the Web API server recieves the request, and our controller endpoint is called, a class will now handle authentication checks, and if the caller is not authenticated or authorized as required, a &quot;401 - Unauthorized&quot; error will be returned to the caller.</p>
<h3 id="tell-the-app-to-accept-requests-from-the-browser">Tell the app to accept requests from the browser</h3>
<p>Next, add the following code anywhere above <code>app.Run()</code> and below <code>var app = builder.Build();</code>:</p>
<pre><code class="line-numbers language-csharp">app.UseCors(x =&gt; x
    .AllowAnyMethod()
    .AllowAnyHeader()
    .SetIsOriginAllowed(origin =&gt; true) // allow any origin
    .AllowCredentials());
</code></pre>
<p>This is needed later when our Blazor app, running in the browser, needs to contact localhost. For security reasons (I believe) this is not allowed by default.</p>
<h3 id="add-authentication-with-info-about-jwt">Add authentication with info about JWT</h3>
<p>Finally, add the following piece of code anywhere above <code>var app = builder.Build();</code>:</p>
<pre><code class="line-numbers language-csharp">builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme).AddJwtBearer(options =&gt;
{
    options.RequireHttpsMetadata = false;
    options.SaveToken = true;
    options.TokenValidationParameters = new TokenValidationParameters()
    {
        ValidateIssuer = true,
        ValidateAudience = true,
        ValidAudience = builder.Configuration[&quot;Jwt:Audience&quot;],
        ValidIssuer = builder.Configuration[&quot;Jwt:Issuer&quot;],
        IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(builder.Configuration[&quot;Jwt:Key&quot;]))
    };
});
</code></pre>
<p>Import the necessary stuff, quick fix it.
A bunch of stuff is happening here. I stole this from an example, so I don't know all the details.</p>
<p>You may notice how we retrieve information from the appsettings.json, e.g. in line 9, 10, 11 above with the:</p>
<p><code>builder.Configuration[&quot;Jwt:Audience&quot;]</code></p>
<p>This goes to the Jwt section, then the Audience line, getting the value. Similar with the other two lines. Further details below.</p>
<h3 id="add-policies">Add policies</h3>
<p>Add the following line of code anywhere <strong>above</strong> <code>var app = builder.Build();</code>:</p>
<pre><code class="line-numbers language-csharp">AuthorizationPolicies.AddPolicies(builder.Services);
</code></pre>
<p>Quick fix import compile errors.</p>
<p>This is our class from the Shared project, so here we tell the Web API to add authorization policies.</p>
<h2 id="appsettings.json">appsettings.json</h2>
<p>Open the WebApi/appsettings.json file. This contains various settings for our program.</p>
<p>We need to add information about the JWT to generate.</p>
<p>Add a &quot;Jwt&quot; section, so your file content looks like this:</p>
<pre><code class="line-numbers language-json">{
  &quot;Logging&quot;: {
    &quot;LogLevel&quot;: {
      &quot;Default&quot;: &quot;Information&quot;,
      &quot;Microsoft.AspNetCore&quot;: &quot;Warning&quot;
    }
  },
  &quot;AllowedHosts&quot;: &quot;*&quot;,
  &quot;Jwt&quot;: {
    &quot;Key&quot;: &quot;This Is My Random Secret Key Which Is At Least Sixteen Characters&quot;,
    &quot;Issuer&quot;: &quot;JWTAuthenticationServer&quot;,
    &quot;Audience&quot;: &quot;JWTServiceBlazorWasmClient&quot;,
    &quot;Subject&quot;: &quot;JWTServiceAccessToken&quot;
  }
}
</code></pre>
<p>Here we have specified various settings to be used when generating the JWT.</p>
<ul>
<li>The &quot;Key&quot; is a secret key used when encrypting. It must be at least 16 characters, and can just be anything random.</li>
<li>The Issuer is who generated the JWT</li>
<li>The Audience is who the JWT is intended for</li>
<li>The Subject... I'm not sure</li>
</ul>

</div>
<div class="tab">
<hr/><h1 id="userservice-implementation">UserService implementation</h1><hr/>
<p>We need a class to handle various User related logic.</p>
<p>In a normal Web API you might have at least three layers:</p>
<ol>
<li>Controllers, to receive incoming requests</li>
<li>Services, to contain logic, validation, etc</li>
<li>Repositories/Data Access Objects to manage persisting data</li>
</ol>
<p>We will skip the third layer, as we are just creating a &quot;dummy database&quot;. In this case a List with two Users hardcoded.</p>
<h3 id="the-service">The Service</h3>
<p>Create a new directory: Services.</p>
<h4 id="interface">Interface</h4>
<p>In here, create a new interface: <code>IAuthService</code>.</p>
<p>It looks like this:</p>
<pre><code class="line-numbers language-csharp">public interface IAuthService
{
    Task&lt;User&gt; GetUser(string username, string password);
    Task RegisterUser(User user);
}
</code></pre>
<p>Import the User.</p>
<p>We are not really going to use the <code>RegisterUser()</code> method, it's just here as an example.</p>
<p>We use return types of Task, even though in this instance nothing will be asynchronous. But, should we wish to improve
on the example, e.g. by adding a database, this would require asynchronous code, so it's better to be ready.</p>
<h4 id="implementation">Implementation</h4>
<p>Next, the implementation, <code>AuthService</code>. Just put this class in the same directory, Services.</p>
<p>It looks like this:</p>
<pre><code class="line-numbers language-csharp'">public class AuthService : IAuthService
{

    private readonly IList&lt;User&gt; users = new List&lt;User&gt;
    {
        new User
        {
            Age = 36,
            Email = &quot;trmo@via.dk&quot;,
            Domain = &quot;via&quot;,
            Name = &quot;Troels Mortensen&quot;,
            Password = &quot;onetwo3FOUR&quot;,
            Role = &quot;Teacher&quot;,
            Username = &quot;trmo&quot;,
            SecurityLevel = 4
        },
        new User
        {
            Age = 34,
            Email = &quot;jakob@gmail.com&quot;,
            Domain = &quot;gmail&quot;,
            Name = &quot;Jakob Rasmussen&quot;,
            Password = &quot;password&quot;,
            Role = &quot;Student&quot;,
            Username = &quot;jknr&quot;,
            SecurityLevel = 2
        }
    };

    public Task&lt;User&gt; ValidateUser(string username, string password)
    {
        User? existingUser = users.FirstOrDefault(u =&gt; 
            u.Username.Equals(username, StringComparison.OrdinalIgnoreCase));
        
        if (existingUser == null)
        {
            throw new Exception(&quot;User not found&quot;);
        }

        if (!existingUser.Password.Equals(password))
        {
            throw new Exception(&quot;Password mismatch&quot;);
        }

        return Task.FromResult(existingUser);
    }

    public Task RegisterUser(User user)
    {

        if (string.IsNullOrEmpty(user.Username))
        {
            throw new ValidationException(&quot;Username cannot be null&quot;);
        }

        if (string.IsNullOrEmpty(user.Password))
        {
            throw new ValidationException(&quot;Password cannot be null&quot;);
        }
        // Do more user info validation here
        
        // save to persistence instead of list
        
        users.Add(user);
        
        return Task.CompletedTask;
    }
}
</code></pre>
<p>At the top, we have an <code>IList&lt;User&gt;</code> field. It is instantiated to contain two user objects.</p>
<p>The first method, <code>ValidateUser</code>, will take the two relevant arguments.<br />
The first line of the method will look through the <code>users</code> list, and find the first User object, which matches the
criteria specified by the lambda expression, i.e. a User object with the same username as provided with the method
parameter.</p>
<p>If no object is found, an exception is thrown. This can then be handled somewhere else (in our case the Controllers).</p>
<p>Then the passwords are checked. Again, if the wrong password is provided, an exception is thrown.</p>
<p>Finally, if a user is found, and the password is correct, we return that user object.</p>
<p>We do it with</p>
<pre><code class="line-numbers language-csharp">return Task.FromResult(existingUser)
</code></pre>
<p>because the return type is <code>Task&lt;User&gt;</code>, but the method is not marked <code>async</code>. In that case, we need to take the return
variable and put into a Task manually.</p>
<p>The RegisterUser method takes a User object, checks if the username is not null or empty. More checks could be made,
e.g. regarding length or whatever.<br />
Then the password is checked, again, maybe you want to have at least 16 characters, and upper and lower case characters,
and symbols and numbers. You can put that logic here.<br />
You probably also need to check if the username is unique. But all that is not really the purpose of this tutorial, so
it's left out.</p>
<p>The User object is added to the list. Then <code>Task.CompletedTask</code> is return, the equivalent of void, when working with
Task return types.</p>
<p>Notice that if you restart the Web API, your newly registered User is lost, because there is no persistence.</p>
<h3 id="add-service">Add service</h3>
<p>Finally, we need to add the interface and its implementation as services for the dependency inject framework.</p>
<p>In Program.cs add the following line anywhere above <code>var app = builder.Build();</code>:</p>
<pre><code class="line-numbers language-csharp">builder.Services.AddScoped&lt;IAuthService, AuthService&gt;();
</code></pre>

</div>
<div class="tab">
<hr/><h1 id="the-authcontroller">The AuthController</h1><hr/>
<p>Create a new class in the Controllers directory, call it <code>AuthController</code>.</p>
<h3 id="add-controller-stuff">Add Controller stuff</h3>
<p>First, modify it to look like this:</p>
<pre><code class="line-numbers language-csharp">[ApiController]
[Route(&quot;[controller]&quot;)]
public class AuthController : ControllerBase
</code></pre>
<p>Import what is necessary. This now marks this class as an ApiController, so that it's picked up by the Web API.<br />
We specify the route to hit this controller, so that it becomes <code>https://localhost:7130/auth</code>.</p>
<h3 id="constructor-and-fields">Constructor and fields</h3>
<p>Next, add the following fields and a constructor:</p>
<pre><code class="line-numbers language-csharp">private readonly IConfiguration config;
private readonly IAuthService authService;

public AuthController(IConfiguration config, IAuthService authService)
{
    this.config = config;
    this.authService = authService;
}
</code></pre>
<p>Import what is necessary.</p>
<p>Now, when this Controller is created (which happens whenever a request is made), the controller receives an instance of <code>IConfiguration</code>, which is used to read the &quot;appsettings.json&quot;, we modified earlier.</p>
<p>We also get an IAuthService injected, i.e. here we just depend on the interface, applying the Dependency Inversion Principle.</p>
<h3 id="claims-generation">Claims generation</h3>
<p>We need a method which can take a User (our own custom object) and turn it in to a Collection of Claims, which the programs understand.</p>
<pre><code class="line-numbers language-csharp">private List&lt;Claim&gt; GenerateClaims(User user)
{
    var claims = new[]
    {
        new Claim(JwtRegisteredClaimNames.Sub, config[&quot;Jwt:Subject&quot;]),
        new Claim(JwtRegisteredClaimNames.Jti, Guid.NewGuid().ToString()),
        new Claim(JwtRegisteredClaimNames.Iat, DateTime.UtcNow.ToString()),
        new Claim(ClaimTypes.Name, user.Username),
        new Claim(ClaimTypes.Role, user.Role),
        new Claim(&quot;DisplayName&quot;, user.Name),
        new Claim(&quot;Email&quot;, user.Email),
        new Claim(&quot;Age&quot;, user.Age.ToString()),
        new Claim(&quot;Domain&quot;, user.Domain),
        new Claim(&quot;SecurityLevel&quot;, user.SecurityLevel.ToString())
    };
    return claims.ToList();
}
</code></pre>
<p>Notice the <code>JwtRegisteredClaimNames</code> class is from</p>
<p><code>using System.IdentityModel.Tokens.Jwt;</code></p>
<p>Then import the other necessary things with quick fix.</p>
<p>The method takes a User, and creates an Array of Claims.<br />
The first three are JWT stuff, recommended to be included. They may not be strictly necessary.<br />
Then follows a Claim for each of the properties of our User object.</p>
<p>In your own projects your User object may look different, have different properties, and so you need to modify the above method accordingly, so that all relevant properties are turned into claims.</p>
<h3 id="jwt-generation">JWT generation</h3>
<p>This method will generate a JWT to be returned to the caller trying to log in.</p>
<pre><code class="line-numbers language-csharp">private string GenerateJwt(User user)
{
    List&lt;Claim&gt; claims = GenerateClaims(user);
    
    SymmetricSecurityKey key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(config[&quot;Jwt:Key&quot;]));
    SigningCredentials signIn = new SigningCredentials(key, SecurityAlgorithms.HmacSha512);
    
    JwtHeader header = new JwtHeader(signIn);
    
    JwtPayload payload = new JwtPayload(
        config[&quot;Jwt:Issuer&quot;],
        config[&quot;Jwt:Audience&quot;],
        claims, 
        null,
        DateTime.UtcNow.AddMinutes(60));
    
    JwtSecurityToken token = new JwtSecurityToken(header, payload);
    
    string serializedToken = new JwtSecurityTokenHandler().WriteToken(token);
    return serializedToken;
}
</code></pre>
<p>This method is somewhat black magic, but it will generate the JWT, given a User object.</p>
<p>The first line calls the previous method to get a List of Claims, i.e. our User converted to a list of key-value pairs containing the same information.</p>
<p>A JWT is signed by the server, so it cannot be tampered with. We do that in the next two lines.</p>
<p>We create a JwtPayload containing the relevant information:</p>
<ul>
<li>The Issuer, i.e. the server</li>
<li>The Audience, i.e. the Blazor app</li>
<li>The claims</li>
<li>null, whatever that is</li>
<li>An expiration date/time, meaning this JWT is only valid for a certain time, in this case 60 minutes. You can put whatever you wish here</li>
</ul>
<p>In the end the JWT is serialized into a string of seemingly random characters.</p>
<h3 id="login-endpoint">Login endpoint</h3>
<p>We need a last method, the endpoint to be accessed when making a login request.</p>
<p>It looks like this:</p>
<pre><code class="line-numbers language-csharp">[HttpPost, Route(&quot;login&quot;)]
public async Task&lt;ActionResult&gt; Login([FromBody] UserLoginDto userLoginDto)
{
    try
    {
        User user = await authService.ValidateUser(userLoginDto.Username, userLoginDto.Password);
        string token = GenerateJwt(user);
    
        return Ok(token);
    }
    catch (Exception e)
    {
        return BadRequest(e.Message);
    }
}
</code></pre>
<p>Do the imports.</p>
<p>We mark the endpoint as a Post request, and put the Route(&quot;login&quot;) resulting in the URI to hit this endpoint:</p>
<p><code>https://localhost:7130/auth/login</code></p>
<p>The method takes a <code>UserLoginDto</code> object, i.e. the class we created containing Username and Password.</p>
<p>The user info is validated, and upon success the JWT is generated and then returned.</p>
<p>If an exception happens, we return BadRequest. This is not particularly fine-grained, as we might wish to return different types of status codes, based on what went wrong. This is generally a better approach, but outside the scope of this tutorial.<br />
We could create various types of exceptions, and catch these specific exceptions across multiple catch-clauses, and return more specific status codes.</p>

</div>
<div class="tab">
<hr/><h1 id="testing-the-login">Testing the login</h1><hr/>
<p>It's time to test whether we can log in.</p>
<p>Normally, when you run your Web API, it opens a Swagger page. You can test the Login endpoint from here, and if you provide valid credentials, you should get a JWT back.</p>
<p>However, future calls which requires the JWT attached are more complicated to create with Swagger. We would have to add stuff in the Program.cs, and complicate things.</p>
<p>So, we'll do something else. We could use Postman, that would be easy enough, and if you prefer that, go for it.</p>
<h3 id="the.http-test-file">The .http test file</h3>
<p>Rider has a built in Http Client. It's pretty simple.</p>
<p>In the WebApi project folder, create a new file. Call it &quot;WebApiTests.http&quot;, or whatever, but the file type is &quot;.http&quot;:</p>
<p><img src="Resources/AddHttpFile.png" alt="img.png" /></p>
<p>And here's the file:</p>
<p><img src="Resources/AfterAddingHttp.png" alt="img.png" /></p>
<p>Open the file. In here we can define calls to our Web API.</p>
<p>Input the following:</p>
<pre><code class="line-numbers language-http">// log in as Troels
POST https://localhost:7130/auth/login
Content-Type: application/json

{ &quot;Username&quot; : &quot;trmo&quot;, &quot;Password&quot; : &quot;onetwo3FOUR&quot; }
</code></pre>
<p>The // marks a comment.</p>
<p>Then we define a &quot;POST&quot; request to &quot;https://localhost:7130/auth/login&quot;.</p>
<p>We define the Content-Type to be &quot;application/json&quot;, i.e. saying the request contains content in the format of JSON.</p>
<p>Finally a JSON object matching the format of our <code>UserLoginDto</code>.</p>
<p>Run the Web API, and then run your test. You should receive a JWT.</p>
<p><img src="Resources/LoginRequest.gif" alt="" /></p>
<p>In my test I received the following JWT:</p>
<p>&quot;eyJhbGciOiJIUzUxMiIsInR5cCI6IkpXVCJ9.
eyJzdWIiOiJKV1RTZXJ2aWNlQWNjZXNzVG9rZ
W4iLCJqdGkiOiI3MzFkNTk2MS0zYjU1LTQxMz
UtYjFkOS03MTlhMjI5NDYyY2MiLCJpYXQiOiI
xNC8wOC8yMDIyIDExOjUyOjIwIiwiaHR0cDov
L3NjaGVtYXMueG1sc29hcC5vcmcvd3MvMjAwN
S8wNS9pZGVudGl0eS9jbGFpbXMvbmFtZSI6In
RybW8iLCJodHRwOi8vc2NoZW1hcy5taWNyb3N
vZnQuY29tL3dzLzIwMDgvMDYvaWRlbnRpdHkv
Y2xhaW1zL3JvbGUiOiJUZWFjaGVyIiwiRGlzc
GxheU5hbWUiOiJUcm9lbHMgTW9ydGVuc2VuIi
wiRW1haWwiOiJ0cm1vQHZpYS5kayIsIkFnZSI
6IjM2IiwiRG9tYWluIjoidmlhIiwiU2VjdXJp
dHlMZXZlbCI6IjQiLCJleHAiOjE2NjA0ODE1N
DAsImlzcyI6IkpXVEF1dGhlbnRpY2F0aW9uU2
VydmVyIiwiYXVkIjoiSldUU2VydmljZUJsYXp
vcldhc21DbGllbnQifQ.A3ncVJsEcfYD5AArX
R3F1tKYr7QaL7HQ_ln-kwWZbwXpx2aQz08DgV
X2l8CnfZr7FxE8BzsrO7-A1Mru4Gklbg&quot;</p>
<p>If you are interested, you can go to <a href="https://jwt.io/">jwt.io</a> to unpack the token:</p>
<p><img src="Resources/UnpackedToken.png" alt="img.png" /></p>

</div>
<div class="tab">
<hr/><h1 id="guarding">Guarding</h1><hr/>
<p>If your program is running, stop it.</p>
<p>Now we need to test how we can apply policies to guard our endpoints in the controllers.</p>
<p>In the Controllers directory, create a new Controller, call it &quot;TestController&quot;.</p>
<p>Modify it to look like this:</p>
<pre><code class="line-numbers language-csharp">[ApiController]
[Route(&quot;[controller]&quot;)]
[Authorize]
public class TestController : ControllerBase
{
    
}
</code></pre>
<p>It's similar to the AuthController, but now notice the extra attribute <code>[Authorize]</code>.</p>
<p>This means this Controller can only be interacted with, if the caller provides a valid JWT.<br />
It means by default all endpoints can only be called with a valid token.<br />
If we leave out the attribute, all endpoints can by default be called by anonymous callers, i.e. no valid token is needed. It's up to you to decide whether to use it or not. For this test, we include the attribute.</p>
<p>We will create a couple of dummy methods, which just returns &quot;OK&quot;, but the point is we will guard these endpoints with policies and authentication.</p>
<h2 id="authorized-guard">Authorized guard</h2>
<p>The below method has nothing extra attached to it. Add it to the TestController:</p>
<pre><code class="line-numbers language-csharp">[HttpGet(&quot;authorized&quot;)]
public ActionResult GetAsAuthorized()
{
    return Ok(&quot;This was accepted as authorized&quot;);
}
</code></pre>
<p>This looks like a normal, very simple endpoint. We just return status code 200 - OK. With a message.</p>
<p>The HttpGet(&quot;authorized&quot;) just indicates the sub-route to this specific endpoint, e.g.:</p>
<p><code>https://localhost:7271/test/authorized</code></p>
<p>Let's test this.</p>
<h5 id="blocked-access">Blocked access</h5>
<p>Run your Web API.</p>
<p>Open the WebApiTests.http file.</p>
<p>We can separate multiple requests with ###, so, expand the content of your file to be:</p>
<pre><code class="line-numbers language-http">// log in as Troels
POST https://localhost:7271/auth/login
Content-Type: application/json

{ &quot;Username&quot; : &quot;trmo&quot;, &quot;Password&quot; : &quot;onetwo3FOUR&quot; }

###

GET https://localhost:7271/test/authorized
</code></pre>
<p>Notice the new GET request at the bottom, and the &quot;###&quot; separating it from the one above.</p>
<p>With your Web API running, run the GET request.<br />
The result should be something like:</p>
<pre><code>https://localhost:7271/test/authorized

HTTP/1.1 401 Unauthorized
Content-Length: 0
Date: Sun, 14 Aug 2022 12:07:45 GMT
Server: Kestrel
WWW-Authenticate: Bearer

&lt;Response body is empty&gt;


Response code: 401 (Unauthorized); Time: 76ms; Content length: 0 bytes
</code></pre>
<p>The bottom line says, we were not authorized to call this endpoint. That's because we did not provide a valid JWT.</p>
<h5 id="now-with-token">Now with token</h5>
<p>In your .http test file add a new request, remember to separate it with &quot;###&quot;:</p>
<p>Now, first, execute the first login request, resulting in a JWT.</p>
<p>Copy that JWT, and modify your latest GET request to something like this:</p>
<pre><code class="line-numbers language-http">GET https://localhost:7271/test/authorized
Authorization: Bearer eyJhbGciOiJIUzUxMiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJKV1RTZXJ2aWNlQWNjZXNzVG9rZW4iLCJqdGkiOiJmODhhMDJiMS0wMTdjLTQzOTktYTc3Zi1kMTVlNTk5MDA1ZGYiLCJpYXQiOiIxNC8wOC8yMDIyIDEyOjExOjE2IiwiaHR0cDovL3NjaGVtYXMueG1sc29hcC5vcmcvd3MvMjAwNS8wNS9pZGVudGl0eS9jbGFpbXMvbmFtZSI6InRybW8iLCJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL3dzLzIwMDgvMDYvaWRlbnRpdHkvY2xhaW1zL3JvbGUiOiJUZWFjaGVyIiwiRGlzcGxheU5hbWUiOiJUcm9lbHMgTW9ydGVuc2VuIiwiRW1haWwiOiJ0cm1vQHZpYS5kayIsIkFnZSI6IjM2IiwiRG9tYWluIjoidmlhIiwiU2VjdXJpdHlMZXZlbCI6IjQiLCJleHAiOjE2NjA0ODI2NzYsImlzcyI6IkpXVEF1dGhlbnRpY2F0aW9uU2VydmVyIiwiYXVkIjoiSldUU2VydmljZUJsYXpvcldhc21DbGllbnQifQ.w3qJXGPEYi6MMKH-t03KzryBmT7b7OqGJ6iEePDJuE06SI5hH27PS36Bo6QDrq1b_ykX5S0qxAfyJheSw-EDUA
</code></pre>
<p>This is how we provide a JWT along with our request. Notice the token above will not work with you. You will have to log in, and use that token.</p>
<p>Run the last GET request again, with the token. You should get back:</p>
<pre><code>https://localhost:7271/test/authorized

HTTP/1.1 200 OK
Content-Type: text/plain; charset=utf-8
Date: Sun, 14 Aug 2022 12:12:23 GMT
Server: Kestrel
Transfer-Encoding: chunked

This was accepted as authorized

Response code: 200 (OK); Time: 72ms; Content length: 31 bytes
</code></pre>
<p>So, providing a valid JWT gives us access.</p>

</div>
<div class="tab">
<hr/><h1 id="more-policy-guarding-examples">More policy guarding examples</h1><hr/>
<p>Currently, we have blocked our controller so that you need a valid JWT to call the endpoints.</p>
<h4 id="allow-anonymous">Allow anonymous</h4>
<p>Maybe we wish to open some of the endpoints to everyone, we can do that with the &quot;AllowAnonymous&quot; attribute:</p>
<pre><code class="line-numbers language-csharp">[HttpGet(&quot;allowanon&quot;), AllowAnonymous]
public ActionResult GetAsAnon()
{
    return Ok(&quot;This was accepted as anonymous&quot;);
}
</code></pre>
<p>Create another test request in your .http file to the endpoint <code>https://localhost:7271/test/allowanon</code> .<br />
Notice your port may be different.</p>
<h4 id="guard-with-policy">Guard with policy</h4>
<p>Now we can have open endpoints and endpoints requiring a valid token, i.e. you are logged in. But what about applying a specific policy, i.e. you must be <em>x</em> or have <em>y</em> or whatever.</p>
<p>Try the following endpoint in your TestController:</p>
<pre><code class="line-numbers language-csharp">[HttpGet(&quot;mustbevia&quot;), Authorize(&quot;MustBeVia&quot;)]
public ActionResult GetAsVia()
{
    return Ok(&quot;This was accepted as via domain&quot;);
}
</code></pre>
<p>Here we use the <code>Authorized(&quot;MustBeVia&quot;)</code> attribute. Remember, in the Shared/Auth/AuthorizationPolicies.cs class we defined a policy named &quot;MustBeVia&quot;.</p>
<p>You have two users hardcoded: trmo, and jknr. Only trmo is has the domain &quot;via&quot;.<br />
So, first log in with trmo, receive the token, and use that token with a GET request to <code>https://localhost:7271/test/mustbevia</code> .</p>
<p>It should be okay.</p>
<p>Then try to modify the login credentials to &quot;jknr&quot; and &quot;password&quot;, to log in as Jakob. Copy the received token into your request above, and try again. You should get an Unauthorized response back.</p>
<h4 id="manual-checking">Manual checking</h4>
<p>Finally, maybe you don't like to rely on policies. You can leave them out entirely if you wish to do so, and just do the authorization validation manually, i.e. writing that code yourself.</p>
<p>Here's an example endpoint:</p>
<pre><code class="line-numbers language-csharp">[HttpGet(&quot;manualcheck&quot;)]
public ActionResult GetWithManualCheck()
{
    Claim? claim = User.Claims.FirstOrDefault(claim =&gt; claim.Type.Equals(ClaimTypes.Role));
    if (claim == null)
    {
        return StatusCode(403, &quot;You have no role&quot;);
    }

    if (!claim.Value.Equals(&quot;Teacher&quot;))
    {
        return StatusCode(403, &quot;You are not a teacher&quot;);
    }

    return Ok(&quot;You are a teacher, you may proceed&quot;);
}
</code></pre>
<p>Notice there is no Authorize attribute above the method signature.</p>
<p>In the method body, the first line:<br />
We access the <code>User</code> property. This has little to do with your specific User object. This property comes from the superclass, ControllerBase, and is the same type of ClaimsPrincipal we used in the AuthorizationPolicies.cs class. I.e. it contains information about the user stored in the provided JWT from the request.</p>
<p>You can extract various information from this <code>User</code>, e.g. the claims.</p>

</div>
<div class="tab">
<hr/><h1 id="weatherforecastcontroller">WeatherForecastController</h1><hr/>
<p>This class came with the Web API project template. We haven't touched it much, but let's use this as a slightly closer real life example.</p>
<p>Open the class.</p>
<p>Put the [Authorized] attribute above the class definition, i.e. line 9 or so. Now, we can only access the GET endpoint with a valid token.</p>
<p>This concludes the Web API part of the tutorial.</p>
<p>Next up, we take a look at the Blazor side of things.</p>

</div>
<div class="tab">
<hr/><h1 id="blazor">Blazor</h1><hr/>
<p>Now we start on the front end of things.</p>
<p>We will see how to make a login request to our web api, receive a JWT and use that to guard various parts of the app.</p>
<h3 id="create-project">Create project</h3>
<p>We start by adding a new project, of type Blazor-wasm.</p>
<p><img src="Resources/CreateBlazor.png" alt="img.png" /></p>
<h3 id="add-packages">Add packages</h3>
<p>Again, we need to add a package:</p>
<ul>
<li>Microsoft.AspNetCore.Components.Authorization</li>
</ul>
<p>Remember to pick the latest non-preview version.</p>
<h3 id="add-reference">Add reference</h3>
<p>Add a project-reference to Shared, similar to what we did with the Web API, so that we get access to the models and the policy setup in that library.</p>
<h3 id="icons">Icons</h3>
<p>We are going to use two icons for login and logout. It's not strictly necessary, but let's try it out.</p>
<p>You should be able to right click and download the two images below:</p>
<p><img src="Resources/Login.png" alt="" /></p>
<p><img src="Resources/Logout.png" alt="" /></p>
<p>Place them here in your blazor project:</p>
<p><img src="Resources/IconsLocation.png" alt="img.png" /></p>

</div>
<div class="tab">
<hr/><h1 id="wrap-in-auth">Wrap in Auth</h1><hr/>
<p>We need to make available authentication across our app.</p>
<p>Open BlazorWasm/App.razor. Modify it to look as follows:</p>
<pre data-line="1,4-9,19"><code class="line-numbers language-html">&lt;CascadingAuthenticationState&gt;
    &lt;Router AppAssembly=&quot;@typeof(App).Assembly&quot;&gt;
        &lt;Found Context=&quot;routeData&quot;&gt;
            &lt;AuthorizeRouteView RouteData=&quot;@routeData&quot; DefaultLayout=&quot;@typeof(MainLayout)&quot;&gt;
                &lt;NotAuthorized&gt;
                    &lt;img width=&quot;600&quot; src=&quot;https://i.kym-cdn.com/entries/icons/original/000/002/144/You_Shall_Not_Pass!_0-1_screenshot.jpg&quot;/&gt;
                    &lt;p&gt;You'll have to log in!&lt;/p&gt;
                &lt;/NotAuthorized&gt;
            &lt;/AuthorizeRouteView&gt;
            &lt;FocusOnNavigate RouteData=&quot;@routeData&quot; Selector=&quot;h1&quot;/&gt;
        &lt;/Found&gt;
        &lt;NotFound&gt;
            &lt;PageTitle&gt;Not found&lt;/PageTitle&gt;
            &lt;LayoutView Layout=&quot;@typeof(MainLayout)&quot;&gt;
                &lt;p role=&quot;alert&quot;&gt;Sorry, there's nothing at this address.&lt;/p&gt;
            &lt;/LayoutView&gt;
        &lt;/NotFound&gt;
    &lt;/Router&gt;
&lt;/CascadingAuthenticationState&gt;
</code></pre>
<p>The yellow highlighted lines contains the changes. We wrap everything in <CascadingAuthenticationState>. And the <RouteView> is changed to <AuthorizeRouteView>.</p>
<p>Everything inside the <NotAuthorized> tags is html to be shown, if the user tries to access something, they are not authorized to access.</p>
<h3 id="imports">Imports</h3>
<p>You should now see that the tag <CascadingAuthenticationState> is a different color than e.g. &lt;Router...&gt;.</p>
<p>That's because C# recognizes the second tag as a razor component, and the first tag is not currently recognized, so it's just colored as html.</p>
<p>We need an import statement.</p>
<p>Open the file BlazorWasm/_imports.razor. At the end, add the following two using statements:</p>
<pre><code class="line-numbers language-csharp">@using Microsoft.AspNetCore.Components.Authorization
@using Microsoft.AspNetCore.Authorization
</code></pre>
<p>Go back to App.razor, and verify the color change, indicating <CascadingAuthenticationState> is now recognized as a component. The result is that in every page or component, we can request information about the logged in user. That is convenient.</p>

</div>
<div class="tab">
<hr/><h1 id="authservice-class">AuthService class</h1><hr/>
<p>This class handles login requests, user-registration requests (not covered in tutorial), and logging out.</p>
<h3 id="directories">Directories</h3>
<p>Inside the project folder create a new directory: Services.
Inside that create a directory: Http.</p>
<p><img src="Resources/ServiceHttpDir.png" alt="img.png" /></p>
<p>We don't strictly need the Http directory, it's just to organize things. In this folder we put service implementations related to Http, i.e. REST and our Web API. If we later wanted other services using e.g. gRPC or other, we could create another directory for that. It's just a detail.</p>
<h3 id="iauthservice-interface">IAuthService interface</h3>
<p>In the Service directory create an interface, IAuthService.</p>
<p>It looks like this:</p>
<pre><code class="line-numbers language-csharp">using System.Security.Claims;
using Shared.Models;

namespace BlazorWasm.Services;

public interface IAuthService
{
    public Task LoginAsync(string username, string password);
    public Task LogoutAsync();
    public Task RegisterAsync(User user);
    public Task&lt;ClaimsPrincipal&gt; GetAuthAsync();

    public Action&lt;ClaimsPrincipal&gt; OnAuthStateChanged { get; set; }
}
</code></pre>
<p>Fix imports.</p>
<p>All methods return Tasks, to support asynchronous programming.</p>
<p>The first method is used to log in, from a log in page.<br />
The second is to log out, i.e. clear your authentication state and become anonymous.<br />
Then a method to register a new user, though not covered in this tutorial.<br />
The GetAuthAsync() method is used to provide authentication state details to the blazor framework, whenever the app needs to know about who is logged in.<br />
The last is an Action, which will fire an event whenever the authentication state changes, i.e. upon log in or log out.</p>
<h3 id="jwtauthservice">JwtAuthService</h3>
<p>In the Http directory create a class &quot;JwtAuthService.cs&quot;.</p>
<p>It's a long class, we'll cut it up. The end result <a href="https://github.com/TroelsMortensen/JwtAuth/blob/master/BlazorWasm/Services/Http/JwtAuthService.cs">is found on GitHub here</a>.</p>
<h4 id="fields">Fields</h4>
<p>This is the start of the class:</p>
<pre><code class="line-numbers language-csharp">public class JwtAuthService : IAuthService
{
    private readonly HttpClient client = new ();

    // this private variable for simple caching
    public static string? Jwt { get; private set; } = &quot;&quot;;

    public Action&lt;ClaimsPrincipal&gt; OnAuthStateChanged { get; set; } = null!;
</code></pre>
<p>It implements the interface IAuthService, so we must provide implementations for the methods defined in the interface.</p>
<p>We have a static public field variable called <code>Jwt</code>. This will hold the token received from the Web API when logged in. It is static because other services need this token when making requests to the Web API, we will see that later. The variable being static provides easier access to it.</p>
<p>Normally static references results in tight couplings, i.e. something to avoid. But the coupling is only within the same layer, so we allow it here. The coupling can be loosened, but that is not relevant for this tutorial.</p>
<p>The last line is the implementation of the Action. Now, other classes can subscribe and listen for events being fired about the authentication state changing. We will need that later.</p>
<h4 id="parsing-the-jwt">Parsing the JWT</h4>
<p>We will need functionality to convert the JWT received from the Web API into Claims with information about the user logged in.</p>
<p>Paste in the below two methods:</p>
<pre><code class="line-numbers language-csharp">// Below methods stolen from https://github.com/SteveSandersonMS/presentation-2019-06-NDCOslo/blob/master/demos/MissionControl/MissionControl.Client/Util/ServiceExtensions.cs
private static IEnumerable&lt;Claim&gt; ParseClaimsFromJwt(string jwt)
{
    string payload = jwt.Split('.')[1];
    byte[] jsonBytes = ParseBase64WithoutPadding(payload);
    Dictionary&lt;string, object&gt;? keyValuePairs = JsonSerializer.Deserialize&lt;Dictionary&lt;string, object&gt;&gt;(jsonBytes);
    return keyValuePairs!.Select(kvp =&gt; new Claim(kvp.Key, kvp.Value.ToString()!));
}

private static byte[] ParseBase64WithoutPadding(string base64)
{
    switch (base64.Length % 4)
    {
        case 2:
            base64 += &quot;==&quot;;
            break;
        case 3:
            base64 += &quot;=&quot;;
            break;
    }

    return Convert.FromBase64String(base64);
}
</code></pre>
<p>How they work is irrelevant. Consider it black magic. The argument is the JWT, the result is a collection of Claims about the user.</p>
<h3 id="creating-the-claimsprincipal">Creating the ClaimsPrincipal</h3>
<p>We need a method to create a ClaimsPrincipal. Remember, this is the type of User object the auth-framework understands. So the JWT is converted into a ClaimsPrincipal with the following method:</p>
<pre><code class="line-numbers language-csharp">private static ClaimsPrincipal CreateClaimsPrincipal()
{
    if (string.IsNullOrEmpty(Jwt))
    {
        return new ClaimsPrincipal();
    }

    IEnumerable&lt;Claim&gt; claims = ParseClaimsFromJwt(Jwt);
    
    ClaimsIdentity identity = new(claims, &quot;jwt&quot;);

    ClaimsPrincipal principal = new(identity);
    return principal;
}
</code></pre>
<p>If there is no JWT, i.e. no user is logged in, we return an &quot;empty&quot; ClaimsPrincipal. This is then anonymous.</p>
<p>Otherwise, we get the Claims from the JTW. We put those claims into a ClaimsIdentity, a kind of sub-user. We state the auth-type is &quot;jwt&quot;.<br />
This ClaimsIdentity is then provided to a ClaimsPrincipal. I believe a ClaimsPrincipal may contain multiple Identities, though that's beyond this tutorial.</p>
<p>That's enough of helper methods. You may notice they are all private and <em>static</em>. They don't need to be static, but as they are just helper methods, making them static is in some cases a small optimization. It's just a detail, you don't need to do it.</p>
<h3 id="login-method">Login method</h3>
<p>Now, the login method. It looks like this:</p>
<pre><code class="line-numbers language-csharp">public async Task LoginAsync(string username, string password)
{
    UserLoginDto userLoginDto = new()
    {
        Username = username,
        Password = password
    };

    string userAsJson = JsonSerializer.Serialize(userLoginDto);
    StringContent content = new(userAsJson, Encoding.UTF8, &quot;application/json&quot;);

    HttpResponseMessage response = await client.PostAsync(&quot;https://localhost:7130/auth/login&quot;, content);
    string responseContent = await response.Content.ReadAsStringAsync();

    if (!response.IsSuccessStatusCode)
    {
        throw new Exception(responseContent);
    }

    string token = responseContent;
    Jwt = token;

    ClaimsPrincipal principal = CreateClaimsPrincipal();

    OnAuthStateChanged.Invoke(principal);
}
</code></pre>
<p>First a UserLoginDto object is created with username and password. Remember, this is what the Web API needed to validate a user.</p>
<p>The object is serialized into JSON. That JSON is put into a <code>StringContent</code> object, using Encoding UTF8, and specifying the content is on JSON-format.</p>
<p>We make a Post request in line 12, and in line 13 we read the response content, which should be our JWT.</p>
<p><strong>Remember to change the port to match your Web API's!</strong></p>
<p>If there is a problem with the request, i.e. we get an error code back, we throw an Exception. This exception is caught in a page, and an error message is shown to the user. It is always <em>very</em> important to give feedback to the user, both upon success and failure.</p>
<p>We assign the received jwt to the property <code>Jwt</code>. This property is a form of <a href="https://en.wikipedia.org/wiki/Cache_(computing)">cache</a>. From wiki:</p>
<blockquote>
<p>... is a hardware or software component that stores data so that future requests for that data can be served faster</p>
</blockquote>
<p>It's just a temporary storage to hold data which is needed in the future. If we didn't store the JWT we would need to log in all the time. It wouldn't work. This cache is simple, and the last part of this tutorial will cover small improvements. But we start out simple.</p>
<p>We get the ClaimsPrincipal and finally invoke the Action to notify whoever is interested about the change in authentication state.</p>
<h3 id="register-user">Register User</h3>
<p>We include a method to register a user. You may later create a page for registering users if you wish.</p>
<pre><code class="line-numbers language-csharp">public async Task RegisterAsync(User user)
{
    string userAsJson = JsonSerializer.Serialize(user);
    StringContent content = new(userAsJson, Encoding.UTF8, &quot;application/json&quot;);
    HttpResponseMessage response = await client.PostAsync(&quot;https://localhost:7130/auth/register&quot;, content);
    string responseContent = await response.Content.ReadAsStringAsync();

    if (!response.IsSuccessStatusCode)
    {
        throw new Exception(responseContent);
    }
}
</code></pre>
<p>Remember to change the port number!</p>
<h3 id="register-service">Register service</h3>
<p>Finally, we need to register the interface and implementation as a service, so the app can use them for dependency injection.</p>
<p>Open BlazorWasm/Program.cs, add the line:</p>
<pre><code class="line-numbers language-csharp">builder.Services.AddScoped&lt;IAuthService, JwtAuthService&gt;();
</code></pre>

</div>
<div class="tab">
<hr/><h1 id="the-authentication-state-provider-class">The Authentication State Provider class</h1><hr/>
<p>Your Blazor app constantly needs to evaluate what to show to the user based on their credentials.
As mentioned in the beginning, you can show/hide parts of your UI based on the user being logged in or not, and based on their credentials, i.e. Claims.</p>
<p>The app need to get access to this authentication state, and that happens through a class, which we extend.</p>
<p>Create a new directory in BlazorWasm, call it &quot;Auth&quot;.</p>
<p>In here create the class CustomAuthProvider:</p>
<pre><code class="line-numbers language-csharp">using System.Security.Claims;
using BlazorWasm.Services;
using Microsoft.AspNetCore.Components.Authorization;

namespace BlazorWasm.Auth;

public class CustomAuthProvider: AuthenticationStateProvider
{
    private readonly IAuthService authService;

    public CustomAuthProvider(IAuthService authService)
    {
        this.authService = authService;
        authService.OnAuthStateChanged += AuthStateChanged;
    }
    
    public override async Task&lt;AuthenticationState&gt; GetAuthenticationStateAsync()
    {
        ClaimsPrincipal principal = await authService.GetAuthAsync();
        
        return new AuthenticationState(principal);
    }
    
    private void AuthStateChanged(ClaimsPrincipal principal)
    {
        NotifyAuthenticationStateChanged(
            Task.FromResult(
                new AuthenticationState(principal)
            )
        );
    }
}
</code></pre>
<p>The Blazor framework knows about the abstract superclass, <code>AuthenticationStateProvider</code>. We then provide a subclass, which can give the app the authentication state it requires, in the form of a ClaimsPrincipal.
So, whenever the app needs to know whether it should show or hide some piece of UI, it will ask our class here about the user credentials, i.e. a ClaimsPrincipal, and then evaluate accordingly.</p>
<p>The field variable is a reference to the IAuthService interface we just created. Notice that we don't know anything about the implementation, or whether JWT is used or whatever. Again, Dependency Inversion Principle. If we wish to change authentication strategy, we can do that isolated.</p>
<p>The constructor receives the instance of IAuthService, i.e. we use dependency injection. And then we subscribe to the <code>OnAuthStateChanged</code> event from the IAuthService. I.e. whenever the authentication state changes through logging in or out, this class wants to know about it, and react to it.<br />
What this class then does is call the method NotifyAuthenticationStateChanged, which is located in the AuthenticationStateProvider, i.e. the superclass. This will cause the app to update.</p>
<p>The method <code>GetAuthenticationStateAsync()</code> is called whenever the blazor app needs to know whether to block or show some UI piece.<br />
Here we just retrieve the ClaimsPrincipal from the IAuthService and return it.</p>
<h3 id="register-service">Register service</h3>
<p>We must tell the blazor app to use our implementation. Open Program.cs, and include the line:</p>
<p><code>builder.Services.AddScoped&lt;AuthenticationStateProvider, CustomAuthProvider&gt;();</code></p>
<p>Fix imports.</p>
<h3 id="add-policies">Add policies</h3>
<p>In Program.cs add the following line:</p>
<p><code>AuthorizationPolicies.AddPolicies(builder.Services);</code></p>
<p>This will add the same policies to your Blazor app as to your Web API. It's convenient to define them in just one place when they need to be the same.</p>

</div>
<div class="tab">
<hr/><h1 id="the-login-page">The login page</h1><hr/>
<p>We need to be able to log in. This requires a page where we can input our credentials.</p>
<p>In the Pages directory, create a new page:</p>
<p><img src="Resources/AddBlazorComponent.png" alt="img.png" /></p>
<p>And then input name, and select &quot;Page&quot;:</p>
<p><img src="Resources/SelectPage.png" alt="img.png" /></p>
<h3 id="the-code">The code</h3>
<p>At the top of the file, you should have these four lines:</p>
<pre><code class="line-numbers language-razor">@page &quot;/Login&quot;
@using BlazorWasm.Services
@inject IAuthService authService
@inject NavigationManager navMgr
</code></pre>
<p>We declare the page directive, i.e. the sub-uri to get to the Login page.<br />
There is a using statement, and then two @inject statements. This gives us an instance of IAuthService (i.e. the JwtAuthService) and an instance of the NavigationManager.</p>
<p>The code block is here:</p>
<pre><code class="line-numbers language-csharp">@code {
    private string userName;
    private string password;
    private string errorLabel;

    private async Task LoginAsync()
    {
        errorLabel = &quot;&quot;;
        try
        {
            await authService.LoginAsync(userName, password);
            navMgr.NavigateTo(&quot;/&quot;);
        }
        catch (Exception e)
        {
            Console.WriteLine(e);
            errorLabel = $&quot;Error: {e.Message}&quot;;
        }
    }
}
</code></pre>
<p>We have private fields to hold the username, the password, and any error message we might need to show to the user.</p>
<p>The <code>LoginAsync()</code> method will delegate to the IAuthService, attempting to log in. If succesful we use the NavigationManager to navigate to the home page.<br />
In the case of any exceptions, we catch them and display the error message through the <code>errorLabel</code>.</p>
<h3 id="the-view">The view</h3>
<p>The below is the html/razor syntax for the view of the Login page:</p>
<pre><code class="line-numbers language-razor">&lt;AuthorizeView&gt;
    &lt;NotAuthorized&gt;
        &lt;div class=&quot;card&quot;&gt;
            &lt;h3&gt;Please login&lt;/h3&gt;
            &lt;div class=&quot;field&quot;&gt;
                &lt;label&gt;User name:&lt;/label&gt;
                &lt;input type=&quot;text&quot; @bind=&quot;userName&quot;/&gt;
            &lt;/div&gt;
            &lt;div class=&quot;field&quot;&gt;
                &lt;label style=&quot;text-align: center&quot;&gt;Password:&lt;/label&gt;
                &lt;input type=&quot;password&quot; @bind=&quot;password&quot;/&gt;
            &lt;/div&gt;
            @if (!string.IsNullOrEmpty(errorLabel))
            {
                &lt;div class=&quot;field&quot;&gt;
                    &lt;label style=&quot;color: red&quot;&gt;
                        @errorLabel
                    &lt;/label&gt;
                &lt;/div&gt;
            }
            &lt;div class=&quot;field&quot;&gt;
                &lt;button class=&quot;loginbtn&quot; @onclick=&quot;LoginAsync&quot;&gt;Log in&lt;/button&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/NotAuthorized&gt;
    &lt;Authorized&gt;
        &lt;div class=&quot;card&quot;&gt;
            &lt;h3&gt;Hello, @context.User.Identity.Name&lt;/h3&gt;
        &lt;/div&gt;
    &lt;/Authorized&gt;
&lt;/AuthorizeView&gt;
</code></pre>
<p>So, what's going on here?</p>
<p>We wrap everything in the <AuthorizeView> component. Inside this we have access to information about the ClaimsPrincipal representing the currently logged in user.</p>
<p>Notice the two sub-tags: <code>&lt;NotAuthorized&gt;</code> and <code>&lt;Authorized&gt;</code>.\</p>
<ul>
<li>The first is &quot;active&quot; if no one is logged in, i.e. all the html inside this tag is displayed.</li>
<li>The second contains html shown if the user <em>is</em> logged in.</li>
</ul>
<p>In the NotAuthorized part we have two input fields for the username and password.</p>
<p>If the errorLabel contains something, we display that text.</p>
<p>At the bottom we have the button, which when pressed calls the <code>LoginAsync()</code> method.</p>
<p>Inside the Authorized part we have access to the <code>context</code>, a variable of type <code>AuthenticationState</code>, so we can access the contained ClaimsPrincipal, and get the Name. Or any Claim we might want.</p>
<p>The Name property is set specifically, when you add a Claim to the ClaimsPrincipal with the <code>ClaimsType</code> of <code>ClaimsType.Name</code>. We did this in the Web API's AuthController:</p>
<p><code>new Claim(ClaimTypes.Name, user.Username)</code></p>
<p>``</p>
<h3 id="styling">Styling</h3>
<p>Add a style-behind to make the Login page look nicer. It could contain the following css:</p>
<pre><code class="line-numbers language-css">.card {
    box-shadow: 0 4px 8px 0 rgba(0,0,0,0.2);
    transition: 0.3s;
    width: 250px;
    padding: 25px;
    text-align: center;
    margin: auto;
    margin-top: 50px;
}

.field {
    margin-top: 20px;
}

.loginbtn {
    background-color:lightgreen;
    border-radius: 5px;
    padding: 5px;
    padding-left: 10px;
    padding-right: 10px;
}

.loginbtn:hover{
    transform: scale(1.1);
    box-shadow: 0 2px 10px 2px #3f3f3f;
}
</code></pre>
<p>The result should be this look:</p>
<p><img src="Resources/LoginCard.png" alt="img.png" /></p>
<p>You can check by running your Blazor app, and manually put in</p>
<p><code>https://localhost:7105/login</code></p>
<p>in the browser bar. Maybe with another port.</p>

</div>
<div class="tab">
<hr/><h1 id="login-buttons">Login buttons</h1><hr/>
<p>We can't have the user type in manually in the search bar every time they wish to log in.</p>
<p>Let's make some buttons for this, and put them somewhere convenient.</p>
<p>Create a new Blazor Component in the Pages directory, call it <code>LoginButtons</code>.</p>
<h3 id="the-code">The code</h3>
<p>This is where we start, leaving out the view part:</p>
<pre><code class="line-numbers language-csharp">@using BlazorWasm.Services
@namespace Login
@inject NavigationManager navMgr
@inject IAuthService authService

...

@code {

    private void Login()
    {
        navMgr.NavigateTo(&quot;/Login&quot;);
    }

    private async Task Logout()
    {
        await authService.LogoutAsync();
        navMgr.NavigateTo(&quot;/&quot;);
    }

}
</code></pre>
<p>Notice there is no page directive here, so this is not a page we can navigate to. It is instead a piece of UI to be used in other components or pages.</p>
<p>We inject a <code>NavigationManager</code> and the <code>IAuthService</code> at the top.</p>
<p>In the code, we have a method to navigate to the Login page, and a method to log out. This <code>Logout()</code> method will tell the IAuthService to clear the logged in user, and then tell the app to navigate to the home page.</p>
<h3 id="the-view">The view</h3>
<p>In step 11 you were asked to download the login and logout icons, and put them in the wwwroot/img folder. We'll use these icons now.</p>
<p>Here's the view:</p>
<pre><code class="line-numbers language-razor">&lt;AuthorizeView&gt;
    &lt;Authorized&gt;
        &lt;img class=&quot;icon&quot; src=&quot;img/Logout.png&quot; @onclick=&quot;Logout&quot;/&gt;
    &lt;/Authorized&gt;
    &lt;NotAuthorized&gt;
        &lt;img class=&quot;icon&quot; src=&quot;img/Login.png&quot; @onclick=&quot;Login&quot;/&gt;
    &lt;/NotAuthorized&gt;
&lt;/AuthorizeView&gt;
</code></pre>
<p>Everything is wrapped in the AuthorizeView component, so that we inside get access to the authentication state, i.e. is someone logged in or not?</p>
<p>If the user is Authorized, i.e. logged in, we show the Logout icon, and attach the Logout() method to the on-click event.</p>
<p>If the user is not Authorized, i.e. not logged in, we display the Login icon.</p>
<h3 id="styling">Styling</h3>
<p>Create a style behind, and add this styling:</p>
<pre><code class="line-numbers language-css">.icon {
    width: 30px;
    cursor: pointer;
}
</code></pre>
<h3 id="adding-the-buttons-to-the-ui">Adding the buttons to the UI</h3>
<p>Finally, open the Shared/MainLayout.razor component. We want to add the buttons to the top bar of the app.</p>
<p>We do that by adding the LoginButtons component to the MainLayout, like so:</p>
<pre data-line="11"><code class="line-numbers language-razor">@inherits LayoutComponentBase
@using Login

&lt;div class=&quot;page&quot;&gt;
    &lt;div class=&quot;sidebar&quot;&gt;
        &lt;NavMenu/&gt;
    &lt;/div&gt;

    &lt;main&gt;
        &lt;div class=&quot;top-row px-4&quot;&gt;
            &lt;LoginButtons/&gt;
        &lt;/div&gt;

        &lt;article class=&quot;content px-4&quot;&gt;
            @Body
        &lt;/article&gt;
    &lt;/main&gt;
&lt;/div&gt;
</code></pre>
<p>There used to be a link to some &quot;about&quot;. We don't need that.</p>

</div>
<div class="tab">
<hr/><h1 id="testing-the-log-in">Testing the log in</h1><hr/>
<p>We should now be able to test the login functionality.</p>
<p>Start the Web API.</p>
<p>Start the Blazor app.</p>
<p>In the top right corner of the app, in the grey bar, you should see the Login icon.</p>
<p>Click it.</p>
<p>Type in:<br />
User name: trmo<br />
Password: onetwo3FOUR</p>
<p>Click <kbd>Log in</kbd></p>
<p>Hopefully everything works as intended. You should be shown the home page and notice the login icon changed to a logout icon, i.e. the arrow points out of the rectangle.</p>

</div>
<div class="tab">
<hr/><h1 id="authorization-functionality">Authorization functionality</h1><hr/>
<p>Now that the login works, what can we actually do with it?</p>
<ul>
<li>We can show or hide certain parts of the UI. We have already seen that with e.g. the login/logout button.</li>
<li>We can access information about the logged in user</li>
<li>We can block access to various pages</li>
</ul>
<p>We'll go over the various examples over the next few slides.</p>

</div>
<div class="tab">
<hr/><h1 id="blocking-access-to-a-page">Blocking access to a page</h1><hr/>
<p>If there are pages you don't want anonymous users to access, you can block them similarly to how we blocked an entire Web API Controller: with the Authorize attribute.</p>
<p>Let's try.</p>
<p>Create a new Blazor page, you can call it &quot;MustBeLoggedInToView.razor&quot;, or whatever.</p>
<p>The content of the page looks like this:</p>
<pre><code class="line-numbers language-razor">@page &quot;/MustBeLoggedInToView&quot;
@attribute [Authorize]

&lt;h3&gt;Must Be Logged In To View&lt;/h3&gt;

&lt;p&gt;You can only access this page, if you're logged in. Given that you're seeing this, you're logged in&lt;/p&gt;
</code></pre>
<p>It's very simple, nothing much going on. There is no code block.</p>
<p>The thing to notice is the second line:</p>
<p><code>@attribute [Authorize]</code></p>
<p>This piece of code says that this page is only displayed when you are logged in.</p>
<p>Let's test this.</p>
<p>Open the Shared/NavMenu component. Add an extra nav menu item:</p>
<pre data-line="18-22"><code class="line-numbers language-razor">&lt;div class=&quot;@NavMenuCssClass&quot; @onclick=&quot;ToggleNavMenu&quot;&gt;
    &lt;nav class=&quot;flex-column&quot;&gt;
        &lt;div class=&quot;nav-item px-3&quot;&gt;
            &lt;NavLink class=&quot;nav-link&quot; href=&quot;&quot; Match=&quot;NavLinkMatch.All&quot;&gt;
                &lt;span class=&quot;oi oi-home&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt; Home
            &lt;/NavLink&gt;
        &lt;/div&gt;
        &lt;div class=&quot;nav-item px-3&quot;&gt;
            &lt;NavLink class=&quot;nav-link&quot; href=&quot;counter&quot;&gt;
                &lt;span class=&quot;oi oi-plus&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt; Counter
            &lt;/NavLink&gt;
        &lt;/div&gt;
        &lt;div class=&quot;nav-item px-3&quot;&gt;
            &lt;NavLink class=&quot;nav-link&quot; href=&quot;fetchdata&quot;&gt;
                &lt;span class=&quot;oi oi-list-rich&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt; Fetch data
            &lt;/NavLink&gt;
        &lt;/div&gt;
        &lt;div class=&quot;nav-item px-3&quot;&gt;
            &lt;NavLink class=&quot;nav-link&quot; href=&quot;MustBeLoggedInToView&quot;&gt;
                &lt;span class=&quot;oi oi-list-rich&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt; Must Be Logged In
            &lt;/NavLink&gt;
        &lt;/div&gt;
    &lt;/nav&gt;
&lt;/div&gt;
</code></pre>
<h3 id="test">Test</h3>
<p>Run Web API and Blazor again. Without logging in, try to access the page.</p>
<p>You should see Gandalf blocking your way.</p>
<p>Now log in, and try again.</p>
<h3 id="adding-policy">Adding policy</h3>
<p>Currently you can view the page if you are logged in. But you can also apply a policy, only granting access if the logged in user fulfills that policy.</p>
<p>It's done with this line instead:</p>
<p><code>@attribute [Authorize(&quot;MustBeVia&quot;)]</code></p>
<p>Now, the user must fulfill the MustBeVia policy.</p>
<p>Test this by rerunning Web API and Blazor. First log in as Jakob:<br />
jknr/password</p>
<p>Try to access the page. You should be blocked by Gandalf.</p>
<p>Log out, and in again as<br />
trmo/onetwo3FOUR</p>
<p>and try the page. You should have access.</p>

</div>
<div class="tab">
<hr/><h1 id="the-authentication-context">The Authentication Context</h1><hr/>
<p>Sometimes you wish to display things to the user about their credentials, or based on their credentials.</p>
<p>When inside a <AuthorizeView> in the view part of a page, we get access to the <code>context</code>, a variable containing this information about the logged in user. It was mentioned before.</p>
<p>Let's create a page, which displays a user's Claims.</p>
<p>Create a new page, you could call it &quot;ShowCredentialsFromContext&quot;.</p>
<p>It looks like this:</p>
<pre><code class="line-numbers language-razor">@page &quot;/ShowCredentialsFromContext&quot;
@using System.Security.Claims

&lt;h3&gt;Show Credentials 1&lt;/h3&gt;
&lt;p&gt;Here we can see the users credentials&lt;/p&gt;
&lt;AuthorizeView&gt;
    &lt;Authorized&gt;
        &lt;h3&gt;Hello @context.User.Identity.Name&lt;/h3&gt;
        &lt;p&gt;@context.User.Claims.First(claim =&gt; claim.Type.Equals(ClaimTypes.Role)).Value&lt;/p&gt;
        &lt;p&gt;
            Your claims include:
            &lt;ol&gt;
                @foreach (Claim claim in context.User.Claims)
                {
                    &lt;li&gt;
                        &lt;label&gt;@claim.Type: @claim.Value&lt;/label&gt;
                    &lt;/li&gt;
                }
            &lt;/ol&gt;
        &lt;/p&gt;
    &lt;/Authorized&gt;
    &lt;NotAuthorized&gt;
        &lt;p&gt;You are not logged in.&lt;/p&gt;
    &lt;/NotAuthorized&gt;
&lt;/AuthorizeView&gt;

&lt;AuthorizeView Policy=&quot;MustBeVia&quot;&gt;
    &lt;p&gt;You are VIA&lt;/p&gt;
&lt;/AuthorizeView&gt;
</code></pre>
<p>Similar to the Login page, we have the <AuthorizeView> and inside we have two sub-tags: <Authorized> and <NotAuthorized>.</p>
<p>The content of each is shown based on your logged in states, as mentioned before.</p>
<p>In line 8, we have this:</p>
<p><code>&lt;h3&gt;Hello @context.User.Identity.Name&lt;/h3&gt;</code></p>
<p>We get access to the context, an <code>AuthenticationState</code>. It contains a <code>ClaimsPrincipal</code>, i.e. the <code>.User</code>.
This then contains the <code>Identity</code>, and here we can get the <code>Name</code>.</p>
<p>Remember this <code>Name</code> was set with a Claim of a specific <em>Type</em> in the Web API's AuthController:</p>
<p><code>new Claim(ClaimTypes.Name, user.Username)</code></p>
<p>Now look at line 9, here we access the Claims to find the Role of the user.</p>
<p>And further down we display all the Claims through the foreach-loop.</p>
<p>Remember to add it to the nav menu.</p>
<h3 id="block-view-with-policy">Block view with policy</h3>
<p>You can block an entire page, but you can also block just part of a page, based on a policy. You can see that at the bottom of the code block above.</p>

</div>
<div class="tab">
<hr/><h1 id="the-authentication-state">The Authentication State</h1><hr/>
<p>The previous slide showed how to get user information in the view part.</p>
<p>What if you need it in the code block?<br />
Maybe you are about to create a Product, and you wish to extract the user name to set as owner.<br />
Maybe one method does different things based on your Claims.</p>
<p>Whatever your reason or need, you can get access to the information.</p>
<p>Let's try an example. We will redo the previous page, it will look the same to the user, but the programming is different.</p>
<p>Create a new page, you can call it &quot;ShowCredentialsFromAuthState&quot;, or something else.</p>
<p>It looks like this:</p>
<pre><code class="line-numbers language-razor">@page &quot;/ShowCredentialsFromAuthState&quot;
@using System.Security.Claims

&lt;h3&gt;Show Credentials 2&lt;/h3&gt;
&lt;p&gt;Here we can see the users credentials&lt;/p&gt;

@if (isLoggedIn)
{
    &lt;h3&gt;Hello @name&lt;/h3&gt;
    &lt;p&gt;
        Your claims include:
        &lt;ol&gt;
            @foreach (Claim claim in userClaims!)
            {
                &lt;li&gt;
                    &lt;label&gt;@claim.Type: @claim.Value&lt;/label&gt;
                &lt;/li&gt;
            }
        &lt;/ol&gt;
    &lt;/p&gt;
}
else
{
    &lt;p&gt;You are not logged in.&lt;/p&gt;
}

@code {

    [CascadingParameter]
    public Task&lt;AuthenticationState&gt; AuthState { get; set; } = null!;

    private string? name;
    private IEnumerable&lt;Claim&gt;? userClaims;
    private bool isLoggedIn;

    protected override async Task OnInitializedAsync()
    {
        AuthenticationState authState = await AuthState;
        ClaimsPrincipal user = authState.User;
        isLoggedIn = user.Identity != null;
        
        if (!isLoggedIn) return;
        
        userClaims = user.Claims;
        name = user.Identity!.Name!;
    }

}
</code></pre>
<p>We have a bit more going on here. The view part is less complex this time, though.</p>
<p>We have a boolean <code>isLoggedIn</code> and if it is true, we display the <code>name</code>and also all the claims of the user.</p>
<p>Otherwise we just display &quot;You are not logged in&quot;.</p>
<p>So, no Authorize components or other stuff in the view to block/hide/show things.</p>
<h5 id="lets-take-a-look-at-the-code">Let's take a look at the code.</h5>
<p>The first property is the <code>AuthenticationState</code>, i.e. logged in information. It is marked with <code>[CascadingParameter]</code>. This is because it is set from a parent component far away. Remember how we modified the App.razor to wrap everything in <CascadingAuthenticationState>? This component will set the AuthenticationState on all components/pages in your app, if they request it, like we do with this property.</p>
<p>We also have the property to contain the <code>name</code> of the user, and a collection of claims, and then the boolean to see if the user is logged in.</p>
<h5 id="now-the-method-oninitializedasync">Now, the method <code>OnInitializedAsync()</code>.</h5>
<p>Remember, this is automatically called whenever the page is loaded.<br />
First line, we await the AuthState, to receive the AuthenticationState. From that we pull out the ClaimsPrincipal in the next line.<br />
Then, if there is an Identity, it means the user is logged in.<br />
We can pull out the claims and name of the user.</p>
<p>In the previous slide we saw how to show something if the user fulfilled the MustBeVia policy.<br />
Now, we can in the code just pull out the Domain claim, and check if the value is &quot;via&quot;, and then use a boolean to show/hide something in the UI.</p>
<p>So, we don't strictly need to define policies, but they make things a lot easier if the same rules apply to several parts of your app.</p>

</div>
<div class="tab">
<hr/><h1 id="the-end-almost">The End (almost)</h1><hr/>
<p>This concludes the basic tutorial. A few more slides will follow, to talk about some minor optimizations.</p>
<p>But for now, you should have a working login system, and you should have an understanding of how you can guard various parts of both Web API and Blazor app.</p>

</div>
<div class="tab">
<hr/><h1 id="optimization">Optimization</h1><hr/>
<p>Under construction...</p>

</div>



        
        <div style="overflow:auto; padding-bottom: 10px">
            <hr/>
            <div style="float:right;">
                <button type="button" id="prevBtn1" class="prev-button" onclick="nextPrev(-1)">Previous</button>
                <button type="button" id="nextBtn1" class="next-button" onclick="nextPrev(1)">Next&gt;</button>
            </div>
        </div>
        
    </div>
</div>
<script>
    showFirstOrSpecificTab();
</script>

</body>
</html>
