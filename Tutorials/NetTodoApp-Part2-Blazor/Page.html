<!DOCTYPE html>
<html>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link href="https://fonts.googleapis.com/css?family=Raleway" rel="stylesheet">
<link href="./../../Resources/Style.css" rel="stylesheet">
<link href="./../../Resources/prism.css" rel="stylesheet">
<script src="./../../Resources/TabNavigavtor.js"></script>
<link rel="shortcut icon" href="./../../Resources/CodeIcon.png">
<title>VIA Codelabs</title>
<body>
<script src="./../../Resources/prism.js"></script>

<div>
    <a href="./../../index.html" class="homelink">HOME</a>
</div>
<div style="display:flex;width:100%;height:100%;padding-top:64px">
    <div id="steps-list">
        <ol>
            <li class="step" onclick="setTab(0)">1 Introduction</li>
<li class="step" onclick="setTab(1)">2 Architecture</li>
<li class="step" onclick="setTab(2)">3 Components</li>
<li class="step" onclick="setTab(3)">4 Overall UI design</li>
<li class="step" onclick="setTab(4)">5 Fix CORS</li>
<li class="step" onclick="setTab(5)">6 Add user</li>
<li class="step" onclick="setTab(6)">7 Add User page</li>
<li class="step" onclick="setTab(7)">8 Add User Code</li>
<li class="step" onclick="setTab(8)">9 Add User View</li>
<li class="step" onclick="setTab(9)">10 Add User Test</li>
<li class="step" onclick="setTab(10)">11 Add User Styling</li>
<li class="step" onclick="setTab(11)">12 Add Page to NavMenu</li>
<li class="step" onclick="setTab(12)">13 View Users feature</li>
<li class="step" onclick="setTab(13)">14 View Users Service</li>
<li class="step" onclick="setTab(14)">15 View Users Code</li>
<li class="step" onclick="setTab(15)">16 View Users View</li>
<li class="step" onclick="setTab(16)">17 View Users Styling</li>
<li class="step" onclick="setTab(17)">18 Add Todo Feature</li>
<li class="step" onclick="setTab(18)">19 Add Todo Service</li>
<li class="step" onclick="setTab(19)">20 Add Todo Page</li>
<li class="step" onclick="setTab(20)">21 View Todos</li>
<li class="step" onclick="setTab(21)">22 View Todos Service</li>
<li class="step" onclick="setTab(22)">23 View Todos Page</li>
<li class="step" onclick="setTab(23)">24 View Todos Filtering</li>
<li class="step" onclick="setTab(24)">25 Component Intro</li>
<li class="step" onclick="setTab(25)">26 Checkbox Component</li>
<li class="step" onclick="setTab(26)">27 Use Checkbox</li>
<li class="step" onclick="setTab(27)">28 Edit Todo</li>
<li class="step" onclick="setTab(28)">29 GetTodoById</li>
<li class="step" onclick="setTab(29)">30 Edit Todo Page</li>
<li class="step" onclick="setTab(30)">31 Navigate To Edit</li>
<li class="step" onclick="setTab(31)">32 Delete Todo Feature</li>
<li class="step" onclick="setTab(32)">33 Delete Todo Service</li>
<li class="step" onclick="setTab(33)">34 Delete Todo View</li>
<li class="step" onclick="setTab(34)">35 Summation</li>
<li class="step" onclick="setTab(35)">36 Component Communication</li>
<li class="step" onclick="setTab(36)">37 Popup</li>

        </ol>
    </div>
    <div id="container" action="/action_page.php">
        <div style="overflow:auto;">

            <div style="float:right; margin:10px">
                <button type="button" id="prevBtn" class="prev-button" onclick="nextPrev(-1)">Previous</button>
                <button type="button" id="nextBtn" class="next-button" onclick="nextPrev(1)">Next</button>
            </div>
        </div>

        <!-- One "tab" for each step in the form: -->

        <div class="tab">
<p>Huske fejl beskeder, også i OnINitialized.</p>
<p>Users skal kunne vælges i en drop down.</p>
<p>Ved input skal jeg ikke bruge det indbyggede EditForm. Brug basic html.</p>
<p>Få en HTtpClient gennem constructor. De skal åbenbart ikke disposes.</p>
<hr/><h1 id="introduction">Introduction</h1><hr/>
<p>This is the <em>second</em> part of a 3 part tutorial series.</p>
<p>You should already have the Todo Web API in place from the first part. We will continue working in the same Solution so as to reuse certain things.</p>
<p>This tutorial will cover the client side, i.e. making a Blazor WASM app.</p>
<h2 id="features">Features</h2>
<p>We already have the server-side of multiple features from part 1. We will now complete the client side of those features.</p>
<ol>
<li>As a user of the system I can add a new User, so that Todos can be assigned to Users.</li>
<li>As a User I can get a list of all existing Users, so that I can assign Todos to them</li>
<li>As a User I can add a new Todo, so that I can remember important things</li>
<li>As a User I can view all or filtered Todos, so that I can remember what to do</li>
<li>As a User I can complete a Todo, so that I can mark things as done</li>
<li>As a User I can delete a Todo, so that I can clean up</li>
</ol>
<h2 id="branches">Branches</h2>
<p>Again, each feature has its own branch on GitHub. Below is an overview:</p>
<ul>
<li><a href="">009_ClientSetup</a> Here the initial setup of the Client components are done.</li>
</ul>
<h2 id="running-your-programs">Running your programs</h2>
<p>When you run your programs, either Web API or Blazor app, you <strong>do not use the &quot;IIS Express&quot; version</strong>. That requires extra setup, and I don't really know what it is about.</p>
<p><img src="Resources/RunningYourPrograms.png" alt="img.png" /></p>
<p>You can also just right-click your Web API or Blazor project, and run things from there, not worrying about ISS:</p>
<p><img src="Resources/RightClickToRun.png" alt="img.png" /></p>
<h3 id="tired-of-swagger-opening-all-the-time">Tired of Swagger opening all the time?</h3>
<p>Whenever you need to test something, you almost always need to start your Web API, and then Blazor. And your Web API will open a Swagger page.
If you get tired of this, you can go to WebAPI/Properties/launchSettings.json and modify the following line:</p>
<pre data-line="15"><code class="line-numbers language-json">{
  &quot;$schema&quot;: &quot;https://json.schemastore.org/launchsettings.json&quot;,
  &quot;iisSettings&quot;: {
    &quot;windowsAuthentication&quot;: false,
    &quot;anonymousAuthentication&quot;: true,
    &quot;iisExpress&quot;: {
      &quot;applicationUrl&quot;: &quot;http://localhost:21227&quot;,
      &quot;sslPort&quot;: 44331
    }
  },
  &quot;profiles&quot;: {
    &quot;WebAPI&quot;: {
      &quot;commandName&quot;: &quot;Project&quot;,
      &quot;dotnetRunMessages&quot;: true,
      &quot;launchBrowser&quot;: true,
      &quot;launchUrl&quot;: &quot;swagger&quot;,
      &quot;applicationUrl&quot;: &quot;https://localhost:7093;http://localhost:5093&quot;,
      &quot;environmentVariables&quot;: {
        &quot;ASPNETCORE_ENVIRONMENT&quot;: &quot;Development&quot;
      }
    },
    &quot;IIS Express&quot;: {
      &quot;commandName&quot;: &quot;IISExpress&quot;,
      &quot;launchBrowser&quot;: true,
      &quot;launchUrl&quot;: &quot;swagger&quot;,
      &quot;environmentVariables&quot;: {
        &quot;ASPNETCORE_ENVIRONMENT&quot;: &quot;Development&quot;
      }
    }
  }
}
</code></pre>
<p>&quot;launchBrowser: true&quot;. Change this to false, and the browser will not launch.</p>
<p>You can do the same for the Blazor app. You can then either just hard refresh with <kbd>ctrl</kbd>+<kbd>F5</kbd>.<br />
And in the console in Rider you can also click on the link with https to open a window.</p>

</div>
<div class="tab">
<hr/><h1 id="architecture">Architecture</h1><hr/>
<p>In the previous tutorial, we applied a clean-like approach to the server.
It does not make sense to do the same on the client side, as it has a different purpose, and is better built in a slightly different approach.</p>
<p>We will have two layers, one of which may be considered two in it-self.</p>
<p>This is the plan:</p>
<p><img src="Resources/ClientArchitecture.png" alt="img.png" /></p>
<p>The &quot;UI&quot; layer is a Blazor WASM app, and the &quot;Clients&quot; layer is a library with classes, which can make HTTP requests to the Web API.</p>
<p>The &quot;UI&quot; layer has a &quot;sub-layer&quot; marked &quot;View models&quot;. That is because they are often tightly intertwined with the UI. I.e. the View models are not a separate layer or component.</p>
<p>Now, we will need at least two new components: one per layer. That leaves the interfaces, where to put them?<br />
Sometimes you might see people put them in their own component, called Contracts. However, in our case that might be a bit excessive.</p>
<p>We will revisit the consideration from the clean approach, giving the following discussion:</p>
<p>Put the interfaces in the component least likely to be swapped out. In this case here, the Clients are swapped out, if we changed network technology, i.e. we move from REST to e.g. gRPC or GraphQL or something else.<br />
The UI layer may be swapped out, if we don't like Blazor-WASM.</p>
<p>If the interfaces were put in Clients, it would be easier to reuse that component if we were to add other types of client apps: desktop or mobile apps.</p>
<p>When starting the app, we will have to register client services, to be injected into the Blazor pages.
This means the UI component must depend on the Clients component.
If the interfaces are located in the UI, then the Clients component must depend on the UI, to implement the interfaces.
This causes an impossible bidirectional dependency.</p>
<p>So, we cannot put the interfaces in the UI.
They must go into the Clients, or into a separate component.
The latter is perhaps more flexible, if we expect to add other client apps, but we don't.
We will keep it simple, and put the interfaces in Clients.</p>
<p>This leads to the component/package diagram.</p>
<h2 id="component-diagram">Component Diagram</h2>
<p>Below is a rough component diagram of the Client app.</p>
<p><img src="Resources/ClientComponentDiagram.png" alt="img.png" /></p>
<p>Each grey container is a component. The Domain already exists in your solution, it was created in part 1 of the Tutorial.</p>
<p>The light blue containers are directories. Not all directories are shown, just the most important ones.</p>
<h2 id="class-diagram">Class Diagram</h2>
<p>The final class diagram will eventually be shown here, after which this text will be updated.</p>

</div>
<div class="tab">
<hr/><h1 id="creating-components">Creating Components</h1><hr/>
<p>It's time to create the two new components in your existing Solution.</p>
<h3 id="blazor-project">Blazor project</h3>
<p>Start with a new Blazor WASM project:</p>
<p><img src="Resources/CreateBlazorProject.gif" alt="" /></p>
<h3 id="clients-project">Clients project</h3>
<p>Then create a new Class Library, I have called mine HttpClients.</p>
<p>Delete the class &quot;Class1.cs&quot;.</p>
<h3 id="dependencies">Dependencies</h3>
<p>Make inter-component dependencies as follows:</p>
<ul>
<li>HttpClients -&gt; Domain</li>
<li>BlazorWASM -&gt; HttpClients</li>
</ul>
<p>Now, as last time, this gives us a transitive dependency: BlazorWASM -&gt; HttpClients -&gt; Domain, meaning that the Blazor component has access to everything in the Domain component.</p>
<p>That should be all for setting up. We are ready for the first feature.</p>

</div>
<div class="tab">
<hr/><h1 id="ui-design">UI design</h1><hr/>
<p>We will not rework the UI very much for this tutorial. This means we will keep the left side navigation menu, and just add a few more menu items to it, as necessary.</p>
<p>Should a more elaborate rework be desired, the basic setup is found in BlazorWASM/Shared/MainLayout.razor</p>
<p>Out of the box, it looks like this:</p>
<pre><code class="line-numbers language-razor">@inherits LayoutComponentBase

&lt;div class=&quot;page&quot;&gt;
    &lt;div class=&quot;sidebar&quot;&gt;
        &lt;NavMenu/&gt;
    &lt;/div&gt;

    &lt;main&gt;
        &lt;div class=&quot;top-row px-4&quot;&gt;
            &lt;a href=&quot;https://docs.microsoft.com/aspnet/&quot; target=&quot;_blank&quot;&gt;About&lt;/a&gt;
        &lt;/div&gt;

        &lt;article class=&quot;content px-4&quot;&gt;
            @Body
        &lt;/article&gt;
    &lt;/main&gt;
&lt;/div&gt;
</code></pre>
<p>You may notice the <code>&lt;NavMenu/&gt;</code> in line 5, which is the component (not project component, but Blazor component) that contains the HTML and code for the left side navigation menu.
If you remove this line, the navigation menu disappears.</p>
<p>Also notice the</p>
<pre><code class="line-numbers language-razor">&lt;div class=&quot;top-row px-4&quot;&gt;
    &lt;a href=&quot;https://docs.microsoft.com/aspnet/&quot; target=&quot;_blank&quot;&gt;About&lt;/a&gt;
&lt;/div&gt;
</code></pre>
<p>This is the top bar, always present. You can modify, or remove this. Some pages have navigation menus in the top panel instead of the side.</p>
<p>Actually, the only thing of the view, you cannot remove here, is the <code>@Body</code>. This variable is extremely important:<br />
Whenever you open a new page, the content of the page will be inserted at this variable.</p>
<p>So, if you want a very different layout of your app, this file is where to change the overall structure.</p>
<p>As mentioned, in this tutorial, we will not do any rework.</p>

</div>
<div class="tab">
<hr/><h1 id="adding-access-to-the-web-api">Adding access to the Web API</h1><hr/>
<p>Currently, your Web API does not have &quot;Cross Origin Resource Sharing&quot; enabled, which prevents your Blazor app from accessing the API.</p>
<p>In your WebAPI/Program.cs add the following:</p>
<pre><code class="line-numbers language-csharp">app.UseCors(x =&gt; x
    .AllowAnyMethod()
    .AllowAnyHeader()
    .SetIsOriginAllowed(origin =&gt; true) // allow any origin
    .AllowCredentials());
</code></pre>
<p>It must be after the app variable is defined, <a href="https://github.com/TroelsMortensen/WasmTodo/blob/010_AddUser/WebAPI/Program.cs">see here</a>, probably lines 26-30.</p>
<p>If you wish to know more about CORS, <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS">read here</a>. For this course, it is just something we enable, without caring too much about it. It is a security measure, which we are disabling.</p>
<h2 id="setting-base-address-of-httpclient">Setting base address of HttpClient</h2>
<p>If you open BlazorWASM/Program.cs, we will find that an HttpClient is added as a scoped service, and the base address is set to be the address of the host environment, i.e. the localhost.</p>
<p>The host address is that of your Blazor WASM app. However, we need to contact the Web API, which has a different address.<br />
Run your Web API to see in the console which https address it is listening on. Copy this address into the object inializer, like this:</p>
<pre><code class="line-numbers language-csharp">builder.Services.AddScoped(sp =&gt; new HttpClient { BaseAddress = new Uri(&quot;https://localhost:7093&quot;) });
</code></pre>

</div>
<div class="tab">
<hr/><h1 id="adding-new-users">Adding New Users</h1><hr/>
<p>We will implement the client side of the features in the same order as on the server (that's the current plan, at least).</p>
<p>This means we start here:</p>
<blockquote>
<p>As a user of the system I can add a new User, so that Todos can be assigned to Users.</p>
</blockquote>
<h2 id="interface">Interface</h2>
<p>Whether we start developing the feature with the HttpClient layer or the UI layer, they both depend on the interface in between. So, let's start there.</p>
<p>In HttpClients components, create a new directory: ClientInterfaces.</p>
<p>Inside this directory, create a new interface: IUserService.</p>
<p>We already have a DTO for creating Users, used on the server side: <code>UserCreationDto</code>.
Let us use this as the argument, and the return type will be the resulting User.  We get a User back from the endpoint, so this seems fitting.</p>
<p>This results in the method:</p>
<pre><code class="line-numbers language-csharp">Task&lt;User&gt; Create(UserCreationDto dto);
</code></pre>
<p>Add the method to the interface, fix import errors.</p>
<p>We will do the implementation next, and finally the UI.</p>
<h2 id="the-implementation">The Implementation</h2>
<p>Inside HttpClients component, create a new directory to house the implementations. Call the directory: Implementations.</p>
<p>We need a new class here: TodoHttpClient. It should implement the interface. Initially the class looks like this:</p>
<pre><code class="line-numbers language-csharp">public class UserHttpClient : IUserService
{
    private readonly HttpClient client;

    public UserHttpClient(HttpClient client)
    {
        this.client = client;
    }

    public Task&lt;User&gt; Create(UserCreationDto dto)
    {
        throw new NotImplementedException();
    }
}
</code></pre>
<p>We request an HttpClient through the constructor, thereby leaving the creation of the HttpClient up to the Blazor framework. The is best practice, and will improve longtime performance of your app.</p>
<p>If you are curious, <a href="https://www.youtube.com/watch?v=Z6Y2adsMnAA">Nick Chapsas has an elaborate video about performance</a>.</p>
<h4 id="the-method">The method</h4>
<p>First, add <code>async</code> to the method signature. Then let's do the method body. It looks like this:</p>
<pre><code class="line-numbers language-csharp">public async Task&lt;User&gt; Create(UserCreationDto dto)
{
    HttpResponseMessage response = await client.PostAsJsonAsync(&quot;/users&quot;, dto);
    string result = await response.Content.ReadAsStringAsync();
    if (!response.IsSuccessStatusCode)
    {
        throw new Exception(result);
    }

    User user = JsonSerializer.Deserialize&lt;User&gt;(result)!;
    return user;
}
</code></pre>
<p>We use the client to make a POST request to &quot;/users&quot;, sending the dto. The dto will be serialized to JSON, and wrapped in an appropriate HttpContent object.</p>
<p>Now, &quot;/users&quot; is not enough. We know the URI should be &quot;https://localhost:7093/Users&quot;. However, on the HttpClient you can set a &quot;base url&quot;, which is the first part, and we then only need to provide the part of the URI after the port.</p>
<p>Every request returns a response, whether we actually expect an object back or not.
We know that this endpoint will either return an error message, or the created User.
So, we read the content of the response.<br />
If the response is not a success code, i.e. an error code in the 400 or 500 range,
we know the result content is the error message, and an exception is thrown with that message.<br />
The exception can then be caught in the page and a message can be shown to the user of the app.</p>
<p>It is <em>always</em> important to give feedback to the user, in both sunny or rainy scenarios. If there is no feedback, they might try again, and create two users, or they may not be aware that the user was not created. User feeback is <em><strong>important</strong></em>.</p>
<p>If the status code is success, in this case we expect a &quot;201 Created&quot;, we know the result is a User as JSON, and it is deserialized and returned.</p>
<p>Most of our client methods will have a very similar structure.</p>
<h2 id="register-as-service">Register as service</h2>
<p>We will register the TodoHttpClient as a service in <code>Program.cs</code>, so that the dependency framework can inject an instance into our pages, when needed.</p>
<p>Open BlazorWASM/Program.cs. Put in the line:</p>
<pre><code class="line-numbers language-csharp">builder.Services.AddScoped&lt;IUserService, UserHttpClient&gt;();
</code></pre>
<p>Next up, let's do the page.</p>

</div>
<div class="tab">
<hr/><h1 id="add-user-page">Add User Page</h1><hr/>
<p>The Pages directory in your BlazorWASM project will house all Blazor components/pages. You may create sub-directories, if needed, but otherwise I recommend putting all blazor components in here.</p>
<h2 id="create-page">Create Page</h2>
<p>In the Pages folder, create a new Blazor component, call it &quot;CreateUser&quot;:</p>
<p><img src="Resources/AddBlazorComponent.png" alt="img.png" /></p>
<p>And then:</p>
<p><img src="Resources/CreateBlazorComponent.png" alt="img.png" /></p>
<p>If you make a Component instead of a Page, it can still be fixed. The only difference is that Pages come with the @page directive at the top:</p>
<pre><code>@page &quot;/CreateUser&quot;
</code></pre>
<p>If you created a component, this is not there, but can just be added.</p>
<p>You should now have this content in your page:</p>
<pre><code class="line-numbers language-razor">@page &quot;/CreateUser&quot;
&lt;h3&gt;CreateUser&lt;/h3&gt;

@code {
    
}
</code></pre>

</div>
<div class="tab">
<hr/><h1 id="the-code">The Code</h1><hr/>
<p>Let's start with the code block, i.e. what will essentially be your view-model. My style is typically to have the code block inside the page, as shown above. But if you prefer to do code-behinds, you're welcome to do that.</p>
<p>We need an object to hold the data, that the user inputs. And we need a method to send that data to the UserService.</p>
<p>It looks like this:</p>
<pre><code class="line-numbers language-csharp">@code {
    private string username = &quot;&quot;;
    private string resultMsg = &quot;&quot;;
    private string color = &quot;&quot;;
    
    private async Task Create()
    {
        resultMsg = &quot;&quot;;

        try
        {
            await userService.Create(new UserCreationDto(username));
            username = &quot;&quot;;
            resultMsg = &quot;User successfully created&quot;;
            color = &quot;green&quot;;
        }
        catch (Exception e)
        {
            Console.WriteLine(e);
            resultMsg = e.Message;
            color = &quot;red&quot;;
        }
    }
}
</code></pre>
<p>Three field variables. The <code>resultMsg</code> is to hold any messages, we wish to display to the user. Maybe something fails on the server side, e.g. the user name was already taken. We wish to display that information to the user. Remember, feedback is important.<br />
The <code>color</code> is to set the color of the resultMsg in the view, see below.</p>
<p>The <code>Create()</code> method does very little. We reset the <code>resultMsg</code> first. Then a call to the <code>IUserService</code> with a new UserCreationDto containing the user name.</p>
<p>If something goes wrong, we catch any potential exceptions, and display their message, by putting it into the <code>resultMsg</code> variable, which causes an update to the view, which will be re-rendered.</p>

</div>
<div class="tab">
<hr/><h1 id="the-view">The View</h1><hr/>
<p>Next up, the view definition.</p>
<p>As a minimum we need an input field, so that the user can input the wanted user name.<br />
We also need a button, which when clicked, will call the <code>Create()</code> method.<br />
And then we need a way to display messages held in the <code>resultMsg</code>.</p>
<p>I have added a little extra, which will be explained, and then the view looks like this:</p>
<pre><code class="line-numbers language-razor">@page &quot;/CreateUser&quot;
@using Domain.DTOs
@using HttpClients.ClientInterfaces
@inject IUserService userService;

&lt;div class=&quot;card&quot;&gt;
    &lt;h3&gt;Create User&lt;/h3&gt;
    &lt;div class=&quot;form-group field&quot;&gt;
        &lt;label&gt;User name:&lt;/label&gt;
        &lt;input type=&quot;text&quot; @bind=&quot;username&quot; @bind:event=&quot;oninput&quot;/&gt;
        @if (!string.IsNullOrEmpty(resultMsg))
        {
            &lt;label style=&quot;color: @color&quot;&gt;@resultMsg&lt;/label&gt;
        }
    &lt;/div&gt;
    &lt;div class=&quot;button-row&quot;&gt;
        &lt;button @onclick=&quot;Create&quot; disabled=&quot;@(string.IsNullOrEmpty(username))&quot; class=&quot;acceptbtn&quot;&gt;Create&lt;/button&gt;
    &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p><strong>Line 1</strong>: This is the page directive. It defines the sub-uri to access this specific page.<br />
<strong>Line 2-3</strong>: Importing various namespaces.<br />
<strong>Line 4</strong>: Here we inject an instance of <code>IUserService</code>.
This instance is created and provided by the dependency injection framework, and we can do this, when we have registered the interface and implementing class as services in Program.cs, as we did the previous slide.<br />
We hereby achieve dependency inversion, and if we were to change the network technology, the idea is, we shouldn't have to rework any of our pages, because they just know about the interface.<br />
However, because we decided to put the interfaces into the HttpClients component, we would still have to modify all pages, if we changed network technology. Notice the using statement in line 3, this references the namespace HttpClients. We have chosen to accept this flaw, as we will not change network technology. Remember the discussion on slide 2 on where to put the interfaces.</p>
<p>But, this page does not know about the implementation behind the interface.</p>
<p>Then comes a mix of HTML and razor-syntax, i.e. inlined C#.<br />
First there is a containing <code>&lt;div&gt;</code> in line 6. We will add some styling later to setup the page a little nicer.</p>
<p>The first interesting thing comes in <strong>line 10</strong>. This is a text input field:</p>
<pre><code class="line-numbers language-razor">&lt;input type=&quot;text&quot; @bind=&quot;username&quot; @bind:event=&quot;oninput&quot;/&gt;
</code></pre>
<p>We have two &quot;@-attributes&quot;. The first one says that the value of the text field should be stored in the field variable <code>username</code>.</p>
<p>The second <code>@</code> is then the type of event, which should cause the value of the input field to be put into the field variable.
We want it to be &quot;oninput&quot;, i.e. each key press will cause an update to the value of the field variable.
The default is &quot;onchange&quot;, which will cause the update when you de-focus the text input, i.e. click somewhere outside of it. If we just want the default onchange we can leave out the second <code>@bind:eve...</code>.<br />
We want the &quot;oninput&quot;, because the button should be  disabled, when there is nothing in the input field.</p>
<p><strong>Line 11-14</strong>: This is a code snippet, started with the <code>@</code> to indicate some razor-syntax follows, which should be evaluated when generating the html.<br />
We check if there is anything in the <code>resultMsg</code> field, and if so, we display a <code>&lt;label&gt;</code> with whatever error message should be shown. If the <code>resultMsg</code> is empty, the HTML inside the if-statement is not rendered.</p>
<p><strong>Line 17</strong>: Here we have the button to be pressed when creating a user:</p>
<pre><code class="line-numbers language-csharp">&lt;button @onclick=&quot;Create&quot; disabled=&quot;@(string.IsNullOrEmpty(username))&quot; class=&quot;acceptbtn&quot;&gt;Create&lt;/button&gt;
</code></pre>
<p>We specify the method to be called when the button is clicked with <code>@onclick=&quot;Create&quot;</code>. We could also here provide a lambda expression instead of the method name.<br />
THen the <code>disabled=</code> is a standard HTML attribute, which value must be &quot;true&quot; or &quot;false&quot;.
Here we evaluate the state with <code>@(string.IsNullOrEmpty(username))</code>, the @ indicating razor-syntax to be avaluated when rendered. We check if the <code>username</code> has a value. If there is no value, it doesn't make sense to be able to click the button, so it will be disabled.</p>

</div>
<div class="tab">
<hr/><h1 id="test">Test</h1><hr/>
<p>We should now have the functionality in place. We will add a bit of styling later, but let's test it first.</p>
<p>Run first your Web API. You can just close the Swagger page, which opens.</p>
<p>Run then the BlazorWASM. It should open a new tab in your browser.</p>
<p>In the address bar put &quot;https://localhost:7205/CreateUser&quot; to navigate to the page, we have just worked on.</p>
<p>You should then see your page:</p>
<p><img src="Resources/CreateUserPageView.png" alt="img.png" /></p>
<p>Type in something in the text-field and see how the button becomes enabled.</p>
<p>Try first a user name, you know exists. We should see an error message.</p>
<p>Then try a new user name, non-existing. This should work, and you should see a green success mesage.</p>

</div>
<div class="tab">
<hr/><h1 id="adding-styling-to-create-user-page">Adding Styling to Create User Page</h1><hr/>
<p>Now that the functionality works, we can beautify it just a little bit. This is not a course in HTML and CSS, but we will still look at an example of how to apply it.</p>
<p>Remember, we have two approaches to styling:</p>
<ul>
<li>App wide css is defined in a file in the wwwroot/css. You can have multiple style-sheets in here, and they are made available app wide by importing them in the wwwroot/index.html file.</li>
<li>Component scoped styling, i.e. a style-sheet only available to a single component.</li>
</ul>
<p>We will use the latter, and create a &quot;style-behind&quot;.</p>
<p>Right click Pages directory, add a new style sheet. The name must be that of the component appended with &quot;.css&quot;, in our case that will be &quot;CreateUser.razor.css&quot;.</p>
<p>If done correctly, you should now see a style sheet nested under your razor component file:</p>
<p><img src="Resources/CreateUserStyleBehind.png" alt="img.png" /></p>
<p>Input the following into the .css file:</p>
<pre><code class="line-numbers language-css">.card {
    box-shadow: 0 4px 8px 0 rgba(0,0,0,0.2);
    transition: 0.3s;
    width: 250px;
    padding: 25px;
    text-align: center;
    margin: auto;
    margin-top: 50px;
    border-radius: 15px;
}

.field {
    margin-top: 20px;
}

.acceptbtn {
    background-color:lightgreen;
    border-radius: 5px;
    padding: 5px;
    padding-left: 10px;
    padding-right: 10px;
}

.button-row{
    margin-top: 15px;
}
</code></pre>
<p>I will not go through the CSS, but the result should look like this:</p>
<p><img src="Resources/CreateUserPageWithStyling.png" alt="img.png" /></p>
<p>The functionality remains the same.</p>
<p>Now, we may wish all &quot;accept&quot;-type buttons to have the same style, in which case, we should move that style-class to the app wide style-sheets. Or we could make the button a separate component. We might come back to this</p>

</div>
<div class="tab">
<hr/><h1 id="adding-a-navigation-menu-item">Adding a Navigation Menu Item</h1><hr/>
<p>Currently, we have had to manually input the URI into the browser address bar. We need another item in the navigation menu.</p>
<p>Open BlazorWASM/Shared/NavMenu.razor.</p>
<p>Find this part in the file (ca lines 10 to 28):</p>
<pre data-line="3-7"><code class="line-numbers language-razor">&lt;div class=&quot;@NavMenuCssClass&quot; @onclick=&quot;ToggleNavMenu&quot;&gt;
    &lt;nav class=&quot;flex-column&quot;&gt;
        &lt;div class=&quot;nav-item px-3&quot;&gt;
            &lt;NavLink class=&quot;nav-link&quot; href=&quot;&quot; Match=&quot;NavLinkMatch.All&quot;&gt;
                &lt;span class=&quot;oi oi-home&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt; Home
            &lt;/NavLink&gt;
        &lt;/div&gt;
        &lt;div class=&quot;nav-item px-3&quot;&gt;
            &lt;NavLink class=&quot;nav-link&quot; href=&quot;counter&quot;&gt;
                &lt;span class=&quot;oi oi-plus&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt; Counter
            &lt;/NavLink&gt;
        &lt;/div&gt;
        &lt;div class=&quot;nav-item px-3&quot;&gt;
            &lt;NavLink class=&quot;nav-link&quot; href=&quot;fetchdata&quot;&gt;
                &lt;span class=&quot;oi oi-list-rich&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt; Fetch data
            &lt;/NavLink&gt;
        &lt;/div&gt;
    &lt;/nav&gt;
&lt;/div&gt;
</code></pre>
<p>Here we have the three nav menu items, e.g. lines 3-7 defines a single nav menu item, the home button:</p>
<p><img src="Resources/NavMenuItemHome.png" alt="" /></p>
<p>We can just copy the div and nested content and adjust a little bit. Make it like this:</p>
<pre data-line="18-23"><code class="line-numbers language-razor">&lt;div class=&quot;@NavMenuCssClass&quot; @onclick=&quot;ToggleNavMenu&quot;&gt;
    &lt;nav class=&quot;flex-column&quot;&gt;
        &lt;div class=&quot;nav-item px-3&quot;&gt;
            &lt;NavLink class=&quot;nav-link&quot; href=&quot;&quot; Match=&quot;NavLinkMatch.All&quot;&gt;
                &lt;span class=&quot;oi oi-home&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt; Home
            &lt;/NavLink&gt;
        &lt;/div&gt;
        &lt;div class=&quot;nav-item px-3&quot;&gt;
            &lt;NavLink class=&quot;nav-link&quot; href=&quot;counter&quot;&gt;
                &lt;span class=&quot;oi oi-plus&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt; Counter
            &lt;/NavLink&gt;
        &lt;/div&gt;
        &lt;div class=&quot;nav-item px-3&quot;&gt;
            &lt;NavLink class=&quot;nav-link&quot; href=&quot;fetchdata&quot;&gt;
                &lt;span class=&quot;oi oi-list-rich&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt; Fetch data
            &lt;/NavLink&gt;
        &lt;/div&gt;
        &lt;div class=&quot;nav-item px-3&quot;&gt;
            &lt;NavLink class=&quot;nav-link&quot; href=&quot;CreateUser&quot;&gt;
                &lt;span class=&quot;oi oi-plus&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt; Create user
            &lt;/NavLink&gt;
        &lt;/div&gt;
    &lt;/nav&gt;
&lt;/div&gt;
</code></pre>
<p>The <code>href=..</code> says which page to open, it should match the sub-URI in your page directive in the CreateUser.razor file.</p>
<h2 id="cleaning-up">Cleaning up</h2>
<p>Initially, there are two demo pages: Counter and Fetch Data. We might as well delete them and remove the links.</p>
<p>Remove the following from NavMenu:</p>
<pre data-line="8-17"><code class="line-numbers language-razor">&lt;div class=&quot;@NavMenuCssClass&quot; @onclick=&quot;ToggleNavMenu&quot;&gt;
    &lt;nav class=&quot;flex-column&quot;&gt;
        &lt;div class=&quot;nav-item px-3&quot;&gt;
            &lt;NavLink class=&quot;nav-link&quot; href=&quot;&quot; Match=&quot;NavLinkMatch.All&quot;&gt;
                &lt;span class=&quot;oi oi-home&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt; Home
            &lt;/NavLink&gt;
        &lt;/div&gt;
        &lt;div class=&quot;nav-item px-3&quot;&gt;
            &lt;NavLink class=&quot;nav-link&quot; href=&quot;counter&quot;&gt;
                &lt;span class=&quot;oi oi-plus&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt; Counter
            &lt;/NavLink&gt;
        &lt;/div&gt;
        &lt;div class=&quot;nav-item px-3&quot;&gt;
            &lt;NavLink class=&quot;nav-link&quot; href=&quot;fetchdata&quot;&gt;
                &lt;span class=&quot;oi oi-list-rich&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt; Fetch data
            &lt;/NavLink&gt;
        &lt;/div&gt;
        &lt;div class=&quot;nav-item px-3&quot;&gt;
            &lt;NavLink class=&quot;nav-link&quot; href=&quot;CreateUser&quot;&gt;
                &lt;span class=&quot;oi oi-plus&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt; Create user
            &lt;/NavLink&gt;
        &lt;/div&gt;
        &lt;div class=&quot;nav-item px-3&quot;&gt;
            &lt;NavLink class=&quot;nav-link&quot; href=&quot;ViewUsers&quot;&gt;
                &lt;span class=&quot;oi oi-list&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt; View users
            &lt;/NavLink&gt;
        &lt;/div&gt;
    &lt;/nav&gt;
&lt;/div&gt;
</code></pre>
<p>Those are the two links to Counter and Fetch data, respectively.</p>
<p>Now, you can also delete the two files, Counter.razor and FetchData.razor, from the Pages directory.</p>
<p>Let us leave the Index.razor, so we have some kind of home page.</p>

</div>
<div class="tab">
<hr/><h1 id="view-users">View Users</h1><hr/>
<p>The second user story is:</p>
<blockquote>
<p>As a User I can get a list of all existing Users, so that I can assign Todos to them</p>
</blockquote>
<p>Now, the point of this one is actually just to be able to assign users to Todos, so the phrasing of the user story could have been better. But we needed that endpoint in the Web API, to retrieve a list of users.</p>
<p>So, we might as well make a page to view all users.</p>
<h2 id="new-page">New Page</h2>
<p>Make a new page in the Pages directory, call it &quot;ViewUsers&quot;.</p>
<p>The content will look like this:</p>
<pre><code class="line-numbers language-razor">@page &quot;/ViewUsers&quot;
&lt;h3&gt;ViewUsers&lt;/h3&gt;

@code {
    
}
</code></pre>
<h2 id="add-to-menu">Add to menu</h2>
<p>Let's also add it as a menu Item right away. Go ahead and do that, in the same way as the previous page.</p>
<p>Notice that for each nav menu item in the HTML of NavMenu.razor, there is a <code>&lt;span&gt;</code> tag, with the class defining what icon should be next to the text.</p>
<p><a href="https://icon-sets.iconify.design/oi/">You can find many available icons here</a>, they seem to be included in bootstrap, located in a file here: BlazorWASM/wwwroot/open-iconic/font/css/open-iconic-bootstrap.min.css.</p>
<p>So, maybe the icon for the menu item should be a list. Or something else. You can pick whatever.</p>

</div>
<div class="tab">
<hr/><h1 id="user-service-method">User Service Method</h1><hr/>
<p>We start by implementing a method to retrieve all users.</p>
<p>In IUserService interface we need the following method. The Web API actually allows us to search for Users by user name, so lets include that.</p>
<pre><code class="line-numbers language-csharp">Task&lt;IEnumerable&lt;User&gt;&gt; GetUsers(string? usernameContains = null);
</code></pre>
<p>By assigning the argument to null here, we can provide a default value. This means we do not need to provide an argument when calling the method, and if we don't, the argument will be set to null. Alternatively, we would have to actively pass <code>null</code> as the argument, when calling the method from a page's code block.</p>
<h2 id="implementation">Implementation</h2>
<p>Let's implement the method in UserHttpClient:</p>
<pre><code class="line-numbers language-csharp">public async Task&lt;IEnumerable&lt;User&gt;&gt; GetUsers(string? usernameContains = null)
{
    string uri = &quot;/users&quot;;
    if (!string.IsNullOrEmpty(usernameContains))
    {
        uri += $&quot;?username={usernameContains}&quot;;
    }
    HttpResponseMessage response = await client.GetAsync(uri);
    string result = await response.Content.ReadAsStringAsync();
    if (!response.IsSuccessStatusCode)
    {
        throw new Exception(result);
    }

    IEnumerable&lt;User&gt; users = JsonSerializer.Deserialize&lt;IEnumerable&lt;User&gt;&gt;(result)!;
    return users;
}
</code></pre>
<p>The method is async, because we make a call to the Web API, which may take time. The argument is again defaulted to null. And the return type is <code>IEnumerable&lt;Users&gt;</code>, i.e. the immutable collection returned from the Web API endpoint.</p>
<p>First the sub-URI is defined to be &quot;/users&quot;.<br />
Then, if the method-argument is not null, we suffix that to the URI as a query parameter. The URI might then e.g. be: &quot;/users?username=roe&quot;, to fetch all users whose name contains &quot;roe&quot;.</p>
<p>Next follows template code very similar to the other method in the class. A GET request is made, the response is checked for success. In case of failure, an error is thrown. In case of success, the string is de-serialized from JSON to <code>IEnumerable&lt;User&gt;</code>, which is then returned.</p>
<p>That should be all for the service.</p>

</div>
<div class="tab">
<hr/><h1 id="view-users-code-block">View Users Code Block</h1><hr/>
<p>Next up, let's do the code block in the page.</p>
<p>When it loads, we need to retrieve the list of users, so that it can be displayed. Here we go:</p>
<pre><code class="line-numbers language-csharp">@code {
    private IEnumerable&lt;User&gt;? users;
    private string msg = &quot;&quot;;

    protected override async Task OnInitializedAsync()
    {
        msg = &quot;&quot;;
        try
        {
            users = await userService.GetUsers();
        }
        catch (Exception e)
        {
            Console.WriteLine(e);
            msg = e.Message;
        }
    }
}
</code></pre>
<p>We have first a field to hold the users. It is marked as nullable, because it will be <code>null</code> until the data is retrieved from the server.</p>
<p>Then a field to hold any messages, in case of errors.</p>
<p>The method is overridden from ComponentBase. All blazor components automatically inherits from it.<br />
This specific method is automatically called, whenever the page loads.<br />
It just retrieves a collection of Users from through the IUserService. In case of errors, the message is assigned to <code>msg</code>, which can then be displayed in the view.</p>
<p>Remember, if the IUserService implementation receives a failure status code from the Web API, an exception is thrown. That's what we catch here.</p>

</div>
<div class="tab">
<hr/><h1 id="view-users-view">View Users View</h1><hr/>
<p>So, the view part of viewing users. The HTML.</p>
<p>We wish to display all user names. That can be formatted in different ways. It could just be a bullet list, or something else. I have again attempted to apply some kind of fancy styling. We'll take that on the next slide.</p>
<p>Here is the html razor-syntax:</p>
<pre><code class="line-numbers language-csharp">@page &quot;/ViewUsers&quot;
@using Domain.Models
@using HttpClients.ClientInterfaces
@inject IUserService userService

&lt;h3 style=&quot;text-align: center&quot;&gt;Overview of all users&lt;/h3&gt;

@if (!string.IsNullOrEmpty(msg))
{
    &lt;div&gt;
        &lt;span&gt;@msg&lt;/span&gt;
    &lt;/div&gt;
}

@if (users == null)
{
    &lt;span&gt;Loading..&lt;/span&gt;
}
else if (!users.Any())
{
    &lt;span&gt;No users to be found&lt;/span&gt;
}
else
{
    &lt;div class=&quot;users-container&quot;&gt;
        @foreach (User user in users)
        {
            &lt;div class=&quot;user-card&quot;&gt;
                &lt;label&gt;@user.UserName&lt;/label&gt;
            &lt;/div&gt;
        }
    &lt;/div&gt;
}
</code></pre>
<p><strong>Line 1</strong>: The page directive, i.e. the URI to access this page.</p>
<p><strong>Lines 2-3</strong>: Import statements, so that we can access classes <code>User</code> and <code>IUserService</code>.</p>
<p><strong>Line 4</strong>: Here we inject an <code>IUserService</code> instance.</p>
<p><strong>Line 5</strong>: It's just a header. I have committed crimes and just inlined a bit of styling in the tag.</p>
<p><strong>Line 7</strong>: Here we display the <code>msg</code> in case it has any value. This happens in case of errors.</p>
<p><strong>Line 14</strong>: Here starts an if-elseif-else.</p>
<p><strong>if</strong>: If the <code>users</code> variable is null, it is because no data has been retrieved from the server.<br />
<strong>else if</strong>: this is the case, when the <code>users</code> are loaded, but the collection is empty. The method <code>Any()</code> returns true, if there are any elements in the collection.<br />
<strong>else</strong>: finally, here we have loaded data, and there is actually some data. We wish to display all users. There is a <code>foreach</code> to loop the <code>users</code>, and for each user object, we generate a little piece of html, i.e. the <code>&lt;div</code> and <code>&lt;label&gt;</code> tags.
This piece here: <code>&lt;label&gt;@user.UserName&lt;/label&gt;</code>, notice how we use the <code>user</code> variable from the foreach-loop, and get the <code>UserName</code>. This is a string, which will then be displayed in the UI.</p>
<p>Again, notice how <code>@</code> is used to inline some C# code, which is evaluated to generate the resulting HTML. We can inline C# just about anywhere, so the dynamic HTML generation can be very flexible.</p>
<p>Finally, let's add some styling.</p>

</div>
<div class="tab">
<hr/><h1 id="styling-the-view-users-page">Styling the View Users Page</h1><hr/>
<p>Create a style-behind again, similar to what we did with the AddUser page.</p>
<p>Insert the below styling:</p>
<pre><code class="line-numbers language-css">.user-card {
    box-shadow: 0 4px 8px 0 rgba(0,0,0,0.2);
    display: inline-block;
    margin: 25px;
    padding: 15px;
    border-radius: 10px;
}
</code></pre>
<h2 id="test">Test</h2>
<p>Run Web API and then run Blazor.</p>
<p>You might want to add a couple of users first, so you have a handful.</p>
<p>Then open the ViewUsers page, it should look something like this:</p>
<p><img src="Resources/ViewUsersPage.png" alt="img.png" /></p>

</div>
<div class="tab">
<hr/><h1 id="add-new-todo">Add New Todo</h1><hr/>
<p>We are ready for the next feature:</p>
<blockquote>
<p>As a User I can add a new Todo, so that I can remember important things</p>
</blockquote>
<p>The user should input title, and assignee of a Todo. The assignee is to be selected from a drop-down menu. This may not scale too well, if there are hundreds of users, but we will keep it simple for now.</p>
<p>We need:</p>
<ul>
<li>Create a new Service interface, responsible for Todos.</li>
<li>Implement a new HTTP service, responsible for Todos.</li>
<li>Create a page, where the user can input the relevant data.</li>
</ul>
<p><a href="https://github.com/TroelsMortensen/WasmTodo/tree/012_CreateTodo">This feature is found in this branch</a></p>

</div>
<div class="tab">
<hr/><h1 id="service-for-handling-todos">Service for Handling Todos</h1><hr/>
<p>We start by defining the interfaces. Then the implementation</p>
<h2 id="interfaces">Interfaces</h2>
<p>We need to be able to retrieve users, so that we can select an assignee. That already exists in the IUserService.</p>
<p>We also need a new interface, ITodoService. Create this in HttpClients/ClientInterfaces.</p>
<p>It needs a method to create Todos. It does not need to return anything. And the argument is the <code>TodoCreationDto</code> we already have.</p>
<p>The interface then looks like this:</p>
<pre><code class="line-numbers language-csharp">public interface ITodoService
{
    Task CreateAsync(TodoCreationDto dto);
}
</code></pre>
<h2 id="implementation">Implementation</h2>
<p>Next up, create a new class, TodoHttpClient in side HttpClients/Implementations.</p>
<p>It initially looks like this:</p>
<pre><code class="line-numbers language-csharp">public class TodoHttpClient : ITodoService
{
    private readonly HttpClient client;

    public TodoHttpClient(HttpClient client)
    {
        this.client = client;
    }

    public Task CreateAsync(TodoCreationDto dto)
    {
        throw new NotImplementedException();
    }
}
</code></pre>
<p>Then the implementation. Give it a go yourself first, it is very similar to how we handled creating users.</p>
<details>
<summary>hint</summary>
<pre><code class="line-numbers language-csharp">public async Task CreateAsync(TodoCreationDto dto)
{
    HttpResponseMessage response = await client.PostAsJsonAsync(&quot;/todos&quot;,dto);
    if (!response.IsSuccessStatusCode)
    {
        string content = await response.Content.ReadAsStringAsync();
        throw new Exception(content);
    }
}
</code></pre>
<p>The argument is serialized. Then the client is used to make a POST request with the JSON. The response is checked for failure, in which case an exception is thrown.</p>
</details>
<h2 id="add-as-service">Add as Service</h2>
<p>Add your new interface and implementation as services in BlazorWASM/Program.cs:</p>
<pre><code class="line-numbers language-csharp">builder.Services.AddScoped&lt;ITodoService, TodoHttpClient&gt;();
</code></pre>

</div>
<div class="tab">
<hr/><h1 id="add-todo-page">Add Todo Page</h1><hr/>
<p>Next up is the UI.</p>
<p>Create a new Page, call it &quot;CreateTodo&quot;. Leave it empty for now.</p>
<h2 id="nav-menu">Nav Menu</h2>
<p>Add a new nav menu item to the nav menu, so that we can easily open the CreateTodo page.</p>
<h2 id="code-block">Code block</h2>
<p>We start with the code block.</p>
<p>We need to initially load the users. And we need a method to take the input, wrap it up and forward it to the client class.</p>
<p>It looks like this:</p>
<pre><code class="line-numbers language-csharp">@code {
    private IEnumerable&lt;User&gt;? users;
    private int? selectedUserId;
    private string todoTitle = &quot;&quot;;

    private string msg = &quot;&quot;;

    protected override async Task OnInitializedAsync()
    {
        msg = &quot;&quot;;
        try
        {
            users = await userService.GetUsers();
        }
        catch (Exception e)
        {
            Console.WriteLine(e);
            msg = e.Message;
        }
    }

    private async Task Create()
    {
        msg = &quot;&quot;;
        if (selectedUserId == null)
        {
            msg = &quot;You must select an assignee!&quot;;
            return;
        }
        if (string.IsNullOrEmpty(todoTitle))
        {
            msg = &quot;Title cannot be empty!&quot;;
            return;
        }

        try
        {
            TodoCreationDto dto = new((int)selectedUserId, todoTitle);
            await todoService.CreateAsync(dto);
            navMgr.NavigateTo(&quot;/&quot;);
        }
        catch (Exception e)
        {
            Console.WriteLine(e);
            msg = e.Message;
        }
    }
}
</code></pre>
<p>The first field holds the users. They are retrieved when the page is loaded, using the <code>OnInitializedAsync()</code> method, overridden from the ComponentBase super class.</p>
<p>The second field hold the selected User id. Initially no user is selected, so the value must be <code>null</code>.</p>
<p>The third field is for the Todo title.</p>
<p>And the fourth is for any messages, in case of errors and such.</p>
<p>The method <code>OnInitializedAsync()</code> just fetches all Users from the server.</p>
<p>The <code>Create()</code> method will first reset the <code>msg</code>. Then we check if User and Title is set. This is also checked on the server, but we do a basic check here, so we don't have to contact the server if the User have not filled out everything.<br />
Then a new <code>TodoCreationDto</code> is created, this class already exists, it what the Web API requires. It is handed over to the ITodoService to be sent to the server.\</p>
<p>In both methods we catch any potential errors from the layers below, and display the message through the <code>msg</code> field.</p>
<h5 id="navigationmanager">NavigationManager</h5>
<p>After the call to the <code>ITodoService::CreateAsync()</code> we do something different. For the CreateUser page, we would just display a message saying success. Here we take the opportunity to introduce a new helper class, the <code>NavigationManager</code></p>
<p>This class is injected, see below, and we can use it to navigate to a different page. So far, the user has been in control of navigating between pages in the app. But sometimes something happens, and we want to take the user to a different page.</p>
<p>The argument <code>(&quot;/&quot;)</code> is the URI of the page we want to display. For now, we navigate to the home page. Later we will change this, so we are taken to the Todo overview page. The argument will then be <code>(&quot;/ViewTodos&quot;)</code>.</p>
<p>No success message is shown to the user now, only in case of errors. Whether that is user friendly is less relevant.</p>
<h2 id="the-view">The View</h2>
<p>We have to again to the if-elseif-else thing to check for Users. If there are users, we display the input elements for the User.</p>
<p>It looks like this:</p>
<pre><code class="line-numbers language-razor">@page &quot;/CreateTodo&quot;
@using HttpClients.ClientInterfaces
@using Domain.Models
@using Domain.DTOs
@inject IUserService userService
@inject ITodoService todoService
@inject NavigationManager navMgr

&lt;div class=&quot;card&quot;&gt;
    @if (users == null)
    {
        &lt;label&gt;Loading users...&lt;/label&gt;
    }
    else if (!users.Any())
    {
        &lt;label&gt;No users, you cannot create a Todo&lt;/label&gt;
    }
    else
    {
        &lt;h3&gt;Create Todo&lt;/h3&gt;
        &lt;div class=&quot;form-group field&quot;&gt;
            &lt;label&gt;Title:&lt;/label&gt;
            &lt;input type=&quot;text&quot; @bind=&quot;todoTitle&quot;/&gt;
        &lt;/div&gt;
        &lt;div class=&quot;form-group field&quot;&gt;
            &lt;label&gt;Assignee:&lt;/label&gt;
            &lt;select @bind=&quot;selectedUserId&quot;&gt;
                &lt;option&gt;Choose&lt;/option&gt;
                @foreach (User user in users)
                {
                    &lt;option value=&quot;@user.Id&quot;&gt;@user.UserName&lt;/option&gt;
                }
            &lt;/select&gt;
        &lt;/div&gt;
        &lt;div class=&quot;button-row&quot;&gt;
            @if (!string.IsNullOrEmpty(msg))
            {
                &lt;label style=&quot;color: red&quot;&gt;@msg&lt;/label&gt;
            }
            &lt;button @onclick=&quot;Create&quot; class=&quot;acceptbtn&quot;&gt;Create&lt;/button&gt;
        &lt;/div&gt;
    }
&lt;/div&gt;
</code></pre>
<p>Page directive first, then importing namespaces, and we inject both <code>IUserService</code> and <code>ITodoService</code>.</p>
<p>Everything is wrapped in a <code>&lt;div&gt;</code>, we will make it card-ish, like we did with the create User page.</p>
<p>Then we have the if-else if-else. It is similar to the ViewUsers page, same purpose. If there are Users, the input elements are displayed.<br />
There is a header, <code>&lt;h3&gt;</code> and then a <code>&lt;div&gt;</code> containing a simple text input field. The value of which is bound to the field variable <code>todoTitle</code>. This time, we just use the default @bind, but don't specify an event. This means the value of todoTitle will be updated, when the input field is de-focused, i.e. you press enter, or click outside of it.<br />
Then the next div to hold a drop down menu. In HTML that is a <code>&lt;select&gt;</code>. Here we bind the value of what is selected to the field <code>selectedUserId</code>.<br />
We use a <code>@foreach</code> to generate all the options in the <code>&lt;select&gt;</code> tag. The value=&quot;@user.Id&quot; specifies what will be pushed to the field variable <code>selectedUserId. The </code>@user.UserName` is what will be displayed.<br />
I have included a &quot;dummy option&quot;, called &quot;Choose&quot; before the for-loop, just so that you have to make an active choice.</p>
<p>In the last div, we have the error message, and the button.</p>
<p>We could apply the same logic as seen in CreateUser page, where the button is disabled when there is no valid data. But here we see a simpler approach, just for some diversity.</p>
<h2 id="styling">Styling</h2>
<p>Create a style-behind for CreateTodo.razor. Insert the following styles (actually just copied from the style of CreateUser.razor.css):</p>
<pre><code class="line-numbers language-css">.card {
    box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2);
    transition: 0.3s;
    width: 250px;
    padding: 25px;
    text-align: center;
    margin: auto;
    margin-top: 50px;
    border-radius: 15px;
}

.field {
    margin-top: 20px;
}

.acceptbtn {
    background-color: lightgreen;
    border-radius: 5px;
    padding: 5px;
    padding-left: 10px;
    padding-right: 10px;
}

.button-row {
    margin-top: 15px;
}
</code></pre>
<p>Yes, it is identical to what you have in another page. We will optimize later.</p>
<h2 id="test">Test</h2>
<p>Run the Web API and your Blazor app. Open the page to create a new Todo. It should look like this:</p>
<p><img src="Resources/CreateTodoPageView.png" alt="img.png" /></p>
<p>Do some sunny and rainy tests. Verify you get error messages as expected, and verify the Todo goes into the data.json file in WebAPI component, when succeeding in creating a Todo.</p>
<h2 id="refactoring-styles">Refactoring Styles</h2>
<p>Now, because we are using the same styles twice, it would be a good idea to centralize it. If I wish to update the color of accept buttons, I would now have to do it in two places. So, repeating code is rarely good.<br />
We could just copy the style into the existing default file here: BlazorWASM/wwwroot/css/app.css.<br />
This file is &quot;global&quot;, i.e. styles here are accessible across your app. When doing style-behinds, those styles are available only to that specific page.</p>
<p>Alternatively we an create a new global style sheet, let's do that.</p>
<p>At this location: BlazorWASM/wwwroot/css create a new file: &quot;styles.css&quot;. Or whatever you want to call it.<br />
Copy the styles from your style-behind in here.</p>
<p>We then need to tell the app to load this style sheet too. Open BlazorWASM/wwwroot/index.html.</p>
<p>Inside the <code>&lt;head&gt;</code> tag add the highlighted line:</p>
<pre data-line="8"><code class="line-numbers language-html">&lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot; /&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no&quot; /&gt;
    &lt;title&gt;BlazorWASM&lt;/title&gt;
    &lt;base href=&quot;/&quot; /&gt;
    &lt;link href=&quot;css/bootstrap/bootstrap.min.css&quot; rel=&quot;stylesheet&quot; /&gt;
    &lt;link href=&quot;css/app.css&quot; rel=&quot;stylesheet&quot; /&gt;
    &lt;link href=&quot;css/styles.css&quot; rel=&quot;stylesheet&quot; /&gt;
    &lt;link href=&quot;BlazorWASM.styles.css&quot; rel=&quot;stylesheet&quot; /&gt;
&lt;/head&gt;
</code></pre>
<p>Notice how the already existing app.css is loaded in line 7. And by default a non-existing style-sheet with a name matching your project name is loaded in line 9. For whatever reason.</p>
<h3 id="delete-style-behinds">Delete style behinds.</h3>
<p>Now delete the two style behinds <code>CreateTodo.razor.css</code> and <code>CreateUser.razor.css</code>. Or do a &quot;soft-delete&quot; by just commenting out the comment in those two files for now.</p>
<p>Sometimes a Blazor app does not reload new styles correctly, and you will have to press <kbd>shift</kbd>+<kbd>F5</kbd> in your browser to do a hard refresh.</p>

</div>
<div class="tab">
<hr/><h1 id="view-all-todos">View All Todos</h1><hr/>
<p>Next up we work on the following user story:</p>
<blockquote>
<p>As a User I can view all or filtered Todos, so that I can remember what to do</p>
</blockquote>
<p>We want to se all todos, and potentially do some filtering.</p>
<p><a href="https://github.com/TroelsMortensen/WasmTodo/tree/013_ViewTodos">This feature is found here on GitHub</a></p>

</div>
<div class="tab">
<hr/><h1 id="get-all-todos">Get All Todos</h1><hr/>
<p>We start with the client layer, and first the interface.</p>
<p>We need to be able to retrieve Todos, and request them with filtering. We already have an endpoint for this.</p>
<h2 id="interface">Interface</h2>
<p>In ITodoService interface add the following method:</p>
<pre><code class="line-numbers language-csharp">Task&lt;ICollection&lt;Todo&gt;&gt; GetAsync(string? userName, int? userId, bool? completedStatus, string? titleContains);
</code></pre>
<h2 id="implementation">Implementation</h2>
<p>Next up, we implement the method in TodoHttpClient.</p>
<p>The method for fetching the data looks like this:</p>
<pre><code class="line-numbers language-csharp">public async Task&lt;ICollection&lt;Todo&gt;&gt; GetAsync(string? userName, int? userId, bool? completedStatus, string? titleContains)
{
    HttpResponseMessage response = await client.GetAsync(&quot;/todos&quot;);
    string content = await response.Content.ReadAsStringAsync();
    if (!response.IsSuccessStatusCode)
    {
        throw new Exception(content);
    }

    ICollection&lt;Todo&gt; todos = JsonSerializer.Deserialize&lt;ICollection&lt;Todo&gt;&gt;(content, new JsonSerializerOptions
    {
        PropertyNameCaseInsensitive = true
    })!;
    return todos;
}
</code></pre>
<p>It takes the four filter criteria, all nullable, in case we don't want to apply a specific filter. We currently use none of them. We will modify this code later, when we apply the filters.</p>
<p>It is the usual about making a GET request, checking the status code, and deserializing the response. You have seen this before.</p>

</div>
<div class="tab">
<hr/><h1 id="view-all-todos-page">View All Todos Page</h1><hr/>
<p>First, create a new Blazor page in the Pages directory. Call it &quot;ViewTodos&quot;.</p>
<p>This page is going to be a bit more complicated, we will expand it over a few iterations.</p>
<p>Initially it will just display all Todos.<br />
Then we add filtering functionality.<br />
Then the next user story is about completing a Todo, so we expand this page for that.<br />
We can edit Todos, which will be initiated in this page.<br />
We will also be able to delete Todos.<br />
And finally we will show a popup.</p>
<p>All these things, one thing at a time.</p>
<p>First, just load and display all Todos.</p>
<h2 id="the-code">The Code</h2>
<p>We need a method to fetch the Todos. So the code block looks like this:</p>
<pre><code class="line-numbers language-csharp">@code {
    private IEnumerable&lt;Todo&gt;? todos;
    private string msg = &quot;&quot;;

    private async Task LoadTodos()
    {
        try
        {
            todos = await todoService.GetAsync(null, null, null, null);
        }
        catch (Exception e)
        {
            Console.WriteLine(e);
            msg = e.Message;
        }
    }
}
</code></pre>
<p>We have a field to hold the Todos, and a <code>msg</code> for any messages to the user.</p>
<p>The method will get the Todos from the <code>ITodoService</code>. The method takes the four filter criteria, but we have none, currently</p>
<h2 id="the-view">The View</h2>
<p>The view code is shown below:</p>
<pre><code class="line-numbers language-csharp">@page &quot;/ViewTodos&quot;
@using Domain.Models
@using HttpClients.ClientInterfaces
@inject ITodoService todoService

&lt;h3&gt;Todos&lt;/h3&gt;

&lt;div&gt;
    &lt;button @onclick=&quot;LoadTodos&quot;&gt;Load&lt;/button&gt;
&lt;/div&gt;

@if (todos == null)
{
}
else if (!todos.Any())
{
    &lt;p&gt;No Todos to display&lt;/p&gt;
}
else
{
    &lt;table class=&quot;table&quot;&gt;
        &lt;thead&gt;
        &lt;tr&gt;
            &lt;th&gt;Todo ID&lt;/th&gt;
            &lt;th&gt;Owner ID&lt;/th&gt;
            &lt;th&gt;Title&lt;/th&gt;
            &lt;th&gt;Completed?&lt;/th&gt;
        &lt;/tr&gt;
        &lt;/thead&gt;
        &lt;tbody&gt;
        @foreach (var item in todos)
        {
            &lt;tr&gt;
                &lt;td&gt;@item.Id&lt;/td&gt;
                &lt;td&gt;@item.Owner.UserName&lt;/td&gt;
                &lt;td&gt;@item.Title&lt;/td&gt;
                &lt;td&gt;@item.IsCompleted&lt;/td&gt;
            &lt;/tr&gt;
        }
        &lt;/tbody&gt;
    &lt;/table&gt;
}
@if (!string.IsNullOrEmpty(msg))
{
    &lt;label style=&quot;color: red&quot;&gt;@msg&lt;/label&gt;
}
</code></pre>
<p>The usual at the top, page directive, imports, injects.</p>
<p>We have the button in line 9 to call the <code>LoadTodos()</code> method.</p>
<p>Then the usual checks we do, when we want to display a collection: if-else if-else.</p>
<p>The else-part is the only interesting thing here. We define a table. Lines 24-27 are the column titles.<br />
The rows are generated with a foreach-loop, iterating over the Todos.<br />
Each row consists of some table data, each cell is in the <code>&lt;td&gt;</code> tags. Here we pull the data from the Todos to display in the view.<br />
Notice the <code>Owner</code> is a User object, therefore, we need to go a step deeper for the actual user name.</p>
<h4 id="styling">Styling</h4>
<p>We will skip styling, the reader is welcome to apply some themself. Define the css in either a style-behind (we won't do other tables, so isolating the css might be fine), or use one of the global css files.</p>
<h2 id="test">Test</h2>
<p>This should be working now. Run your Web API and Blazor app, navigate to the View Users page, and press the load button. You should see your Todos displayed in the table.</p>
<p>We will now expand this page with filtering functionality.</p>

</div>
<div class="tab">
<hr/><h1 id="view-todos-with-filtering">View Todos With Filtering</h1><hr/>
<p><a href="">This part of the feature is in a new branch here</a>.</p>
<p>We will continue on the View Todos page, by adding some filtering functionality to it.</p>
<p>This requires four input fields in the view. The data of these should then be passed to the ITodoService.</p>
<p>Our Web API should already be able to handle things from there.</p>
<h2 id="icons">Icons</h2>
<p>We are going to use two icons.</p>
<p>First, create a directory called &quot;icons&quot; here:</p>
<p><img src="Resources/IconsFolder.png" alt="img.png" /></p>
<p>This directory will house our icons. Since they are inside the &quot;wwwroot&quot; we can easily use them in the pages.</p>
<p>Next, download the two following funnel icons, and place them into the directory. You should be able to right click them, and select to &quot;save as&quot;. <a href="https://github.com/TroelsMortensen/WasmTodo/tree/014_ViewTodosWithFilter/BlazorWASM/wwwroot/icons">Otherwise find them here</a></p>
<p><img src="Resources/funnel.png" alt="" /></p>
<p><img src="Resources/clear_funnel.png" alt="" /></p>
<p>We will use these icons as buttons to open/close the filters. Take a moment to appreciate the icons, I made them myself.</p>
<p><img src="Resources/IMadeIt.gif" alt="" /></p>
<h2 id="code-block">Code Block</h2>
<p>We must provide field variables to hold the data for the new input fields. They must be passed to the call to get Todos from the ITodoService.</p>
<p>It looks like this:</p>
<pre data-line="6-9,20"><code class="line-numbers language-csharp">@code {
    private IEnumerable&lt;Todo&gt;? todos;
    private string msg = &quot;&quot;;
    private bool doShowFilters = false;

    private string? usernameFilter;
    private int? userIdFilter;
    private string? completedStatusFilter;
    private string? titleContainsFilter;
    
    private async Task LoadTodos()
    {
        try
        {
            bool? completedFilterValue = null;
            if (!string.IsNullOrEmpty(completedStatusFilter) &amp;&amp; !completedStatusFilter.Equals(&quot;all&quot;))
            {
                completedFilterValue = bool.Parse(completedStatusFilter);
            }
            todos = await todoService.GetAsync(usernameFilter, userIdFilter, completedFilterValue, titleContainsFilter);
        }
        catch (Exception e)
        {
            Console.WriteLine(e);
            msg = e.Message;
        }
    }
}
</code></pre>
<p>In lines 14-18 we get the value of the input field for the completed status. We are using a drop-down menu, with the values &quot;all&quot;, &quot;true&quot;, &quot;false&quot;. And so, if all is selected, the filter is not applied. Otherwise the value is parsed to a boolean.<br />
All four fields are nullable, so we can choose to not provide a value, to indicate a specific filter should be ignored.</p>
<p>Notice also the field <code>doShowFilters</code>, which is used to determine whether the filters should be shown or not.</p>
<h2 id="view">View</h2>
<p>We must update the view to display the four new required input fields. We will make a show/hide functionality using the funnel icons from above.</p>
<p>Below is shown the first part of the view, but not the table definition.</p>
<pre><code class="line-numbers language-razor">@page &quot;/ViewTodos&quot;
@using Domain.Models
@using HttpClients.ClientInterfaces
@inject ITodoService todoService

&lt;h3&gt;Todos&lt;/h3&gt;
&lt;div class=&quot;filter-bar&quot;&gt;
    &lt;div class=&quot;filters-container&quot;&gt;
        &lt;img src=&quot;icons/@(doShowFilters ? &quot;clear_&quot; : &quot;&quot;)funnel.png&quot; class=&quot;funnel&quot; @onclick=&quot;@(() =&gt; doShowFilters = !doShowFilters)&quot; alt=&quot;Funnel&quot;/&gt;
        @if (doShowFilters)
        {
            &lt;div class=&quot;filter&quot;&gt;
                &lt;label&gt;Username:&lt;/label&gt;
                &lt;input type=&quot;text&quot; @bind=&quot;usernameFilter&quot;/&gt;
            &lt;/div&gt;
            &lt;div class=&quot;filter&quot;&gt;
                &lt;label&gt;User id:&lt;/label&gt;
                &lt;input type=&quot;number&quot; @bind=&quot;userIdFilter&quot;/&gt;
            &lt;/div&gt;
            &lt;div class=&quot;filter&quot;&gt;
                &lt;label&gt;Is completed?&lt;/label&gt;
                &lt;select @bind=&quot;completedStatusFilter&quot;&gt;
                    &lt;option value=&quot;all&quot;&gt;All&lt;/option&gt;
                    &lt;option value=&quot;true&quot;&gt;Yes&lt;/option&gt;
                    &lt;option value=&quot;false&quot;&gt;No&lt;/option&gt;
                &lt;/select&gt;
            &lt;/div&gt;
            &lt;div class=&quot;filter&quot;&gt;
                &lt;label&gt;Title contains:&lt;/label&gt;
                &lt;input type=&quot;text&quot; @bind=&quot;titleContainsFilter&quot;/&gt;
            &lt;/div&gt;
        }
    &lt;/div&gt;
&lt;/div&gt;

&lt;div&gt;
    &lt;button @onclick=&quot;LoadTodos&quot;&gt;Load&lt;/button&gt;
&lt;/div&gt;
</code></pre>
<p>The new part is from the <code>&lt;div&gt;</code> tag, with the class of &quot;filter-bar&quot;. Here we create a container to hold the filter input fields.</p>
<p>The <code>&lt;img&gt;</code> tag displays either the &quot;funnel&quot; icon or the &quot;clear_funnel&quot; icon, based on the value of <code>doShowFilters</code>. This part here:</p>
<pre><code class="line-numbers language-razor">src=&quot;icons/@(doShowFilters ? &quot;clear_&quot; : &quot;&quot;)funnel.png&quot;
</code></pre>
<p>Inside the parenthesis is a &quot;ternary expression&quot;, it is a short-hand if-then-else. If <code>doShowFilters</code> is true, the &quot;clear_&quot; is returned, otherwise the &quot;&quot;. The value is then put together with <code>funnel.png</code>. So the src value will be either:</p>
<ul>
<li>clear_funnel.png</li>
<li>funnel_png</li>
</ul>
<p>There is an onclick handler attached, with the <code>@onclick</code>, containing the following lambda expression:</p>
<pre><code class="line-numbers language-csharp">() =&gt; doShowFilters = !doShowFilters
</code></pre>
<p>What this will do is simple to just flip the value of doShowFilters. If it is <code>false</code>, it will become <code>true</code> and vice versa.</p>
<p>Then we have the <code>@if</code>-statement checking if the filter inputs should be displayed. We have:</p>
<ol>
<li>First a text input for the ser name.</li>
<li>Then a number input to filter by User ID.</li>
<li>Then a drop down, i.e. <code>&lt;select&gt;</code>, with three values: all, true, false. If all is selected, this filter is not used.</li>
<li>And finally a text input to check if the Title of a Todo contains the inserted text.</li>
</ol>
<p>The div, and nested button, below already existed, they are merely included so that you can see what part of the view is new.</p>
<h2 id="styling">Styling</h2>
<p>We do need a bit of styling, e.g. the icons are too large, and the filters should be organized just a little bit.</p>
<p>Create a style-behind, <code>ViewTodos.razor.css</code>, and paste in the following style:</p>
<pre><code class="line-numbers language-css">.filter-bar {
    border: 1px solid #ccc;
    border-radius: 10px;
    padding: 5px;
    display: inline-block;
    margin: 10px;
}

.funnel{
    width:30px;
    height:30px;
    cursor: pointer;
}

.filter {
    border: 1px solid #ccc;
    border-radius: 5px;
    padding: 5px;
    margin: 5px;
    text-align: center;
}
</code></pre>
<p>You are obviously welcome to fiddle around, if you wish to make it prettier.</p>
<h2 id="todohttpclient">TodoHttpClient</h2>
<p>In this class we need to take the filter arguments and construct a string of query parameters to suffix to the URI.</p>
<p>We make the following changes. There is a new line of code in the existing <code>GetAsync()</code> method, the first line. And a new method. Here:</p>
<pre data-line="3"><code class="line-numbers language-csharp">public async Task&lt;ICollection&lt;Todo&gt;&gt; GetAsync(string? userName, int? userId, bool? completedStatus, string? titleContains)
{
    string query = ConstructQuery(userName, userId, completedStatus, titleContains);

    HttpResponseMessage response = await client.GetAsync(&quot;/todos&quot;+query);
    string content = await response.Content.ReadAsStringAsync();
    if (!response.IsSuccessStatusCode)
    {
        throw new Exception(content);
    }

    ICollection&lt;Todo&gt; todos = JsonSerializer.Deserialize&lt;ICollection&lt;Todo&gt;&gt;(content, new JsonSerializerOptions
    {
        PropertyNameCaseInsensitive = true
    })!;
    return todos;
}

private static string ConstructQuery(string? userName, int? userId, bool? completedStatus, string? titleContains)
{
    string query = &quot;&quot;;
    if (!string.IsNullOrEmpty(userName))
    {
        query += $&quot;?username={userName}&quot;;
    }

    if (userId != null)
    {
        query += string.IsNullOrEmpty(query) ? &quot;?&quot; : &quot;&amp;&quot;;
        query += $&quot;userid={userId}&quot;;
    }

    if (completedStatus != null)
    {
        query += string.IsNullOrEmpty(query) ? &quot;?&quot; : &quot;&amp;&quot;;
        query += $&quot;completedstatus={completedStatus}&quot;;
    }

    if (!string.IsNullOrEmpty(titleContains))
    {
        query += string.IsNullOrEmpty(query) ? &quot;?&quot; : &quot;&amp;&quot;;
        query += $&quot;titlecontains={titleContains}&quot;;
    }

    return query;
}
</code></pre>
<p>So, the second method, <code>ConstructQuery(...)</code> is the interesting one.</p>
<p>It will check each filter argument, check if they are not null, in which case they should be ignore. And otherwise include the needed filter arguments in the query parameter string.</p>
<p>Results could for example be:</p>
<ul>
<li>&quot;?username=Troels&amp;titlecontains=hej&quot;</li>
<li>&quot;?userid=3&quot;</li>
<li>&quot;?completedstatus=false&amp;titlecontains=hej&quot;</li>
</ul>
<p>The query string must always start with a &quot;?&quot;, and each query is separated with &quot;&amp;&quot;.</p>
<p>This is achieved by all the ternary expressions, e.g. <code>query += string.IsNullOrEmpty(query) ? &quot;?&quot; : &quot;&amp;&quot;;</code>. The <code>query</code> variable is expanded upon for each if-statement.<br />
If it is empty, it means we are about to append the first query parameter, and the string must start with &quot;?&quot;. If the <code>query</code> is <em>not</em> empty, we are about to append another query parameter, and so we must insert &quot;&amp;&quot; to separate the existing with the new parameter.</p>
<p>The result of this method, the finished query string, is returned, and appended to &quot;/todos&quot;, so that they can be passed to the endpoint handling GET requests of &quot;/todos&quot;.</p>
<h6 id="thoughts">Thoughts</h6>
<p>As discussed in the tutorial of the Web API, when constructing the endpoint we are using here, it was discussed to instead use a POST with an object containing the query parameters. This might have been simpler.
And easier to expand upon.<br />
If we wish to add another query parameter, or remove one, we currently have to modify various things in: ViewTodos.razor, ITodoService, TodoHttpClient, TodosController. And also the TodoFileDao class.</p>
<p>However if the arguments were wrapped in an object, which would be created in ViewTodos.razor, it would be like a tunnel, and we would only have to modify the two ends, in this case: ViewTodos.razor, and TodoFileDao. So, in general it is better practice to wrap multiple simple type parameters into a single object.</p>
<h2 id="test">Test</h2>
<p>We are ready to test the filtering.</p>
<p>First, you may need to add a couple of Todos, so you have at least 10 with various values. The completed status must be manually changed from &quot;false&quot; to &quot;true&quot; in the <code>data.json</code> file, do this for a few Todos.</p>
<p>Run the Web API, then run the Blazor App.</p>
<p>Navigate to the page.</p>
<p>First just click load without applying filters, to verify that we didn't break anything.</p>
<p>Then play around with the filters, apply one or more in various combinations to verify the result is as expected.</p>

</div>
<div class="tab">
<hr/><h1 id="making-a-checkbox-component">Making a Checkbox Component</h1><hr/>
<p>We are about to let users complete Todos. We will do this in the existing ViewTodos page. The table has a column to display the status of a Todo, currently as a piece of text. We will change this to be a check-box.</p>
<p>This gives us an opportunity to create our own fancy checkbox as a component, to show an example of how to use components. So, before starting on the user story, we will make this fancy check box.</p>
<p><a href="https://github.com/TroelsMortensen/WasmTodo/tree/015_CheckBoxComponent">This part of the tutorial is found here</a></p>
<h2 id="what-are-components">What Are Components?</h2>
<p>Blazor is relying on a component structure. Here we talk about Blazor-components, not the components mentioned in the discussion of architecture, i.e. the projects in your solution.</p>
<p>You don't strictly need components, we have not used them so far, and we have done just fine, but they can provide various benefits.</p>
<p>Various UI elements can be made into components, so that they can be reused, without you having to copy-paste code. This can be very convenient.</p>
<p>Consider the &quot;Create&quot;-button we used in both CreateTodo and CreateUser.
It looked the same, had the same styling, it could have the same functionality (with the disabling).<br />
Currently we have duplicated the HTML and code, but we could make the button into a component, and have the HTML, code, styling, and behaviour in just one place. Then it would be easy to use it all over our app, and if we needed to change something, e.g. make the color a slightly different shade of green, or add some disabling effect, or some other behaviour, everything is located in one place. We would need to only update on place. And so we would follow the <a href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself">DRY principle</a>, i.e. don't duplicate code.</p>
<p>You can create your own components, which we are about to. You can also import libraries of components made by others. Here are some popular ones, if you are curious.</p>
<ul>
<li>Blazor fluent UI, found <a href="https://www.blazorfluentui.net/">here</a></li>
<li>Radzen, found <a href="https://www.radzen.com/">here</a></li>
<li>Syncfusion, found <a href="https://www.syncfusion.com/blazor-components">here</a></li>
<li>Blazored, found <a href="https://giters.com/Blazored">here</a></li>
<li>AntBlazor, found <a href="https://antblazor.com/en-US/">here</a></li>
<li>MudBlazor, found <a href="https://mudblazor.com/">here</a></li>
</ul>
<p>We will make a component now, just a simple check box, and then we will use that in the next feature to complete Todos.</p>
<p><img src="Resources/ItWillBeGlorious.png" alt="img.png" /></p>

</div>
<div class="tab">
<hr/><h1 id="checkbox-component">Checkbox Component</h1><hr/>
<h2 id="purpose">Purpose</h2>
<p>The main purpose here is the introduction to the concept of BlazorComponents.</p>
<p>A secondary purpose is to show one way of passing parameters to a nested component, from a parent component/page</p>
<h2 id="lets-go">Let's Go</h2>
<p>We start by creating a new component file. It is the same as what we have done when creating pages, we just don't need the @page directive at the top. That is the only difference.</p>
<p>First, we might want to organize our files a bit, create a new directory inside Pages, call it UIComponents.</p>
<p>Inside this new directory, create a new component, call it &quot;FancyCheckBox&quot;.</p>
<p><img src="Resources/NewComponent.png" alt="img.png" /></p>
<p>And then:</p>
<p><img src="Resources/SelectComponent.png" alt="img.png" /></p>
<p>This will give you a file with the following content:</p>
<pre><code class="line-numbers language-razor">&lt;h3&gt;FancyCheckBox&lt;/h3&gt;

@code {
    
}
</code></pre>
<p>Notice, the only difference of a new Page and new Component, is that the Page has the @page directive at the top.</p>
<p>Remember, Pages can work as Components too, even though that may be less standard.</p>
<p>In this file, FancyCheckBox, we just want to have HTML for a checkbox, a little bit of functionality, and some styling, for the &quot;Fancy&quot; part.</p>
<h2 id="the-code">The Code</h2>
<p>We just need the initial value of the Todo<span>IsCompleted, and we need a call-back delegate. When the value of this component changes, we want to set the value of the Todo</span>IsCompleted property. Think observer pattern, we use a delegate. Or more specifically, we use a sub-class called <code>EventCallback&lt;..&gt;</code>, which is generally used in Blazor.</p>
<p>So, the code looks like this:</p>
<pre><code class="line-numbers language-csharp">@code {
    
    [Parameter]
    public bool IsCompleted { get; set; }
    
    [Parameter]
    public EventCallback&lt;bool&gt; OnChange { get; set; }
}
</code></pre>
<p>We have the two properties, one for the initial value, <code>IsCompleted</code>, and a delegate to notify interested parties of changes, the <code>OnChange</code>.<br />
But each have an attribute, <code>[Parameter]</code>, now what's that about?</p>
<p>When you instantiate new classes in C#, they often have a constructor, so that you can pass arguments to the class.<br />
What we have here is similar. Wherever we use this component (which may be many places across a large app), we wish to provide it with some initial information, the value of <code>IsCompleted</code>, and we may want to subscribe methods to the <code>OnChange</code>. This must be done from the &quot;outside&quot; of this component.<br />
We can set these properties from the outside, when we mark them with <code>[Parameter]</code>. We will see how shortly.</p>
<p>The point is, initially the checkbox value must be set to either true or false, given the value of the specific Todo. And we must subscribe a method to be invoked, whenever the checkbox is clicked, so that we may update the todo.</p>
<p>Let's take a look at</p>
<h2 id="the-view">The View</h2>
<p>Now, I style this specific checkbox visual from some online example, and it is obviously more fancy than what we need. We could just use the default HTML-checkbox, but that is dull.</p>
<p>So, this is the view:</p>
<pre><code class="line-numbers language-razor">@namespace UIComponents

&lt;label class=&quot;checkbox-container&quot;&gt;
    &lt;input 
        type=&quot;checkbox&quot; 
        class=&quot;checkbox-input&quot; 
        checked=&quot;@IsCompleted&quot; 
        @onchange=&quot;@((arg) =&gt; OnChange.InvokeAsync((bool)arg.Value!))&quot;
    /&gt;
    &lt;span class=&quot;checkbox-span&quot;&gt;&lt;/span&gt;
&lt;/label&gt;
</code></pre>
<p>First, because the file is not located directly inside the Pages directory, we must define a namespace. We will use this namespace in other pages/components to import this functionality.</p>
<p>There is a surrounding label with some styling. Inside there is an input of type checkbox, and a span, which is used for for the graphics.<br />
Let's take a closer look at the <code>&lt;input ../&gt;</code>:</p>
<pre><code class="line-numbers language-razor">&lt;input 
    type=&quot;checkbox&quot; 
    class=&quot;checkbox-input&quot; 
    checked=&quot;@IsCompleted&quot; 
    @onchange=&quot;@((arg) =&gt; OnChange.InvokeAsync((bool)arg.Value!))&quot;
/&gt;
</code></pre>
<p>Line 2: We define the input type to be a checkbox.<br />
Line 3: We define the styling class.<br />
Line 4: We set the initial value of the checkbox to the value from the property.<br />
Line 5: We define what should happen, when the value changes: we provide a lambda expression, which just invokes the <code>OnChange</code>, i.e. we invoke subscribed methods.</p>
<p>Finally..</p>
<h2 id="the-styling">The Styling</h2>
<p>It looks like this, put it in a style-behind of the FancyCheckBox.</p>
<pre><code class="line-numbers language-css">.checkbox-container {
    display: inline-block;
    width: 30px;
    height: 30px;
    cursor: pointer;
}

.checkbox-input {
    position: absolute;
    transform: scale(0);
}

.checkbox-input:checked ~ .checkbox-span {
    transform: rotate(45deg);
    width: 15px;
    margin-left: 8px;
    border-color: #24c78e;
    border-top-color: transparent;
    border-left-color: transparent;
    border-radius: 0;
}

.checkbox-span {
    display: block;
    width: inherit;
    height: inherit;
    border: 3px solid #434343;
    border-radius: 6px;
    transition: all 0.375s;
}
</code></pre>
<h2 id="initial-test">Initial Test</h2>
<p>Before actually taking it in use, let's test if the graphics work as expected.</p>
<p>Open the page Index.razor.</p>
<p>Modify it to look like this:</p>
<pre><code class="line-numbers language-razor">@page &quot;/&quot;
@using UIComponents

&lt;PageTitle&gt;Index&lt;/PageTitle&gt;

&lt;h1&gt;Hello, world!&lt;/h1&gt;

Welcome to your new app.

&lt;SurveyPrompt Title=&quot;How is Blazor working for you?&quot;/&gt;

&lt;FancyCheckBox/&gt;
</code></pre>
<p>Notice the second line, where we import the namespace, defined in the FancyCheckBox component file.</p>
<p>And then the bottom line, where we insert the component. It almost looks like we are just using a normal HTML tag.</p>
<p>Your IDE, however, should color code it different from standard HTML. Here's what my theme looks like:</p>
<p><img src="Resources/ComponentHighlight.png" alt="img.png" /></p>
<p>Notice the component is in purple, same as the SurveyPrompt, which is another component, that came with the template project. <code>&lt;PageTitle&gt;</code> is again also a component, defined in the Blazor framework.</p>
<p>Now, go ahead and delete the line <code>@using UIComponents</code>, and you should see your component change color to that of HTML, in my case blue. The colors help to indicate that you may have forgotten to import a specific component, and so it will not show up in the UI, when running the app.<br />
Put the using statement back again.</p>
<p>When the UI is rendered, the content of the component is extracted, and inserted into the final page, so when you inspect the html of the UI in the browser, you will not see that some of the html came from a component.</p>
<p>You can duplicate the line of <code>&lt;FancyCheckBox/&gt;</code> a couple of times to get more checkboxes. That's the easy re-usability mentioned earlier.</p>
<p>Sometimes components are made for re-usability, but I find that often components are made because your page grows too large. You can then take parts of a page, and refactor out into a new component. This can be a very good way to organize your pages.</p>
<p>Now, the test. Run your Blazor app, we don't need the Web API for this, as we are not retrieving any data just yet.</p>
<p>Your front page should now look like this:</p>
<p><img src="Resources/CheckBoxInAction.gif" alt="" /></p>
<p>My god, is that fancy or what?!</p>
<p>Okay, we haven't provided any parameters to it just yet. So let's go and use it for real.</p>
<p>You may delete the component from the Index.razor page, if you wish.</p>

</div>
<div class="tab">
<hr/><h1 id="using-the-checkbox">Using the Checkbox</h1><hr/>
<p>We need to modify the ViewTodos page, so that instead of displaying a textual value, we use the new</p>
<p><img src="Resources/FancyCheckBoxMeme.png" alt="img.png" /></p>
<p><a href="https://github.com/TroelsMortensen/WasmTodo/tree/015_CheckBoxComponent">The code is found in this branch</a></p>
<h2 id="the-service">The Service</h2>
<p>First, we must create a new method in TodoHttpClient responsible for making update requests.</p>
<h4 id="interface">Interface</h4>
<p>Start by putting the following method into the interface <code>ITodoService</code>:</p>
<pre><code class="line-numbers language-csharp">    Task UpdateAsync(TodoUpdateDto dto);
</code></pre>
<p>We already have the <code>TodoUpdateDto</code> class, i.e. the argument, which is what the PATCH endpoint in your Web API needs.</p>
<h4 id="implementation">Implementation</h4>
<p>Now, we must implement the method in TodoHttpClient.</p>
<p>It is similar to the <code>CreateAsync()</code> method in this class. We must make a PATCH request, and check the response for error code.</p>
<p>However, where there is a <code>PostAsJson()</code> method, there is no <code>PatchAsJson</code>. So, we must use the client slightly differently.</p>
<p>This is then the method:</p>
<pre><code class="line-numbers language-csharp">public async Task UpdateAsync(TodoUpdateDto dto)
{
    string dtoAsJson = JsonSerializer.Serialize(dto);
    StringContent body = new StringContent(dtoAsJson, Encoding.UTF8, &quot;application/json&quot;);

    HttpResponseMessage response = await client.PatchAsync(&quot;/todos&quot;, body);
    if (!response.IsSuccessStatusCode)
    {
        string content = await response.Content.ReadAsStringAsync();
        throw new Exception(content);
    }
}
</code></pre>
<p>First the dto argument is manually serialized to JSON. That was otherwise handled for us when using <code>PostAsJson(..)</code>.<br />
Then we create a <code>StringContent</code> to hold the data in the body of the request message. We provide as arguments first the &quot;dto as JSON&quot;, then the encoding, and finally the format of the string. We are sending JSON, so we pass &quot;application/json&quot;. I don't know why it must be prefixed with &quot;application/&quot;, maybe someone will some day google this, and tell me.</p>
<p>We make a Patch request with the client, providing endpoint URI and the content for the body.</p>
<p>Then the status is checked, and in case of errors from the server, we throw an exception, so we can provide feedback to the user.</p>
<h2 id="the-view">The View</h2>
<p>First, we must import the component in ViewTodos.razor at the top:</p>
<pre data-line="4"><code class="line-numbers language-razor">@page &quot;/ViewTodos&quot;
@using Domain.Models
@using HttpClients.ClientInterfaces
@using UIComponents
@using Domain.DTOs
@inject ITodoService todoService
</code></pre>
<p>Then we must modify the table definition to use the component. Here is the snippet:</p>
<pre data-line="20-22"><code class="line-numbers language-razor">...
else
{
    &lt;table class=&quot;table&quot;&gt;
        &lt;thead&gt;
        &lt;tr&gt;
            &lt;th&gt;Todo ID&lt;/th&gt;
            &lt;th&gt;Owner ID&lt;/th&gt;
            &lt;th&gt;Title&lt;/th&gt;
            &lt;th&gt;Completed?&lt;/th&gt;
        &lt;/tr&gt;
        &lt;/thead&gt;
        &lt;tbody&gt;
        @foreach (var item in todos)
        {
            &lt;tr&gt;
                &lt;td&gt;@item.Id&lt;/td&gt;
                &lt;td&gt;@item.Owner.UserName&lt;/td&gt;
                &lt;td&gt;@item.Title&lt;/td&gt;
                &lt;td&gt;
                    &lt;FancyCheckBox IsCompleted=&quot;@item.IsCompleted&quot; OnChange=&quot;@((status) =&gt; CompleteTodo(item, status))&quot;/&gt;
                &lt;/td&gt;
            &lt;/tr&gt;
        }
        &lt;/tbody&gt;
    &lt;/table&gt;
}
..
</code></pre>
<p>Notice lines 20-22. Here we use the FancyCheckBox component. This time we also set the properties.<br />
The <code>IsCompleted</code> property is set to the value of the <code>item</code> from the foreach loop.<br />
To the <code>OnChange</code> delegate we subscribe a lambda expresion. The argument is a bool, i.e. the value of the check box, and we pass that bool, along with the <code>item</code> variable to a method, yet to be created.</p>
<p>So the component is initialized with the IsCompleted value of the <code>item</code>, and whenever we click the checkbox, the <code>CompleteTodo(..)</code> method is called. Let's define that method next.</p>
<h2 id="the-code-block">The Code Block</h2>
<p>We must add the new method to the code block, it looks like this:</p>
<pre><code class="line-numbers language-csharp">private async Task CompleteTodo(Todo item, bool status)
{
    TodoUpdateDto dto = new(item.Id)
    {
        IsCompleted = status
    };
    
    try
    {
        await todoService.UpdateAsync(dto);
    }
    catch (Exception e)
    {
        Console.WriteLine(e);
        msg = e.Message;
    }
}
</code></pre>
<p>First we create an instance of <code>TodoUpdateDto</code>. The ID must be set through the constructor, to indicate which Todo is to be updated.
The other properties are optional, so we only set the <code>IsCompleted</code>, because that is the only thing, we wish to change.</p>
<p>We pass the dto to the TodoHttpService, and display any error messages.</p>
<p>That should all, time for testing.</p>
<h2 id="testing">Testing</h2>
<p>Start Web API, start Blazor.</p>
<p>Navigate to View Todos page, load the list of todos.</p>
<p>Click on a check mark of an uncompleted Todo, and watch the box change to a checkmark. But is the data saved?</p>
<p>You just reload the page, or navigate to a different page and back again to reload the data. Be aware that modified Todos are at the bottom now.</p>
<h4 id="a-bug">A Bug?</h4>
<p><img src="Resources/ComputerBug.png" alt="img.png" /></p>
<p>Remember, on the server side we implemented a business rule stating that completed Todo items cannot be uncompleted.</p>
<p>Now, if you were to try to un-complete an item, that would sort of go okay:</p>
<ul>
<li>You will see that check checkmark changes back to a box, indicating the Todo is no longer complete.</li>
<li>You will also see an error message below the table, indicating the Todo could <em>not</em> be un-completed.</li>
<li>If you refresh the page, reload the data, you will see that the change was <em>in fact not saved</em>.</li>
</ul>
<p>So, the server logic works. But the UI does not match the effect entirely.</p>
<h4 id="a-fix">A Fix?</h4>
<p>We could attempt to make it so that when you click the checkbox, it would attempt to change the value, but in case of errors it would not change.</p>
<p>In the FancyCheckBox component, instead of the lambda expression simply invoking the EventCallback, we could have the <code>@onchange</code> call a method, which would invoke the EventCallback, and catch exceptions.
In case of an exception we would set back the IsCompleted property.</p>
<p>We would have to re-throw the exception caught in ViewTodos::CompleteTodo.</p>
<p>Is it important to fix this bug for the purpose of this tutorial? Not really. So, I'll leave it for now, and maybe come back to it later.</p>
<p><img src="Resources/DealWithIt.png" alt="img.png" /></p>

</div>
<div class="tab">
<hr/><h1 id="edit-todo">Edit Todo</h1><hr/>
<p>This isn't exactly a user story. However, we have the Web API endpoint which can update a Todo, so let's make the front end part of that functionality.<br />
<a href="https://github.com/TroelsMortensen/WasmTodo/tree/016_EditTodo">You can find the code in this branch</a></p>
<p>Furthermore, this will show a way to pass arguments to a page.</p>
<p>For the View Todos page, we would potentially select some filters, and ask to load the data with the click of a button.<br />
Sometimes you want the page to auto-load something, but what that something is may vary.</p>
<p>Imaging this: Your Todo object has many more properties than the current version. The View Todos will provide an overview, but not show details for each Todo.<br />
To see details, we would click on a row in the table, or an icon in a row, to &quot;view details&quot;.<br />
We would be taken to a different page, and that page should automatically display details for the Todo we selected.<br />
We don't want to have to search for a specific Todo on this next page.</p>
<p>This is a common case, you will often need, so we include the feature here.</p>
<p>It requires a new page, and modifications to the ViewTodos.razor.</p>
<p>We already have a method in ITodoService to support this feature: ITodoService::UpdateAsync.<br />
We will need another method to Get a single Todo, by Id.</p>

</div>
<div class="tab">
<hr/><h1 id="get-todo-by-id">Get Todo By Id</h1><hr/>
<p>We need to be able to retrieve a single Todo, given it's ID. We could reuse the method, which returns a collection, but I prefer to have a specific method for this.</p>
<h2 id="the-interface">The Interface</h2>
<p>In ITodoService add the following method signature:</p>
<pre><code class="line-numbers language-csharp">Task&lt;TodoBasicDto&gt; GetByIdAsync(int id);
</code></pre>
<h2 id="the-implementation">The Implementation</h2>
<p>You must make a GET request, with the id, to the Web API. It should return a single <code>TodoBasicDto</code>, which is deserialized and returned. Check error status codes.</p>
<p>Give it a try yourself.</p>
<details>
<summary>hint</summary>
<pre><code class="line-numbers language-csharp">public async Task&lt;TodoBasicDto&gt; GetByIdAsync(int id)
{
    HttpResponseMessage response = await client.GetAsync($&quot;/todos/{id}&quot;);
    string content = await response.Content.ReadAsStringAsync();
    if (!response.IsSuccessStatusCode)
    {
        throw new Exception(content);
    }

    TodoBasicDto todo = JsonSerializer.Deserialize&lt;TodoBasicDto&gt;(content, new JsonSerializerOptions
    {
        PropertyNameCaseInsensitive = true
    })!;
    return todo;
}
</code></pre>
<p>This should be pretty standard, no big surprises here. Notice the null-suppressor &quot;!&quot; at the end of line 13.</p>
</details>
<h4 id="comment">Comment</h4>
<p>Now the Web API returns a <code>TodoBasicDto</code> instead of a Todo. That might be annoying, and we could consider changing it. But let is stick with it for now, to minimize the required changes to existing code.</p>

</div>
<div class="tab">
<hr/><h1 id="edit-todo-page">Edit Todo Page</h1><hr/>
<p>First, inside Pages, create a new page: &quot;EditTodo&quot;.</p>
<p>The content is then:</p>
<pre><code class="line-numbers language-razor">@page &quot;/EditTodo/{id:int}&quot;

&lt;h3&gt;EditTodo&lt;/h3&gt;

@code {
    
}
</code></pre>
<p>Notice we are back to &quot;pages&quot;, as there is a @page directive at the top. Further notice I have added a bit extra:</p>
<pre><code class="line-numbers language-razor">@page &quot;/EditTodo/{id:int}&quot;
</code></pre>
<p>This means we can access this page with a sub-uri, e.g.:</p>
<ul>
<li>...localhost:port/EditTodo/7</li>
</ul>
<p>The idea is then, that the page will display Todo with ID 7.
I don't specifically need the <code>:int</code> part, but this is a constraint.
If we leave it out, e.g. <code>/EditTodo/{id}</code>, then <code>id</code> will be a string, and it must be assigned to a string property,
and we would have to parse it to an int afterwards.</p>
<h2 id="the-code-block">The Code Block</h2>
<p>We start with the code needed, there are several things going on, so you get the code in snippets. All goes into the code block.</p>
<h4 id="fields">Fields</h4>
<pre><code class="line-numbers language-csharp">[Parameter]
public int Id { get; set; }

private TodoUpdateDto dto = null!;
private string msg = &quot;&quot;;
private IEnumerable&lt;User&gt;? users;
</code></pre>
<p>It's a longer code block, with several things to notice.</p>
<p id:int=""><strong>Lines 1-2</strong>: Here we define the int property to hold the ID of the Todo we wish to edit. Remember, the value for this property was provided through the URI to the page: in the @page directive, we specified &quot;/&quot;. Because the property has the same name (ignoring case) as the uri parameter, and is marked with the parameter attribute, the value from the uri will be pasted into the property when the page is accessed.</p>
<p><strong>Lines 4-6</strong>: Various properties. <code>dto</code> will hold the data of the Todo we wish to edit, and then the modified data. <code>msg</code> is as always for user feedback. <code>users</code> is used in a drop down to select a User, if we wish to reassign a Todo to a different User.</p>
<h3 id="loading-data">Loading data</h3>
<p>Then comes the first method:</p>
<pre><code class="line-numbers language-csharp">protected override async Task OnInitializedAsync()
{
    msg = &quot;&quot;;
    try
    {
        users = await userService.GetUsers();
        TodoBasicDto todoData = await todoService.GetByIdAsync(Id);
        User currentlyAssigned = users.First(user =&gt; user.UserName.Equals(todoData.OwnerName));

        dto = new(Id)
        {
            Title = todoData.Title,
            OwnerId = currentlyAssigned.Id
        };
    }
    catch (Exception e)
    {
        Console.WriteLine(e);
        msg = e.Message;
    }
}
</code></pre>
<p><strong>Line 6</strong>: We load the users, so they can be displayed in a drop-down if the user wish to reassign a Todo.<br />
<strong>Line 7</strong>: Here the specific Todo is fetched, given the <code>Id</code>.<br />
<strong>Line 8</strong>: The <code>TodoBasicDto</code> contains only the user name, not the user id. So we need to find the User in the collection, given the user name. The Id is used in the TodoUpdateDto. We can do this, because the server ensures, the username is unique.<br />
<strong>Lines 10-14</strong>: The <code>dto</code> property is initialized to a new <code>TodoUpdateDto</code>, with the data from the fetched TodoBasicDto. We ignore the IsCompleted, because that is updated in the View Todos page.<br />
We will bind input fields in the View to the <code>dto</code>, so the input fields will initially have values matching the Todo we are about to edit.</p>
<p>Now all the data is loaded.</p>
<h3 id="updating-data">Updating data</h3>
<p>And finally the Update method. Once the user has modified the data as needed, they click a button, which will call this method:</p>
<pre><code class="line-numbers language-csharp">private async Task UpdateAsync()
{
    try
    {
        await todoService.UpdateAsync(dto);
        navMgr.NavigateTo(&quot;/ViewTodos&quot;);
    }
    catch (Exception e)
    {
        Console.WriteLine(e);
        msg = e.Message;
    }
}
</code></pre>
<p>We hand over the <code>dto</code> to the ITodoService, and then we navigate back to the View Todos page.</p>
<p>In the Add Todo page, we included some basic checks for the data not being null or empty. We might do the same here. I will leave that to the reader.</p>
<h2 id="the-view">The View</h2>
<p>The view will look pretty similar to the Add Todo page. The data which can be modified is the same as what was inserted when adding a Todo: Title and the User. So, we can steal much of the HTML to also make the page look similar.</p>
<p>We end up with this:</p>
<pre><code class="line-numbers language-razor">@page &quot;/EditTodo/{id:int}&quot;
@using Domain.DTOs
@using Domain.Models
@using HttpClients.ClientInterfaces
@using Microsoft.AspNetCore.Components
@inject ITodoService todoService
@inject IUserService userService
@inject NavigationManager navMgr

&lt;div class=&quot;card&quot;&gt;
    @if (users == null)
    {
        &lt;label&gt;Loading users...&lt;/label&gt;
    }
    else if (!users.Any())
    {
        &lt;label&gt;No users, you cannot create a Todo&lt;/label&gt;
    }
    else if (dto == null)
    {
        &lt;label&gt;Loading Todo data..&lt;/label&gt;
    }
    else
    {
        &lt;h3&gt;Update Todo&lt;/h3&gt;
        &lt;div class=&quot;form-group field&quot;&gt;
            &lt;label&gt;Title:&lt;/label&gt;
            &lt;input type=&quot;text&quot; @bind=&quot;dto.Title&quot;/&gt;
        &lt;/div&gt;
        &lt;div class=&quot;form-group field&quot;&gt;
            &lt;label&gt;Assignee:&lt;/label&gt;
            &lt;select @bind=&quot;dto.OwnerId&quot;&gt;
                &lt;option&gt;Choose&lt;/option&gt;
                @foreach (User user in users)
                {
                    &lt;option value=&quot;@user.Id&quot;&gt;@user.UserName&lt;/option&gt;
                }
            &lt;/select&gt;
        &lt;/div&gt;
        &lt;div class=&quot;button-row&quot;&gt;
            &lt;button @onclick=&quot;UpdateAsync&quot; class=&quot;acceptbtn&quot;&gt;Update&lt;/button&gt;
        &lt;/div&gt;
    }
    @if (!string.IsNullOrEmpty(msg))
    {
        &lt;label style=&quot;color: red&quot;&gt;@msg&lt;/label&gt;
    }
&lt;/div&gt;
</code></pre>
<p>We have the usual stuff at the top: page directive, using statements, injecting stuff.</p>
<p>We have the usual checks of things not being null or empty in the HTML, because we might get errors trying to render something from a <code>null</code>-variable, and if there is no data, the user should be informed.<br />
The <code>else</code> part is the interesting.</p>
<p>There is a text input field for the Title, with the data bound to the <code>dto.Title</code>. Notice here how we don't need a string field variable in the code block, like we did in the Add Todo. Often it is cleaner to bind data to the properties of a data object, like a DTO. This will potentially reduce the number of fields in the code block significantly, simplifying the code, and making it easier to reset things if needed, by just assigning the dto to a new instance.</p>
<p>We have also again the drop down menu of all the users.</p>
<p>Then there's the button, and finally the message for user feedback.</p>
<h2 id="styling">Styling</h2>
<p>If you moved the styles of CreateTodo.razor and CreateUser.razor to the global style sheet, the above HTML will reuse that, and all will be fine. Otherwise you may have to create a style-behind for this page.</p>
<h2 id="testing">Testing</h2>
<p>And that should be all for that feature. Sort of, almost. We still cannot navigate to the page from the URI.<br />
But you can access the page by manually typing in the URI in the browser's address bar. Let's try that.</p>
<p>Run Web API, and Blazor app.</p>
<p>Type in here:</p>
<p><img src="Resources/ManualNavigation.png" alt="img.png" /></p>
<p>Notice, your port may be different. And make sure to put a number which matches the ID of an existing Todo.</p>
<p>Modify some values, update the Title, and assign it to another User. Click the button, which will then take you to the View Todos page. Load the data to inspect your modified Todo.</p>

</div>
<div class="tab">
<hr/><h1 id="navigate-to-the-edit-todo-page">Navigate to the Edit Todo Page</h1><hr/>
<p>The testing was done by manually typing in the URI in the address bar of the browser. That is inconvenient for a user.</p>
<p>We will add a column to the table View Todos, with a button, which when clicked, will take you to the EditTodo page.</p>
<p><img src="Resources/LetsDoThis.png" alt="img.png" /></p>
<h2 id="icon">Icon</h2>
<p>We need a new icon to press. We will use this one:</p>
<p><img src="Resources/edit.gif" alt="" /></p>
<p>Download it like the funnel icons. Place it in the same folder: wwwroot/icons.</p>
<h2 id="the-view-first">The View First</h2>
<p>Open ViewTodos.razor. We will modify the table, here's the snippet part:</p>
<pre data-line="1,16,29-31"><code class="line-numbers language-razor">@inject NavigationManager navMgr


...


else
{
    &lt;table class=&quot;table&quot;&gt;
        &lt;thead&gt;
        &lt;tr&gt;
            &lt;th&gt;Todo ID&lt;/th&gt;
            &lt;th&gt;Owner ID&lt;/th&gt;
            &lt;th&gt;Title&lt;/th&gt;
            &lt;th&gt;Completed?&lt;/th&gt;
            &lt;th&gt;Edit&lt;/th&gt;
        &lt;/tr&gt;
        &lt;/thead&gt;
        &lt;tbody&gt;
        @foreach (var item in todos)
        {
            &lt;tr&gt;
                &lt;td&gt;@item.Id&lt;/td&gt;
                &lt;td&gt;@item.Owner.UserName&lt;/td&gt;
                &lt;td&gt;@item.Title&lt;/td&gt;
                &lt;td&gt;
                    &lt;FancyCheckBox IsCompleted=&quot;@item.IsCompleted&quot; OnChange=&quot;@((status) =&gt; CompleteTodo(item, status))&quot;/&gt;
                &lt;/td&gt;
                &lt;td&gt;
                    &lt;img src=&quot;icons/edit.gif&quot; class=&quot;funnel&quot; @onclick=&quot;@(() =&gt; navMgr.NavigateTo($&quot;/EditTodo/{item.Id}&quot;))&quot;/&gt;
                &lt;/td&gt;
            &lt;/tr&gt;
        }
        &lt;/tbody&gt;
    &lt;/table&gt;
}

...
</code></pre>
<p>Okay, we need a NavigationManager, so that is injected at the top of the page, along with the other inject statements.</p>
<p>Then we have the part of the view with the table definition. Notice the highlighted:</p>
<ul>
<li>There is a new column, defined by the new table header with &quot;Edit&quot;</li>
<li>And then the content of that column is defined in the new <code>&lt;td&gt;</code>. We insert an image, the source being our gif above. The style class is the same as the funnel-filter icons. That is just lazy, but it works for now. When the icon is clicked, we use the NavigationManager to navigate to the page EditTodo, and we add the ID of the Todo displayed in this row.</li>
</ul>
<h2 id="testing-testing-1-2-testing">Testing, Testing, 1, 2, Testing</h2>
<p>Let's do this.</p>
<p>Run the usual, navigate to View Todos. At the right there is a new column with the edit gifs. Click on one, and pay attention to the data of that row, it should now be displayed on the EditTodo page.</p>

</div>
<div class="tab">
<hr/><h1 id="delete-todo-feature-introduction">Delete Todo Feature Introduction</h1><hr/>
<p>Next up, we have our final user story:</p>
<blockquote>
<p>As a User I can delete a Todo, so that I can clean up</p>
</blockquote>
<p>We will do this by again modifying the View Todos page, adding a new column with a little delete icon to be clicked.</p>
<p><a href="">The code for this feature is found here</a></p>

</div>
<div class="tab">
<hr/><h1 id="delete-todo-in-the-todo-service">Delete Todo in the Todo Service</h1><hr/>
<p>We start with the client layer.</p>
<h2 id="the-interface">The Interface</h2>
<p>First we define the method in the ITodoService interface. It does not need to return anything, and the argument is just the id of the Todo, we want to delete.</p>
<p>Put this method in the interface:</p>
<pre><code class="line-numbers language-csharp">Task DeleteAsync(int id);
</code></pre>
<h2 id="the-implementation">The Implementation</h2>
<p>The we need the implementation of the method, in TodoHttpClient.</p>
<p>We already have a Delete endpoint in the TodosController. Implement the Delete method in TodoHttpClient yourself.</p>
<details>
<summary>hint</summary>
<pre><code class="line-numbers language-csharp">public async Task DeleteAsync(int id)
{
    HttpResponseMessage response = await client.DeleteAsync($&quot;Todos/{id}&quot;);
    if (!response.IsSuccessStatusCode)
    {
        string content = await response.Content.ReadAsStringAsync();
        throw new Exception(content);
    }
}
</code></pre>
</details>

</div>
<div class="tab">
<hr/><h1 id="delete-todo-view">Delete Todo View</h1><hr/>
<p>We need to add a new column with an icon.</p>
<h2 id="the-code-block">The Code Block</h2>
<p>We need a new method in the code block of the View Todos page.</p>
<p>I should take an ID, pass it to the Todo Service so that the Server can delete it.<br />
Then we also want to update the data in the view to reflect this deletion.</p>
<p>The method looks like this:</p>
<pre><code class="line-numbers language-csharp">private async Task RemoveTodo(int todoId)
{
    msg = &quot;&quot;;
    try
    {
        await todoService.DeleteAsync(todoId);
        
        var list = new List&lt;Todo&gt;(todos!);
        list.RemoveAll(todo =&gt; todo.Id == todoId);
        todos = list.AsEnumerable();
    }
    catch (Exception e)
    {
        Console.WriteLine(e);
        msg = e.Message;
    }
}
</code></pre>
<p>Line 6 makes the call to the Todo Service.<br />
Lines 8-10 removes the deleted Todo from the <code>todos</code> collection, which holds the data shown in the view. This variable is an IEnumerable, which cannot be modified. So:</p>
<ul>
<li>First convert the IEnumerable to a List</li>
<li>Then remove from the List</li>
<li>Then assign <code>todos</code> to be the List converted to an IEnumerable.</li>
</ul>
<p>It is a bit inconvenient. We could have made the TodoHttpClient::Get() method return an ICollection or IList instead, which might be easier to work with. But I don't want to go back and refactor that. The reader is welcome to use that approach instead.</p>
<p>Alternatively we could just call <code>LoadTodos()</code> again, to reload the todos from the server. This requires an extra call across the network, which may be resource heavy. It is the quick fix, but probably not the most efficient solution.</p>
<h2 id="the-view">The View</h2>
<p>Open again ViewTodos.razor. We must edit the table. We will add another column with an icon to click, when a Todo should be deleted.</p>
<p>The table part of the view is shown here:</p>
<pre data-line="13,29-33"><code class="line-numbers language-razor">...

else
{
    &lt;table class=&quot;table&quot;&gt;
        &lt;thead&gt;
        &lt;tr&gt;
            &lt;th&gt;Todo ID&lt;/th&gt;
            &lt;th&gt;Owner ID&lt;/th&gt;
            &lt;th&gt;Title&lt;/th&gt;
            &lt;th&gt;Completed?&lt;/th&gt;
            &lt;th&gt;Edit&lt;/th&gt;
            &lt;th&gt;Delete?&lt;/th&gt;
        &lt;/tr&gt;
        &lt;/thead&gt;
        &lt;tbody&gt;
        @foreach (var item in todos)
        {
            &lt;tr&gt;
                &lt;td&gt;@item.Id&lt;/td&gt;
                &lt;td&gt;@item.Owner.UserName&lt;/td&gt;
                &lt;td&gt;@item.Title&lt;/td&gt;
                &lt;td&gt;
                    &lt;FancyCheckBox IsCompleted=&quot;@item.IsCompleted&quot; OnChange=&quot;@((status) =&gt; CompleteTodo(item, status))&quot;/&gt;
                &lt;/td&gt;
                &lt;td&gt;
                    &lt;img src=&quot;icons/edit.gif&quot; class=&quot;funnel&quot; @onclick=&quot;@(() =&gt; navMgr.NavigateTo($&quot;/EditTodo/{item.Id}&quot;))&quot;/&gt;
                &lt;/td&gt;
                &lt;td&gt;
                    &lt;label @onclick=&quot;@(() =&gt; RemoveTodo(item.Id))&quot; style=&quot;cursor:pointer; color: red; font-weight: bold&quot;&gt;
                        &amp;#x2717;
                    &lt;/label&gt;
                &lt;/td&gt;
            &lt;/tr&gt;
        }
        &lt;/tbody&gt;
    &lt;/table&gt;
}

...
</code></pre>
<p>Notice the new table column in line 13. And in lines 29-33 we define the content of that column to be an icon, given by the code <code>&amp;#x2717;</code>, which is a red X:</p>
<p><img src="Resources/XIcon.png" alt="img.png" /></p>
<p>Obviously we could have used an actual icon file, like the funnels or the edit.</p>
<p>The <code>&lt;label&gt;</code> tag contains an <code>@onclick</code>-handler, i.e. a lambda expression to call the <code>RemoveTodo()</code> method defined above. I also have a bit of inline styling. You may move this to a css file, if you prefer. You probably have a style-behind for ViewTodos.razor.</p>
<h2 id="testing">Testing</h2>
<p>It is time to test the feature. Run the usual. Navigate to View Todos. Load all Todos.</p>
<p>First: Try to delete an un-completed Todo. The server should not allow you to. You should see the error message below the table.</p>
<p>Then: Delete a completed Todo. If you have none, then first complete a Todo. You should see the view be updated. To verify the deletion was saved on the server, navigate to a different page, and back, and reload the Todos.</p>

</div>
<div class="tab">
<hr/><h1 id="what-have-we-done-so-far">What Have We Done So Far?</h1><hr/>
<p>We started out with six user stories:</p>
<ol>
<li>As a user of the system I can add a new User, so that Todos can be assigned to Users.</li>
<li>As a User I can get a list of all existing Users, so that I can assign Todos to them</li>
<li>As a User I can add a new Todo, so that I can remember important things</li>
<li>As a User I can view all or filtered Todos, so that I can remember what to do</li>
<li>As a User I can complete a Todo, so that I can mark things as done</li>
<li>As a User I can delete a Todo, so that I can clean up</li>
</ol>
<p>We have now implemented these, along with an extra feature to edit a Todo.</p>
<p>We have seen how to define different views with pages.<br />
We have seen how to dynamically generate a view using HTML and razor syntax.<br />
We have used the HttpClient to make requests of the Web API.</p>
<p>And with this you're pretty well off to start your Blazor-WASM adventure.</p>
<p>But there are a bit more complexity to be explored with regards to blazor components. The next few slides will core more elaborate component usage.</p>

</div>
<div class="tab">
<hr/><h1 id="component-communication">Component Communication</h1><hr/>
<p>It has been mentioned before: Blazor is very modular when components are used. We have already done one component: the FancyChecBox, the purpose of which was to provide a re-usable UI element.</p>
<p>The re-usability is a big motivator for using components. Another factor is clarity of the code. HTML tends to get a bit incomprehensible when the code grows to many lines. Pieces of the HTML can be split out into smaller components to organize the HTML in a different way.</p>
<p>When using components, we often need to pass data from one to another. There are different ways of doing that.</p>
<h2 id="passing-data">Passing Data</h2>
<p>Depending on whether you have a page or a component, and also how pages/components are associated, passing data between them can follow various patterns. The purpose of this slide is to show the different ways of passing data back and forth between pages and components</p>
<h3 id="data-to-a-page">Data to a Page</h3>
<p>Whenever you navigate to a new page, sometimes we wish to provide data to that page, so that it can load and display the relevant data.</p>
<p>We have already seen an example of this: using a route parameter. This was covered in slide 30.</p>
<p>We can define a page URI which includes a single, simple parameter. Often just an int or a simple string. In that way it is somewhat similar to how we may define routes to endpoints in the Web API.</p>
<p>We must define the page-directive, and a public property to hold the data:</p>
<pre><code class="line-numbers language-razor">@page &quot;/EditTodo/{id}

@code {
    [Parameter]
    public string Id {get;set;}
}
</code></pre>
<p>By default, the property is a string, but as seen we can put a constraint on the route argument: <code>{id:int}</code>, which converts it to an int.</p>
<p>This is the primary way of passing data to a page.</p>
<p>There is sort of an alternative, which uses the observer pattern. This will be covered later.</p>
<h4 id="with-query-parameters">With Query Parameters</h4>
<p>Similar to what we can do with Web API endpoints and query parameters, we can do that for the URI of a blazor page.</p>
<p><a href="https://www.coderschmoder.com/five-ways-to-pass-data-from-one-blazor-component-to-another/">This post covers that under the section &quot;QUERYSTRING PARAMETERS&quot;</a></p>
<p>You put nothing extra in the page directive, but have a couple of properties marked with [Parameter] and [SupplyParameterFromQuery]. Here's an example:</p>
<pre><code class="line-numbers language-razor">@page &quot;/displayemployee&quot;
&lt;h3&gt;Display  Employee&lt;/h3&gt;
&lt;p&gt;Employee Id: @Id&lt;/p&gt;
&lt;p&gt;Department: @Department&lt;/p&gt;
&lt;p&gt;Employee First Name: @FName&lt;/p&gt;
&lt;p&gt;Employee Last Name: @LName&lt;/p&gt;
@code {
    [Parameter]
    [SupplyParameterFromQuery]
    public int? Id { get; set; }
    [Parameter]
    [SupplyParameterFromQuery]
    public int? Department { get; set; }
    [Parameter]
    [SupplyParameterFromQuery]
    public string? LName { get; set; }
    [Parameter]
    [SupplyParameterFromQuery]
    public string? FName { get; set; }
}
</code></pre>
<h3 id="data-to-a-child-component">Data to a Child Component</h3>
<p>When a component <code>CompA</code> is used inside a page (or other component) <code>PageB</code>,
the CompA is considered a &quot;child&quot; of the PageB, which is the &quot;parent&quot;.</p>
<p>Take this example (which I spent <em>way</em> too long time designing):</p>
<p><img src="Resources/ChildComponentImageExample.png" alt="img.png" /></p>
<p>There is a page displayed, with some text.
The &quot;cards&quot; (<a href="https://www.w3schools.com/howto/howto_css_cards.asp">a &quot;card&quot; is common concept</a>) each display some information about a student, and the profile-image. This card could be defined as a component, we would then generate a number of &quot;card-components&quot; equal to the number of students,
and provide each card-component with a <code>Student</code> object containing the student information.</p>
<p>It might look something like this:</p>
<pre><code class="line-numbers language-razor">@foreach(Student stud in students) {
    &lt;StudentCard Student=&quot;@stud&quot;/&gt;
}
</code></pre>
<p>Where the body of the for-loop is the component.</p>
<p>In this way a <em>parent</em> (whether it is a page or component) can pass data to a <em>child</em>.<br />
This is somewhat similar as passing arguments to a constructor of a class. Here, we can pass variables as arguments as well.</p>
<p>The <code>Student</code> property in the <code>StudentCard</code> component must be marked <code>[Parameter]</code>, e.g.:</p>
<pre><code class="line-numbers language-razor">&lt;div class=&quot;card&quot;&gt;
    &lt;img src=&quot;@Student.ImgUrl&quot;/&gt;
    &lt;p&gt;@Student.Description&lt;/p&gt;
&lt;/div&gt;

@code{
    [Parameter]
    public Student Student {get;set;}
}
</code></pre>
<p>We used this approach with the FancyCheckBox, where we passed in the initial boolean value of the check-box.</p>
<h3 id="data-to-a-parent-component">Data to a Parent Component</h3>
<p>Sometimes a child-component needs to pass data back to a parent-component (or -parent).
We do this using a delegate, more specifically the <code>EventCallback</code>. We did this in the in the FancyCheckBox. When the check-box was clicked, the EventCallback was invoked with the new value.</p>
<pre><code class="line-numbers language-razor">@code {
    [Parameter]
    public EventCallback&lt;bool&gt; OnChange { get; set; }
}
</code></pre>
<p>And subscribing a method to the EventCallback:</p>
<pre data-line="3"><code class="line-numbers language-razor">&lt;FancyCheckBox 
    IsCompleted=&quot;@item.IsCompleted&quot; 
    OnChange=&quot;@((status) =&gt; CompleteTodo(item, status))&quot;
/&gt;
</code></pre>
<p>We provide it with either a lambda-expression or a method reference.</p>
<h3 id="child-content">Child Content</h3>
<p>Sometimes, it is convenient to pass more than just data to a component. We can actually pass an entire snippet of HTML (with other components or razor-syntax).</p>
<p>Assume we make a Card component (like above), but it is intended to be reused for various types of cards across. It could be the students from the example above, but we might wish to use the same card for presenting other data. And maybe the card has some extra functionality, so that we cannot just achieve this with a <code>&lt;div class=&quot;card&quot;&gt;</code>.
Here are is the idea of the same card but with different content:</p>
<p><img src="Resources/DifferentCards.png" alt="img.png" /></p>
<p>Or, you can consider these slides, they behave similarly, have buttons at the top and bottom, but the content is different.</p>
<p>We can then define a component, which can receive the content as a kind of parameter. It might look like this:</p>
<pre><code class="line-numbers language-razor">&lt;MyFancyCard&gt;
    &lt;div class=&quot;student-card-content&gt;
        &lt;img src=..../&gt;
        &lt;p&gt;bla bla bla&lt;p&gt;
    &lt;/div&gt;
&lt;/MyFancyCard&gt;
</code></pre>
<p>The outer tag <code>&lt;MyFancyCard&gt;</code> is actually a component. The inner content, lines 2-5, is the &quot;child-content&quot;, i.e. the content we wish to display in the card.</p>
<p>The <code>MyFancyCard</code> component might then be defined as:</p>
<pre><code class="line-numbers language-razor">&lt;div class=&quot;fancy-card&quot;&gt;
    @ChildContent
&lt;/div&gt;

@code {
    [Parameter]
    public RenderFragment ChildContent {get;set;}
    
    ...
}
</code></pre>
<p>The property must be exactly like this, the type, and the name. This property will then receive the HTML from above, and we can put it in the view of the component with a reference, as in line 2.</p>
<p>We will use this on the next slide to create a popup dialog.</p>
<h3 id="data-to-a-sibling-component">Data to a Sibling Component</h3>
<p>Finally, you may have a page containing two (or more) components. So the page has two child-components, but the components do not know about each other, i.e. neither component is parent/child of the other: They are siblings.<br />
The web site design above show multiple cards, each card a component, all cards at the same level in the HTML, so they are siblings.</p>
<p>If you are industrious with regards to refactoring your page into smaller components, you may end up in this situation, where you click a button in one component, and you wish to update the view in another component.</p>
<p>To achieve this, we use a &quot;state container&quot;. It a simple class, which has a delegate and a piece of data. Then we need a set-method to set the data, which will also invoke the delegate. The components will subscribe their own methods to the delegate, and upon invocation will update their view accordingly.<br />
The state container must be registered as a <em>scoped service</em> in Program.cs, and injected into the components. Alternatively, when using Blazor WASM, a singleton pattern might also achieve this effect.</p>
<p>This could be an example of a state container:</p>
<pre><code class="line-numbers language-csharp">public class StateContainer{

    private int number = 0;
    public Action&lt;int&gt; OnChange {get;set;}
    
    public void SetNumber(int i){
        number = i;
        OnChange?.Invoke(number);
    }
}
</code></pre>
<p>The two components will interact with each other through this StateContainer:</p>
<p><img src="Resources/SetAndNotify.png" alt="img.png" /></p>
<p>I have the ambition of showing a very simple example at the end of this tutorial.</p>

</div>
<div class="tab">
<hr/><h1 id="creating-a-popup">Creating a Popup</h1><hr/>
<p>Currently whenever you have successfully added a Todo, you are just being navigated to the View Todos page. A user might be confused, because no success message was displayed first.</p>
<p>We are going to create a success message shown in a popup. The popup will be a component, and the content and functionality of the popup will be arguments to the component.</p>
<p>The purpose of this functionality is to show another way of passing data to a component.</p>

</div>



        
        <div style="overflow:auto; padding-bottom: 10px">
            <hr/>
            <div style="float:right;">
                <button type="button" id="prevBtn1" class="prev-button" onclick="nextPrev(-1)">Previous</button>
                <button type="button" id="nextBtn1" class="next-button" onclick="nextPrev(1)">Next&gt;</button>
            </div>
        </div>
        
    </div>
</div>
<script>
    showFirstOrSpecificTab();
</script>

</body>
</html>
