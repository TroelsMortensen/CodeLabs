<!DOCTYPE html>
<html>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link href="https://fonts.googleapis.com/css?family=Raleway" rel="stylesheet">
<link href="./../../Resources/Style.css" rel="stylesheet">
<link href="./../../Resources/prism.css" rel="stylesheet">
<script src="./../../Resources/TabNavigavtor.js"></script>
<link rel="shortcut icon" href="./../../Resources/CodeIcon.png">
<title>VIA Codelabs</title>
<body>
<script src="./../../Resources/prism.js"></script>

<div>
    <a href="./../../index.html" class="homelink">HOME</a>
</div>
<div style="display:flex;width:100%;height:100%;padding-top:64px">
    <div id="steps-list">
        <ol>
            <li class="step" onclick="setTab(0)">1 Introduction</li>
<li class="step" onclick="setTab(1)">2 Architecture</li>
<li class="step" onclick="setTab(2)">3 Components</li>
<li class="step" onclick="setTab(3)">4 Overall UI design</li>
<li class="step" onclick="setTab(4)">5 Fix CORS</li>
<li class="step" onclick="setTab(5)">6 Add user</li>
<li class="step" onclick="setTab(6)">7 Add User page</li>
<li class="step" onclick="setTab(7)">8 Add User Code</li>
<li class="step" onclick="setTab(8)">9 Add User View</li>
<li class="step" onclick="setTab(9)">10 Add User Test</li>
<li class="step" onclick="setTab(10)">11 Add User Styling</li>
<li class="step" onclick="setTab(11)">12 Add Page to NavMenu</li>
<li class="step" onclick="setTab(12)">13 View Users feature</li>
<li class="step" onclick="setTab(13)">14 View Users Service</li>
<li class="step" onclick="setTab(14)">15 View Users Code</li>
<li class="step" onclick="setTab(15)">16 View Users View</li>
<li class="step" onclick="setTab(16)">17 View Users Styling</li>
<li class="step" onclick="setTab(17)">18 Add Todo Feature</li>
<li class="step" onclick="setTab(18)">19 Add Todo Service</li>
<li class="step" onclick="setTab(19)">20 Add Todo Page</li>
<li class="step" onclick="setTab(20)">21 View Todos</li>
<li class="step" onclick="setTab(21)">22 View Todos Service</li>
<li class="step" onclick="setTab(22)">23 View Todos Page</li>
<li class="step" onclick="setTab(23)">24 View Todos Filtering</li>
<li class="step" onclick="setTab(24)">25 Component Intro</li>
<li class="step" onclick="setTab(25)">26 Checkbox Component</li>
<li class="step" onclick="setTab(26)">27 Use Checkbox</li>
<li class="step" onclick="setTab(27)">28 Edit Todo</li>
<li class="step" onclick="setTab(28)">29 GetTodoById</li>
<li class="step" onclick="setTab(29)">30 Edit Todo Page</li>
<li class="step" onclick="setTab(30)">31 Navigate To Edit</li>
<li class="step" onclick="setTab(31)">32 Delete Todo Feature</li>
<li class="step" onclick="setTab(32)">33 Delete Todo Service</li>
<li class="step" onclick="setTab(33)">34 Delete Todo View</li>
<li class="step" onclick="setTab(34)">35 Summation</li>
<li class="step" onclick="setTab(35)">36 Component Communication</li>
<li class="step" onclick="setTab(36)">37 Popup</li>
<li class="step" onclick="setTab(37)">38 Using the Popup</li>
<li class="step" onclick="setTab(38)">39 Edit Todo Popup</li>
<li class="step" onclick="setTab(39)">40 State Container Example</li>
<li class="step" onclick="setTab(40)">41 Conclusion</li>

        </ol>
    </div>
    <div id="container" action="/action_page.php">
        <div style="overflow:auto;">

            <div style="float:right; margin:10px">
                <button type="button" id="prevBtn" class="prev-button" onclick="nextPrev(-1)">Previous</button>
                <button type="button" id="nextBtn" class="next-button" onclick="nextPrev(1)">Next</button>
            </div>
        </div>

        <!-- One "tab" for each step in the form: -->

        <div class="tab">
<hr/><h1 id="introduction">Introduction</h1><hr/>
<hr/><h1 id="please-notice">Please notice!</h1><hr/>
<p>This guide was written with Blazor-WASM in mind.
However, I feel it is still easier to work with Blazor-Server.
The debugging and error messaging is better.</p>
<p>Therefore, I suggest you create a Blazor-Server project, instead of a Blazor-WASM. The difference will be tiny, and should have no effect in this tutorial.</p>
<hr/><h1 id="notice-over">Notice over</h1><hr/>
<p>This is the <em>second</em> part of a 3 part tutorial series.</p>
<p>You should already have the Todo Web API in place from the first part. We will continue working in the same Solution so as to reuse certain things.</p>
<p>This tutorial will cover the client side, i.e. making a Blazor WASM app.</p>
<h2 id="features">Features</h2>
<p>We already have the server-side of multiple features from part 1. We will now complete the client side of those features.</p>
<ol>
<li>As a user of the system I can add a new User, so that Todos can be assigned to Users.</li>
<li>As a User I can get a list of all existing Users, so that I can assign Todos to them</li>
<li>As a User I can add a new Todo, so that I can remember important things</li>
<li>As a User I can view all or filtered Todos, so that I can remember what to do</li>
<li>As a User I can complete a Todo, so that I can mark things as done</li>
<li>As a User I can delete a Todo, so that I can clean up</li>
</ol>
<h2 id="branches">Branches</h2>
<p>Again, each feature has its own branch on GitHub. Below is an overview:</p>
<ul>
<li><a href="https://github.com/TroelsMortensen/WasmTodo/tree/009_ClientSetup">009_ClientSetup</a> Here the initial setup of the Client components are done.</li>
<li><a href="https://github.com/TroelsMortensen/WasmTodo/tree/010_AddUser">010_AddUser</a>: Add a new User</li>
<li><a href="https://github.com/TroelsMortensen/WasmTodo/tree/011_ViewUsers">011_ViewUsers</a>: Show an overview of the registered Users</li>
<li><a href="https://github.com/TroelsMortensen/WasmTodo/tree/012_CreateTodo">012_CreateTodo</a>: Create a new Todo</li>
<li><a href="https://github.com/TroelsMortensen/WasmTodo/tree/013_ViewTodos">013_ViewTodos</a>: View all Todos</li>
<li><a href="https://github.com/TroelsMortensen/WasmTodo/tree/014_ViewTodosWithFilter">014_ViewTodosWithFilter</a>: Adding filtering functionality to the Todo overview</li>
<li><a href="https://github.com/TroelsMortensen/WasmTodo/tree/015_CheckBoxComponent">015_CheckBoxComponent</a>: Creating a check-box component</li>
<li><a href="https://github.com/TroelsMortensen/WasmTodo/tree/016_EditTodo">016_EditTodo</a>: Edit and existing Todo</li>
<li><a href="https://github.com/TroelsMortensen/WasmTodo/tree/017_DeleteTodo">017_DeleteTodo</a>: Delete an existing Todo</li>
<li><a href="https://github.com/TroelsMortensen/WasmTodo/tree/018_PopupSuccessMessage">018_PopupSuccessMessage</a>: Show a pop-up message</li>
<li><a href="https://github.com/TroelsMortensen/WasmTodo/tree/019_StateContainer">019_StateContainer</a>: Component to component communication</li>
</ul>
<h2 id="running-your-programs">Running your programs</h2>
<p>When you run your programs, either Web API or Blazor app, you <strong>do not use the &quot;IIS Express&quot; version</strong>. That requires extra setup, and I don't really know what it is about.</p>
<p><img src="Resources/RunningYourPrograms.png" alt="img.png" /></p>
<p>You can also just right-click your Web API or Blazor project, and run things from there, not worrying about ISS:</p>
<p><img src="Resources/RightClickToRun.png" alt="img.png" /></p>
<h3 id="tired-of-swagger-opening-all-the-time">Tired of Swagger opening all the time?</h3>
<p>Whenever you need to test something, you almost always need to start your Web API, and then Blazor. And your Web API will open a Swagger page.
If you get tired of this, you can go to WebAPI/Properties/launchSettings.json and modify the following line:</p>
<pre data-line="15"><code class="line-numbers language-json">{
  &quot;$schema&quot;: &quot;https://json.schemastore.org/launchsettings.json&quot;,
  &quot;iisSettings&quot;: {
    &quot;windowsAuthentication&quot;: false,
    &quot;anonymousAuthentication&quot;: true,
    &quot;iisExpress&quot;: {
      &quot;applicationUrl&quot;: &quot;http://localhost:21227&quot;,
      &quot;sslPort&quot;: 44331
    }
  },
  &quot;profiles&quot;: {
    &quot;WebAPI&quot;: {
      &quot;commandName&quot;: &quot;Project&quot;,
      &quot;dotnetRunMessages&quot;: true,
      &quot;launchBrowser&quot;: true,
      &quot;launchUrl&quot;: &quot;swagger&quot;,
      &quot;applicationUrl&quot;: &quot;https://localhost:7093;http://localhost:5093&quot;,
      &quot;environmentVariables&quot;: {
        &quot;ASPNETCORE_ENVIRONMENT&quot;: &quot;Development&quot;
      }
    },
    &quot;IIS Express&quot;: {
      &quot;commandName&quot;: &quot;IISExpress&quot;,
      &quot;launchBrowser&quot;: true,
      &quot;launchUrl&quot;: &quot;swagger&quot;,
      &quot;environmentVariables&quot;: {
        &quot;ASPNETCORE_ENVIRONMENT&quot;: &quot;Development&quot;
      }
    }
  }
}
</code></pre>
<p>&quot;launchBrowser: true&quot;. Change this to false, and the browser will not launch.</p>
<p>You can do the same for the Blazor app.
In the console in Rider you can also click on the link with https to open a window.<br />
Whenever you restart the app, you can then just hard refresh the browser with <kbd>ctrl</kbd>+<kbd>F5</kbd>. This usually works.</p>

</div>
<div class="tab">
<hr/><h1 id="architecture">Architecture</h1><hr/>
<p>In the previous tutorial, we applied a clean-like approach to the server.
It does not make sense to do the same on the client side, as it has a different purpose, and is better built in a slightly different approach.</p>
<p>We will have two layers, one of which may be considered two in it-self.</p>
<p>This is the plan:</p>
<p><img src="Resources/ClientArchitecture.png" alt="img.png" /></p>
<p>The &quot;UI&quot; layer is a Blazor WASM app, and the &quot;Clients&quot; layer is a library with classes, which can make HTTP requests to the Web API.</p>
<p>The &quot;UI&quot; layer has a &quot;sub-layer&quot; marked &quot;View models&quot;. That is because they are often tightly intertwined with the UI. I.e. the View models are not a separate layer or component.</p>
<p>Now, we will need at least two new components: one per layer. That leaves the interfaces, where to put them?<br />
Sometimes you might see people put them in their own component, e.g. called Contracts. However, in our case that might be a bit excessive.</p>
<p>We will revisit the consideration from the clean approach, giving the following discussion:</p>
<p>Put the interfaces in the component least likely to be swapped out. In this case here, the Clients are swapped out, if we changed network technology, i.e. we move from REST to e.g. gRPC or GraphQL or something else.<br />
The UI layer may be swapped out, if we don't like Blazor-WASM.</p>
<p>If the interfaces were put in Clients, it would be easier to reuse that component if we were to add other types of client apps: desktop or mobile apps.</p>
<p>When starting the app, we will have to register client services, to be injected into the Blazor pages.
This means the UI component must depend on the Clients component.
If the interfaces are located in the UI, then the Clients component must depend on the UI, to implement the interfaces.
This causes an impossible bidirectional dependency.</p>
<p>So, we cannot put the interfaces in the UI.
They must go into the Clients, or into a separate component.
The latter is perhaps more flexible, if we expect to add other client apps, but we don't.
We will keep it simple, and put the interfaces in Clients.</p>
<p>This leads to the component/package diagram.</p>
<h2 id="component-diagram">Component Diagram</h2>
<p>Below is a component diagram of the Client app, with important directories included.</p>
<p><img src="Resources/ClientComponentDiagram.png" alt="img.png" /></p>
<p>Each grey container is a component/project. The Domain already exists in your solution, it was created in part 1 of the Tutorial.</p>
<p>The light blue containers are directories. Not all directories are shown, just the most important ones.</p>
<h2 id="class-diagram">Class Diagram</h2>
<p>The final system is displayed in the below class diagram.</p>
<p>You may notice, I have forgotten to suffix some methods with async, e.g. in <code>IUserService</code>, and several pages. It is super important to fix, so that will not happen. That a method is asynchronous is also implied by the return type of Task.</p>
<p>The Domain component already exists, we created this in the previous tutorial. But I include it here as well, because the Client app also uses it: It is a shared library.</p>
<p><img src="Resources/ClassDiagram.svg" alt="" /></p>

</div>
<div class="tab">
<hr/><h1 id="creating-components">Creating Components</h1><hr/>
<p>It's time to create the two new components in your existing Solution.</p>
<h3 id="blazor-project">Blazor project</h3>
<p>Start with a new Blazor WASM project:</p>
<p><img src="Resources/CreateBlazorProject.gif" alt="" /></p>
<h3 id="clients-project">Clients project</h3>
<p>Then create a new Class Library, I have called mine HttpClients.</p>
<p>Delete the class &quot;Class1.cs&quot;.</p>
<h3 id="dependencies">Dependencies</h3>
<p>Make inter-component dependencies as follows:</p>
<ul>
<li>HttpClients -&gt; Domain</li>
<li>BlazorWASM -&gt; HttpClients</li>
</ul>
<p>Now, like last time, this gives us a transitive dependency: BlazorWASM -&gt; HttpClients -&gt; Domain, meaning that the Blazor component has access to everything in the Domain component.</p>
<p>That should be all for setting up. We are ready for the first feature.</p>

</div>
<div class="tab">
<hr/><h1 id="ui-design">UI design</h1><hr/>
<p>We will not rework the UI very much for this tutorial. This means we will keep the left side navigation menu, and just add a few more menu items to it, as necessary.</p>
<p>Should a more elaborate rework be desired, the basic setup is found in BlazorWASM/Shared/MainLayout.razor</p>
<p>Out of the box, it looks like this:</p>
<pre><code class="line-numbers language-razor">@inherits LayoutComponentBase

&lt;div class=&quot;page&quot;&gt;
    &lt;div class=&quot;sidebar&quot;&gt;
        &lt;NavMenu/&gt;
    &lt;/div&gt;

    &lt;main&gt;
        &lt;div class=&quot;top-row px-4&quot;&gt;
            &lt;a href=&quot;https://docs.microsoft.com/aspnet/&quot; target=&quot;_blank&quot;&gt;About&lt;/a&gt;
        &lt;/div&gt;

        &lt;article class=&quot;content px-4&quot;&gt;
            @Body
        &lt;/article&gt;
    &lt;/main&gt;
&lt;/div&gt;
</code></pre>
<p>Most is just standard HTML, you should recognize this.</p>
<p>You may notice the <code>&lt;NavMenu/&gt;</code> in line 5, which is the component (not project component, but Blazor component which is a piece of UI) that contains the HTML and code for the left side navigation menu.
If you remove this line, the navigation menu disappears.</p>
<p>Also notice the</p>
<pre><code class="line-numbers language-razor">&lt;div class=&quot;top-row px-4&quot;&gt;
    &lt;a href=&quot;https://docs.microsoft.com/aspnet/&quot; target=&quot;_blank&quot;&gt;About&lt;/a&gt;
&lt;/div&gt;
</code></pre>
<p>This is the top bar, always present. You can modify, or remove this. Some pages have navigation menus in the top panel instead of the side.</p>
<p>Actually, the only thing of the view, you cannot remove, is the <code>@Body</code>. This variable is extremely important:<br />
Whenever you open a new page, the content of the page will be inserted at this variable. If the variable is gone, nothing will be displayed.</p>
<p>So, if you want a very different layout of your app, this file is where to change the overall structure.</p>
<p>As mentioned, in this tutorial, we will not do any rework.</p>

</div>
<div class="tab">
<hr/><h1 id="adding-access-to-the-web-api">Adding access to the Web API</h1><hr/>
<p>Currently, your Web API does not have &quot;Cross Origin Resource Sharing&quot; enabled, which prevents your Blazor app from accessing the API.</p>
<p>In your WebAPI/Program.cs add the following:</p>
<pre><code class="line-numbers language-csharp">app.UseCors(x =&gt; x
    .AllowAnyMethod()
    .AllowAnyHeader()
    .SetIsOriginAllowed(origin =&gt; true) // allow any origin
    .AllowCredentials());
</code></pre>
<p>It must be after the app variable is defined, <a href="https://github.com/TroelsMortensen/WasmTodo/blob/010_AddUser/WebAPI/Program.cs">see here</a>, probably lines 26-30.</p>
<p>If you wish to know more about CORS, <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS">read here</a>. For this course, it is just something we enable, without caring too much about it. It is a security measure, which we are disabling.</p>
<h2 id="setting-base-address-of-httpclient">Setting base address of HttpClient</h2>
<p>If we open BlazorWASM/Program.cs, we will find that an HttpClient is added as a scoped service, and the base address is set to be the address of the host environment, i.e. the localhost.</p>
<p>The host address is that of your Blazor WASM app. However, we need to contact the Web API, which has a different address.<br />
Run your Web API to see in the console which https address it is listening on. Or look in the launchSettings.json, mentioned on slide 1.</p>
<p>Copy this address into the object initializer, like this:</p>
<pre data-line="4"><code class="line-numbers language-csharp">builder.Services.AddScoped(
    sp =&gt; 
        new HttpClient { 
            BaseAddress = new Uri(&quot;https://localhost:7093&quot;) 
        }
);
</code></pre>

</div>
<div class="tab">
<hr/><h1 id="adding-new-users">Adding New Users</h1><hr/>
<p>We will implement the client side of the features in the same order as on the server (that's the current plan, at least).</p>
<p>This means we start here:</p>
<blockquote>
<p>As a user of the system I can add a new User, so that Todos can be assigned to Users.</p>
</blockquote>
<h2 id="interface">Interface</h2>
<p>Whether we start developing the feature with the HttpClient layer or the UI layer, they both depend on the interface in between. So, let's start there.</p>
<p>In HttpClients component, create a new directory: &quot;ClientInterfaces&quot;.</p>
<p>Inside this directory, create a new interface: &quot;IUserService&quot;.</p>
<p>We already have a DTO for creating Users, used on the server side: <code>UserCreationDto</code>.
Let us use this as the argument, and the return type will be the resulting User.  We get a User back from the endpoint, so this seems fitting.</p>
<p>This results in the method:</p>
<pre><code class="line-numbers language-csharp">Task&lt;User&gt; Create(UserCreationDto dto);
</code></pre>
<p>Add the method to the interface, fix import errors.</p>
<p>We will do the implementation next, and finally the UI.</p>
<h2 id="the-implementation">The Implementation</h2>
<p>Inside HttpClients component, create a new directory to house the implementations. Call the directory: &quot;Implementations&quot;.</p>
<p>We need a new class here: &quot;UserHttpClient&quot;. It should implement the interface from above. Initially the class looks like this:</p>
<pre><code class="line-numbers language-csharp">public class UserHttpClient : IUserService
{
    private readonly HttpClient client;

    public UserHttpClient(HttpClient client)
    {
        this.client = client;
    }

    public Task&lt;User&gt; Create(UserCreationDto dto)
    {
        throw new NotImplementedException();
    }
}
</code></pre>
<p>We request an HttpClient through the constructor, thereby leaving the creation of the HttpClient up to the Blazor framework. This is best practice, and will improve longtime performance of your app.</p>
<p>If you are curious, <a href="https://www.youtube.com/watch?v=Z6Y2adsMnAA">Nick Chapsas has an elaborate video about performance</a>.</p>
<h4 id="the-method">The method</h4>
<p>First, add <code>async</code> to the method signature, otherwise we cannot await anything in the method body. Then let's do the method body. It looks like this:</p>
<pre><code class="line-numbers language-csharp">public async Task&lt;User&gt; Create(UserCreationDto dto)
{
    HttpResponseMessage response = await client.PostAsJsonAsync(&quot;/users&quot;, dto);
    string result = await response.Content.ReadAsStringAsync();
    if (!response.IsSuccessStatusCode)
    {
        throw new Exception(result);
    }

    User user = JsonSerializer.Deserialize&lt;User&gt;(result, new JsonSerializerOptions
    {
        PropertyNameCaseInsensitive = true
    })!;
    return user;
}
</code></pre>
<p>We use the client to make a POST request to &quot;/users&quot;, sending the dto. The dto will be serialized to JSON, and wrapped in an appropriate StringContent object.</p>
<p>Now, &quot;/users&quot; is generally not enough. We know the URI should be &quot;https://localhost:7093/Users&quot;. However, on the HttpClient you can set a &quot;base url&quot;, which is the first part, and we then only need to provide the part of the URI after the port. This base URL was set in Program.cs, in slide 5.</p>
<p>Every request returns a response, whether we actually expect an object back or not.
We know that this endpoint will either return an error message, or the created User.
So, we read the content of the response.<br />
If the response is not a success code, i.e. an error code in the 400 or 500 range,
we know the result content is the error message, and an exception is thrown with that message.<br />
The exception can then be caught in the page and a message can be shown to the user of the app.</p>
<p>It is <em>always</em> important to give feedback to the user, in both sunny or rainy scenarios. If there is no feedback, they might try again, and create two users, or they may not be aware that the user was not created. User feeback is <em><strong>important</strong></em>.</p>
<p>If the status code is success, in this case we expect a &quot;201 Created&quot;, we know the result is a User as JSON, and it is deserialized and returned.<br />
We supply the <code>JsonSerializer</code> with options to ignore casing, because the result from the Web API will be camelCase, but our model classes use PascalCase for the properties.<br />
At the end of the call, line 13, there is a null-suppressor: &quot;!&quot;, i.e. the exclamation mark. This is because, the Deserialize method returns a nullable object, i.e. <code>User?</code>, but we just above checked if the request went well, so at this point we know <em>there is</em> a User to be deserialized.</p>
<p>Most of our client methods will have a very similar structure.</p>
<h2 id="register-as-service">Register as service</h2>
<p>We will register the UserHttpClient as a service in <code>Program.cs</code>, so that the dependency framework can inject an instance into our pages, when needed.</p>
<p>Open BlazorWASM/Program.cs. Put in the line:</p>
<pre><code class="line-numbers language-csharp">builder.Services.AddScoped&lt;IUserService, UserHttpClient&gt;();
</code></pre>
<p>Next up, let's do the page.</p>

</div>
<div class="tab">
<hr/><h1 id="add-user-page">Add User Page</h1><hr/>
<p>The Pages directory in your BlazorWASM project will house all Blazor components/pages. You may create sub-directories, if needed, but otherwise I recommend putting all blazor components in here.</p>
<h2 id="create-page">Create Page</h2>
<p>In the Pages folder, create a new Blazor component, call it &quot;CreateUser&quot;:</p>
<p><img src="Resources/AddBlazorComponent.png" alt="img.png" /></p>
<p>And then:</p>
<p><img src="Resources/CreateBlazorComponent.png" alt="img.png" /></p>
<p>If you make a Component instead of a Page, it can still be fixed. The only difference is that Pages come with the @page directive at the top:</p>
<pre><code>@page &quot;/CreateUser&quot;
</code></pre>
<p>If you created a component, this is not there, but can just be added.</p>
<p>You should now have this content in your page:</p>
<pre><code class="line-numbers language-razor">@page &quot;/CreateUser&quot;
&lt;h3&gt;CreateUser&lt;/h3&gt;

@code {
    
}
</code></pre>

</div>
<div class="tab">
<hr/><h1 id="the-code">The Code</h1><hr/>
<p>Let's start with the code block, i.e. what will essentially be your view-model. My style is typically to have the code block inside the page, as shown below. But if you prefer to do code-behinds, you're welcome to do that.</p>
<p>We need to hold the data, that the user inputs. And we need a method to send that data to the UserService.</p>
<p>It looks like this:</p>
<pre><code class="line-numbers language-csharp">@code {
    private string username = &quot;&quot;;
    private string resultMsg = &quot;&quot;;
    private string color = &quot;&quot;;
    
    private async Task Create()
    {
        resultMsg = &quot;&quot;;

        try
        {
            await userService.Create(new UserCreationDto(username));
            username = &quot;&quot;;
            resultMsg = &quot;User successfully created&quot;;
            color = &quot;green&quot;;
        }
        catch (Exception e)
        {
            Console.WriteLine(e);
            resultMsg = e.Message;
            color = &quot;red&quot;;
        }
    }
}
</code></pre>
<p>Three field variables. The <code>resultMsg</code> is to hold any messages, we wish to display to the user. Maybe something fails on the server side, e.g. the user name was already taken. We wish to display that information to the user. Remember, feedback is important.<br />
The <code>color</code> is to set the color of the resultMsg in the view, shown on the next slide.</p>
<p>The <code>Create()</code> method does very little. We reset the <code>resultMsg</code> first. Then a call to the <code>IUserService</code> with a new UserCreationDto containing the user name.</p>
<p>If something goes wrong, we catch any potential exceptions, and display their message, by assigning the exception message to the <code>resultMsg</code> variable, which causes an update to a field variable used in the view, which will then be re-rendered.</p>

</div>
<div class="tab">
<hr/><h1 id="the-view">The View</h1><hr/>
<p>Next up, the view definition.</p>
<p>As a minimum we need an input field, so that the user can input the wanted user name.<br />
We also need a button, which when clicked, will call the <code>Create()</code> method.<br />
And then we need a way to display messages held in the <code>resultMsg</code>.</p>
<p>I have added a little extra, which will be explained, and then the view looks like this:</p>
<pre><code class="line-numbers language-razor">@page &quot;/CreateUser&quot;
@using Domain.DTOs
@using HttpClients.ClientInterfaces
@inject IUserService userService;

&lt;div class=&quot;card&quot;&gt;
    &lt;h3&gt;Create User&lt;/h3&gt;
    &lt;div class=&quot;form-group field&quot;&gt;
        &lt;label&gt;User name:&lt;/label&gt;
        &lt;input type=&quot;text&quot; @bind=&quot;username&quot; @bind:event=&quot;oninput&quot;/&gt;
        @if (!string.IsNullOrEmpty(resultMsg))
        {
            &lt;label style=&quot;color: @color&quot;&gt;@resultMsg&lt;/label&gt;
        }
    &lt;/div&gt;
    &lt;div class=&quot;button-row&quot;&gt;
        &lt;button @onclick=&quot;Create&quot; disabled=&quot;@(string.IsNullOrEmpty(username))&quot; class=&quot;acceptbtn&quot;&gt;Create&lt;/button&gt;
    &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p><strong>Line 1</strong>: This is the page directive. It defines the sub-uri to access this specific page.<br />
<strong>Line 2-3</strong>: Importing various namespaces.<br />
<strong>Line 4</strong>: Here we inject an instance of <code>IUserService</code>.
This instance is created and provided by the dependency injection framework, and we can do this, when we have registered the interface and implementing class as services in Program.cs, as we did the previous slide.<br />
We hereby achieve dependency inversion, and if we were to change the network technology, the idea is, we shouldn't have to rework any of our pages, because they just know about the interface.<br />
However, because we decided to put the interfaces into the HttpClients component, we would still have to modify all pages, if we changed network technology. A new network implementation would most likely be placed in a different namespace.<br />
Notice the using statement in line 3, this references the namespace HttpClients. We have chosen to accept this flaw, as we will not change network technology. Remember the discussion on slide 2 on where to put the interfaces.</p>
<p>But, this page does not know about the implementation behind the interface.</p>
<p>Then comes a mix of HTML and razor-syntax, i.e. inlined C#.<br />
First there is a containing <code>&lt;div&gt;</code> in line 6. We will add some styling later to setup the page a little nicer.</p>
<p>The first interesting thing comes in <strong>line 10</strong>. This is a text input field:</p>
<pre><code class="line-numbers language-razor">&lt;input type=&quot;text&quot; @bind=&quot;username&quot; @bind:event=&quot;oninput&quot;/&gt;
</code></pre>
<p>We have two &quot;@-attributes&quot;. The first one says that the value of the text field should be stored in the field variable <code>username</code>. The binding is two-way: if the field variable is changed from the code, the view will update to show this value.</p>
<p>The second <code>@</code> is then the type of event, which should cause the value of the input field to be put into the field variable.
We want it to be &quot;oninput&quot;, i.e. each key press will cause an update to the value of the field variable.<br />
The default is &quot;onchange&quot;, which will cause the update when you de-focus the text input, i.e. click somewhere outside of it. If we just want the default onchange we can leave out the second <code>@bind:eve...</code>.<br />
We want the &quot;oninput&quot;, because the button should be  disabled, when there is nothing in the input field.</p>
<p><strong>Line 11-14</strong>: This is a code snippet, started with the <code>@</code> to indicate some razor-syntax follows, which should be evaluated when generating the html.<br />
We check if there is anything in the <code>resultMsg</code> field, and if so, we display a <code>&lt;label&gt;</code> with whatever error message should be shown. If the <code>resultMsg</code> is empty, the HTML inside the if-statement is not rendered.</p>
<p><strong>Line 17</strong>: Here we have the button to be pressed when creating a user:</p>
<pre><code class="line-numbers language-csharp">&lt;button @onclick=&quot;Create&quot; disabled=&quot;@(string.IsNullOrEmpty(username))&quot; class=&quot;acceptbtn&quot;&gt;Create&lt;/button&gt;
</code></pre>
<p>We specify the method to be called when the button is clicked with <code>@onclick=&quot;Create&quot;</code>. We could also here provide a lambda expression instead of the method name.<br />
Then the <code>disabled=</code> is a standard HTML attribute, the value of which must be &quot;true&quot; or &quot;false&quot;.
Here we evaluate the state with <code>@(string.IsNullOrEmpty(username))</code>, the @ indicating razor-syntax to be avaluated when rendered. We check if the <code>username</code> has a value. If there is no value, it doesn't make sense to be able to click the button, so it will be disabled.</p>
<h2 id="mouse-events">Mouse events</h2>
<p>To the button we have added an <code>@onclick</code> event, and assigned a method to be called, when the button is clicked.</p>
<p>We can do the same for just about any HTML element. We will later put a similar <code>@onclick</code> event handler on an image, slide 24.</p>
<p>There are a number of different event types, e.g.:</p>
<ul>
<li>onclick</li>
<li>onmousedown</li>
<li>onmouseup</li>
<li>onmouseover</li>
<li>ondrag</li>
</ul>
<p>and many more. <a href="https://learn.microsoft.com/en-us/aspnet/core/blazor/components/event-handling?view=aspnetcore-6.0">See a list here</a></p>

</div>
<div class="tab">
<hr/><h1 id="test">Test</h1><hr/>
<p>We should now have the functionality in place. We will add a bit of styling later, but let's test it first.</p>
<p>Run first your Web API. You can just close the Swagger page, which opens.</p>
<p>Run then the BlazorWASM. It should open a new tab in your browser.</p>
<p>In the address bar put &quot;https://localhost:7205/CreateUser&quot; to navigate to the page, we have just worked on (your port may be different).</p>
<p>You should then see your page:</p>
<p><img src="Resources/CreateUserPageView.png" alt="img.png" /></p>
<p>Type in something in the text-field and see how the button becomes enabled.</p>
<p>Try first a user name, you know exists. We should see an error message.</p>
<p>Then try a new user name, non-existing. This should work, and you should see a green success message.<br />
If you have no users, do the above in reverse order.</p>

</div>
<div class="tab">
<hr/><h1 id="adding-styling-to-create-user-page">Adding Styling to Create User Page</h1><hr/>
<p>Now that the functionality works, we can beautify it just a little bit. This is not a course in HTML and CSS, but we will still look at an example of how to apply it.</p>
<p>Remember, we have two approaches to styling:</p>
<ul>
<li>App wide css is defined in a file in the wwwroot/css. You can have multiple style-sheets in here, and they are made available app wide by importing them in the wwwroot/index.html file.</li>
<li>Component scoped styling, i.e. a style-sheet only available to a single component.</li>
</ul>
<p>We will use the latter, and create a &quot;style-behind&quot;.</p>
<p>Right click Pages directory, add a new style sheet. The name must be that of the component appended with &quot;.css&quot;, in our case that will be &quot;CreateUser.razor.css&quot;.</p>
<p>If done correctly, you should now see a style sheet nested under your razor component file:</p>
<p><img src="Resources/CreateUserStyleBehind.png" alt="img.png" /></p>
<p>Input the following into the .css file:</p>
<pre><code class="line-numbers language-css">.card {
    box-shadow: 0 4px 8px 0 rgba(0,0,0,0.2);
    transition: 0.3s;
    width: 250px;
    padding: 25px;
    text-align: center;
    margin: auto;
    margin-top: 50px;
    border-radius: 15px;
}

.field {
    margin-top: 20px;
}

.acceptbtn {
    background-color:lightgreen;
    border-radius: 5px;
    padding: 5px;
    padding-left: 10px;
    padding-right: 10px;
}

.button-row{
    margin-top: 15px;
}
</code></pre>
<p>I will not go through the CSS, but the result should look like this:</p>
<p><img src="Resources/CreateUserPageWithStyling.png" alt="img.png" /></p>
<p>The functionality remains the same.</p>
<p>Now, we may wish all &quot;accept&quot;-type buttons to have the same style, in which case, we should move that style-class to the app wide style-sheets. Or we could make the button a separate component. We might come back to this</p>

</div>
<div class="tab">
<hr/><h1 id="adding-a-navigation-menu-item">Adding a Navigation Menu Item</h1><hr/>
<p>Currently, we have had to manually input the URI into the browser address bar. We need another item in the navigation menu.</p>
<p>Open BlazorWASM/Shared/NavMenu.razor.</p>
<p>Find this part in the file (ca lines 10 to 28):</p>
<pre data-line="3-7"><code class="line-numbers language-razor">&lt;div class=&quot;@NavMenuCssClass&quot; @onclick=&quot;ToggleNavMenu&quot;&gt;
    &lt;nav class=&quot;flex-column&quot;&gt;
        &lt;div class=&quot;nav-item px-3&quot;&gt;
            &lt;NavLink class=&quot;nav-link&quot; href=&quot;&quot; Match=&quot;NavLinkMatch.All&quot;&gt;
                &lt;span class=&quot;oi oi-home&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt; Home
            &lt;/NavLink&gt;
        &lt;/div&gt;
        &lt;div class=&quot;nav-item px-3&quot;&gt;
            &lt;NavLink class=&quot;nav-link&quot; href=&quot;counter&quot;&gt;
                &lt;span class=&quot;oi oi-plus&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt; Counter
            &lt;/NavLink&gt;
        &lt;/div&gt;
        &lt;div class=&quot;nav-item px-3&quot;&gt;
            &lt;NavLink class=&quot;nav-link&quot; href=&quot;fetchdata&quot;&gt;
                &lt;span class=&quot;oi oi-list-rich&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt; Fetch data
            &lt;/NavLink&gt;
        &lt;/div&gt;
    &lt;/nav&gt;
&lt;/div&gt;
</code></pre>
<p>Here we have the three nav menu items, e.g. lines 3-7 defines a single nav menu item, the home button:</p>
<p><img src="Resources/NavMenuItemHome.png" alt="" /></p>
<p>We can just copy the div and nested content and adjust a little bit. Make it like this:</p>
<pre data-line="18-22"><code class="line-numbers language-razor">&lt;div class=&quot;@NavMenuCssClass&quot; @onclick=&quot;ToggleNavMenu&quot;&gt;
    &lt;nav class=&quot;flex-column&quot;&gt;
        &lt;div class=&quot;nav-item px-3&quot;&gt;
            &lt;NavLink class=&quot;nav-link&quot; href=&quot;&quot; Match=&quot;NavLinkMatch.All&quot;&gt;
                &lt;span class=&quot;oi oi-home&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt; Home
            &lt;/NavLink&gt;
        &lt;/div&gt;
        &lt;div class=&quot;nav-item px-3&quot;&gt;
            &lt;NavLink class=&quot;nav-link&quot; href=&quot;counter&quot;&gt;
                &lt;span class=&quot;oi oi-plus&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt; Counter
            &lt;/NavLink&gt;
        &lt;/div&gt;
        &lt;div class=&quot;nav-item px-3&quot;&gt;
            &lt;NavLink class=&quot;nav-link&quot; href=&quot;fetchdata&quot;&gt;
                &lt;span class=&quot;oi oi-list-rich&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt; Fetch data
            &lt;/NavLink&gt;
        &lt;/div&gt;
        &lt;div class=&quot;nav-item px-3&quot;&gt;
            &lt;NavLink class=&quot;nav-link&quot; href=&quot;CreateUser&quot;&gt;
                &lt;span class=&quot;oi oi-plus&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt; Create user
            &lt;/NavLink&gt;
        &lt;/div&gt;
    &lt;/nav&gt;
&lt;/div&gt;
</code></pre>
<p>The <code>href=..</code> in line 19 says which page to open, it should match the sub-URI in your page directive in the CreateUser.razor file.</p>
<h2 id="cleaning-up">Cleaning up</h2>
<p>Initially, there are two demo pages: Counter and Fetch Data. We might as well delete them and remove the links.</p>
<p>Remove the following from NavMenu:</p>
<pre data-line="8-17"><code class="line-numbers language-razor">&lt;div class=&quot;@NavMenuCssClass&quot; @onclick=&quot;ToggleNavMenu&quot;&gt;
    &lt;nav class=&quot;flex-column&quot;&gt;
        &lt;div class=&quot;nav-item px-3&quot;&gt;
            &lt;NavLink class=&quot;nav-link&quot; href=&quot;&quot; Match=&quot;NavLinkMatch.All&quot;&gt;
                &lt;span class=&quot;oi oi-home&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt; Home
            &lt;/NavLink&gt;
        &lt;/div&gt;
        &lt;div class=&quot;nav-item px-3&quot;&gt;
            &lt;NavLink class=&quot;nav-link&quot; href=&quot;counter&quot;&gt;
                &lt;span class=&quot;oi oi-plus&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt; Counter
            &lt;/NavLink&gt;
        &lt;/div&gt;
        &lt;div class=&quot;nav-item px-3&quot;&gt;
            &lt;NavLink class=&quot;nav-link&quot; href=&quot;fetchdata&quot;&gt;
                &lt;span class=&quot;oi oi-list-rich&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt; Fetch data
            &lt;/NavLink&gt;
        &lt;/div&gt;
        &lt;div class=&quot;nav-item px-3&quot;&gt;
            &lt;NavLink class=&quot;nav-link&quot; href=&quot;CreateUser&quot;&gt;
                &lt;span class=&quot;oi oi-plus&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt; Create user
            &lt;/NavLink&gt;
        &lt;/div&gt;
        &lt;div class=&quot;nav-item px-3&quot;&gt;
            &lt;NavLink class=&quot;nav-link&quot; href=&quot;ViewUsers&quot;&gt;
                &lt;span class=&quot;oi oi-list&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt; View users
            &lt;/NavLink&gt;
        &lt;/div&gt;
    &lt;/nav&gt;
&lt;/div&gt;
</code></pre>
<p>Those are the two links to Counter and Fetch data, respectively.</p>
<p>Now, you can also delete the two files, Counter.razor and FetchData.razor, from the Pages directory.</p>
<p>Let us leave the Index.razor, so we have some kind of home page.</p>
<h3 id="section"></h3>
<p>Verify everthing still works, and that you now have your new nav-item in the left side menu. You don't need to run the Web API for this.</p>

</div>
<div class="tab">
<hr/><h1 id="view-users">View Users</h1><hr/>
<p>The second user story is:</p>
<blockquote>
<p>As a User I can get a list of all existing Users, so that I can assign Todos to them</p>
</blockquote>
<p>Now, the point of this one is actually just to be able to assign users to Todos, so the phrasing of the user story could have been better. But we needed that endpoint in the Web API, to retrieve a list of users.</p>
<p>So, we might as well make a page to view all users.</p>
<h2 id="new-page">New Page</h2>
<p>Make a new page in the Pages directory, call it &quot;ViewUsers&quot;.</p>
<p>The content will look like this:</p>
<pre><code class="line-numbers language-razor">@page &quot;/ViewUsers&quot;
&lt;h3&gt;ViewUsers&lt;/h3&gt;

@code {
    
}
</code></pre>
<h2 id="add-to-menu">Add to menu</h2>
<p>Let's also add it as a menu Item right away. Go ahead and do that, in the same way as the previous page.</p>
<p>Notice that for each nav menu item in the HTML of NavMenu.razor, there is a <code>&lt;span&gt;</code> tag, with the class defining what icon should be next to the text.</p>
<p>For example:</p>
<pre><code class="line-numbers language-razor">&lt;span class=&quot;oi oi-list&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt; View users
</code></pre>
<p><a href="https://icon-sets.iconify.design/oi/">You can find many available icons here</a>, they seem to be included in bootstrap, located in a file here: BlazorWASM/wwwroot/open-iconic/font/css/open-iconic-bootstrap.min.css.</p>
<p>So, maybe the icon for this menu item should be a list. Or something else. You can pick whatever.</p>

</div>
<div class="tab">
<hr/><h1 id="user-service-method">User Service Method</h1><hr/>
<p>We start by implementing a method to retrieve all users.</p>
<p>In IUserService interface we need the following method. The Web API actually allows us to search for Users by user name, so lets include that .</p>
<pre><code class="line-numbers language-csharp">Task&lt;IEnumerable&lt;User&gt;&gt; GetUsers(string? usernameContains = null);
</code></pre>
<h6 id="yes-the-method-name-should-have-been-suffixed-async.you-may-do-this.i-may-change-this">(yes, the method name should have been suffixed &quot;Async&quot;. You may do this. I may change this.)</h6>
<p>By assigning the argument to null here, we can provide a default value. This means we do not need to provide an argument when calling the method, and if we don't, the argument will be set to null. Alternatively, we would have to actively pass <code>null</code> as the argument, when calling the method from a page's code block.</p>
<p>The method can be called like this:</p>
<pre><code class="line-numbers language-csharp">IEnumerable&lt;User&gt; users = await userService.GetUsers();
</code></pre>
<h2 id="implementation">Implementation</h2>
<p>Let's implement the method in UserHttpClient.
We must construct the URI and take into account the <code>usernameContains</code> variable.
Then make the request, check the response, deserialize the response content, and return it.</p>
<pre><code class="line-numbers language-csharp">public async Task&lt;IEnumerable&lt;User&gt;&gt; GetUsers(string? usernameContains = null)
{
    string uri = &quot;/users&quot;;
    if (!string.IsNullOrEmpty(usernameContains))
    {
        uri += $&quot;?username={usernameContains}&quot;;
    }
    HttpResponseMessage response = await client.GetAsync(uri);
    string result = await response.Content.ReadAsStringAsync();
    if (!response.IsSuccessStatusCode)
    {
        throw new Exception(result);
    }

    IEnumerable&lt;User&gt; users = JsonSerializer.Deserialize&lt;IEnumerable&lt;User&gt;&gt;(result, new JsonSerializerOptions
    {
        PropertyNameCaseInsensitive = true
    })!;
    return users;
}
</code></pre>
<p>The method is async, because we make a call to the Web API, which may take time.
The argument is again defaulted to <code>null</code> here, like in the interface.
And the return type is <code>IEnumerable&lt;Users&gt;</code>, i.e. the immutable collection returned from the Web API endpoint.<br />
(We can actually deserialize the JSON into any kind of collection, it need not be IEnumerable).</p>
<p>First the sub-URI is defined to be &quot;/users&quot;.<br />
Then, if the method-argument is not null, we suffix that to the URI as a query parameter. The URI might then e.g. be: <code>/users?username=roe</code>, to fetch all users whose name contains &quot;roe&quot;.</p>
<p>Next follows template code very similar to the other method in the class. A GET request is made, the response is checked for success. In case of failure, an error is thrown. In case of success, the string is de-serialized from JSON to <code>IEnumerable&lt;User&gt;</code>, which is then returned.</p>
<p>That should be all for the service.</p>

</div>
<div class="tab">
<hr/><h1 id="view-users-code-block">View Users Code Block</h1><hr/>
<p>With the service implementation done, let's move to the page.</p>
<p>We will start with the code block in the page.</p>
<p>When it loads, we need to retrieve the list of users, so that it can be displayed. Here we go:</p>
<pre><code class="line-numbers language-csharp">@code {
    private IEnumerable&lt;User&gt;? users;
    private string msg = &quot;&quot;;

    protected override async Task OnInitializedAsync()
    {
        msg = &quot;&quot;;
        try
        {
            users = await userService.GetUsers();
        }
        catch (Exception e)
        {
            Console.WriteLine(e);
            msg = e.Message;
        }
    }
}
</code></pre>
<p>We have first a field variable to hold the users. It is marked as nullable, because it will be <code>null</code> until the data is retrieved from the server.<br />
First, the page will be rendered and displayed, then the <code>OnInitializedAsync</code> method is called, and then part of the page is re-renderd, because of the change to the field variable <code>users</code>.</p>
<p>Then a field variable, <code>msg</code>, to hold any messages, in case of errors.</p>
<p>The method, <code>OnInitializedAsync</code>, is overridden from ComponentBase. All blazor components automatically inherits from it.<br />
This specific method is automatically called, whenever the page loads.<br />
It just retrieves a collection of Users from through the IUserService. In case of errors, the message is assigned to <code>msg</code>, which can then be displayed in the view.</p>
<p>Remember, if the IUserService implementation receives a failure status code from the Web API, an exception is thrown. That's what we catch here.<br />
It means most of our methods in the pages will have this try-catch structure, which is not particularly pretty, but it is the simple solution.<br />
Better alternatives probably exist, but we will not cover that here.</p>

</div>
<div class="tab">
<hr/><h1 id="view-users-view">View Users View</h1><hr/>
<p>So, the view part of viewing users. The HTML and razor-syntax (i.e. inline C# code).</p>
<p>We wish to display all user names. That can be formatted in different ways.
It could just be a bullet list, or something else.
I have again attempted to try some attempt of maybe applying some kind of fancy styling, sort of.
We'll take that on the next slide.</p>
<p>Here is the html razor-syntax:</p>
<pre><code class="line-numbers language-csharp">@page &quot;/ViewUsers&quot;
@using Domain.Models
@using HttpClients.ClientInterfaces
@inject IUserService userService

&lt;h3 style=&quot;text-align: center&quot;&gt;Overview of all users&lt;/h3&gt;

@if (!string.IsNullOrEmpty(msg))
{
    &lt;div&gt;
        &lt;span&gt;@msg&lt;/span&gt;
    &lt;/div&gt;
}

@if (users == null)
{
    &lt;span&gt;Loading..&lt;/span&gt;
}
else if (!users.Any())
{
    &lt;span&gt;No users to be found&lt;/span&gt;
}
else
{
    &lt;div class=&quot;users-container&quot;&gt;
        @foreach (User user in users)
        {
            &lt;div class=&quot;user-card&quot;&gt;
                &lt;label&gt;@user.UserName&lt;/label&gt;
            &lt;/div&gt;
        }
    &lt;/div&gt;
}
</code></pre>
<p><strong>Line 1</strong>: The page directive, i.e. the URI to access this page.</p>
<p><strong>Lines 2-3</strong>: Import statements, so that we can access classes <code>User</code> and <code>IUserService</code>.</p>
<p><strong>Line 4</strong>: Here we inject an <code>IUserService</code> instance.</p>
<p><strong>Line 6</strong>: It's just a header. I have committed crimes and just inlined a bit of styling in the tag.</p>
<p><strong>Line 8</strong>: Here we display the <code>msg</code> in case it has any value. This happens in case of errors.</p>
<p><strong>Line 15</strong>: Here starts an if-else if-else:</p>
<p><strong>if</strong>: the <code>users</code> variable is null, it is because no data has been retrieved from the server.</p>
<p><strong>else if</strong>: this is the case, when the <code>users</code> are loaded, but the collection is empty. The method <code>Any()</code> returns true, if there are any elements in the collection.</p>
<p><strong>else</strong>: finally, here we have loaded data, and there is actually some data. We wish to display all users. There is a <code>foreach</code> to loop through the <code>users</code>, and for each User object, we generate a little piece of html, i.e. the <code>&lt;div</code> and <code>&lt;label&gt;</code> tags.\
This piece here: <code>&lt;label&gt;@user.UserName&lt;/label&gt;</code>, notice how we use the <code>user</code> variable from the foreach-loop, and get the <code>UserName</code>. This is a string, which will then be displayed in the UI.</p>
<p>Again, notice how <code>@</code> is used to inline some C# code, which is evaluated to generate the resulting HTML. We can inline C# just about anywhere, so the dynamic HTML generation can be <em>very</em> flexible.</p>
<p>Finally, let's add some styling.</p>

</div>
<div class="tab">
<hr/><h1 id="styling-the-view-users-page">Styling the View Users Page</h1><hr/>
<p>Create a style-behind again, similar to what we did with the AddUser page.</p>
<p>Insert the below styling:</p>
<pre><code class="line-numbers language-css">.user-card {
    box-shadow: 0 4px 8px 0 rgba(0,0,0,0.2);
    display: inline-block;
    margin: 25px;
    padding: 15px;
    border-radius: 10px;
}
</code></pre>
<h2 id="test">Test</h2>
<p>You might want to add a couple of users first, so you have a handful.</p>
<p>Run Web API and then run Blazor.</p>
<p>Then open the ViewUsers page, it should look something like this:</p>
<p><img src="Resources/ViewUsersPage.png" alt="img.png" /></p>

</div>
<div class="tab">
<hr/><h1 id="add-new-todo">Add New Todo</h1><hr/>
<p>We are ready for the next feature:</p>
<blockquote>
<p>As a User I can add a new Todo, so that I can remember important things</p>
</blockquote>
<p>The user should input title, and assignee of a Todo. The assignee is to be selected from a drop-down menu.
This may not scale too well, if there are hundreds of users, but we will keep it simple for now. Later we might introduce some search functionality to find a specific User.</p>
<p>We need:</p>
<ul>
<li>Create a new Service interface, responsible for Todos.</li>
<li>Implement a new HTTP service, responsible for Todos.</li>
<li>Create a page, where the user can input the relevant data.</li>
</ul>
<p><a href="https://github.com/TroelsMortensen/WasmTodo/tree/012_CreateTodo">This feature is found in this branch</a></p>

</div>
<div class="tab">
<hr/><h1 id="service-for-handling-todos">Service for Handling Todos</h1><hr/>
<p>We start by defining the interfaces. Then the implementation.</p>
<h2 id="interfaces">Interfaces</h2>
<p>We need to be able to retrieve users, so that we can select an assignee. That already exists in the <code>IUserService</code>.</p>
<p>We also need a new interface, &quot;ITodoService&quot;. Create this in HttpClients/ClientInterfaces.</p>
<p>It needs a method to create Todos. It does not need to return anything. And the argument is the <code>TodoCreationDto</code> we already have.</p>
<p>The interface then looks like this:</p>
<pre><code class="line-numbers language-csharp">public interface ITodoService
{
    Task CreateAsync(TodoCreationDto dto);
}
</code></pre>
<h6 id="notice-how-i-remembered-to-suffix-it-async">(Notice how I remembered to suffix it &quot;Async&quot;.)</h6>
<p>We could again return the result Todo, like we did with the Create User method. Maybe we will change this method later, if it is needed.</p>
<h2 id="implementation">Implementation</h2>
<p>Next up, create a new class, &quot;TodoHttpClient&quot; inside HttpClients/Implementations.</p>
<p>It initially looks like this:</p>
<pre><code class="line-numbers language-csharp">public class TodoHttpClient : ITodoService
{
    private readonly HttpClient client;

    public TodoHttpClient(HttpClient client)
    {
        this.client = client;
    }

    public Task CreateAsync(TodoCreationDto dto)
    {
        throw new NotImplementedException();
    }
}
</code></pre>
<p>Then the implementation. Give it a go yourself first, it is very similar to how we handled creating users.</p>
<details>
<summary>hint</summary>
<pre><code class="line-numbers language-csharp">public async Task CreateAsync(TodoCreationDto dto)
{
    HttpResponseMessage response = await client.PostAsJsonAsync(&quot;/todos&quot;,dto);
    if (!response.IsSuccessStatusCode)
    {
        string content = await response.Content.ReadAsStringAsync();
        throw new Exception(content);
    }
}
</code></pre>
<p>The client is used to make a POST request with the JSON. The response is checked for failure, in which case an exception is thrown.</p>
</details>
<h2 id="add-as-service">Add as Service</h2>
<p>Add your new interface and implementation as services in BlazorWASM/Program.cs:</p>
<pre><code class="line-numbers language-csharp">builder.Services.AddScoped&lt;ITodoService, TodoHttpClient&gt;();
</code></pre>

</div>
<div class="tab">
<hr/><h1 id="add-todo-page">Add Todo Page</h1><hr/>
<p>Next up is the UI.</p>
<p>Create a new Page, call it &quot;CreateTodo&quot;. Leave it empty for now.</p>
<h2 id="nav-menu">Nav Menu</h2>
<p>Add a new nav menu item to the nav menu, so that we can easily open the CreateTodo page.</p>
<h2 id="code-block">Code block</h2>
<p>We start with the code block.</p>
<p>We need to initially load the users. And we need a method to take the input, wrap it up and forward it to the client class.</p>
<p>It looks like this. Read through it, see if it makes sense, then read the comments below:</p>
<pre><code class="line-numbers language-csharp">@code {
    private IEnumerable&lt;User&gt;? users;
    private int? selectedUserId;
    private string todoTitle = &quot;&quot;;

    private string msg = &quot;&quot;;

    protected override async Task OnInitializedAsync()
    {
        msg = &quot;&quot;;
        try
        {
            users = await userService.GetUsers();
        }
        catch (Exception e)
        {
            Console.WriteLine(e);
            msg = e.Message;
        }
    }

    private async Task Create()
    {
        msg = &quot;&quot;;
        if (selectedUserId == null)
        {
            msg = &quot;You must select an assignee!&quot;;
            return;
        }
        if (string.IsNullOrEmpty(todoTitle))
        {
            msg = &quot;Title cannot be empty!&quot;;
            return;
        }

        try
        {
            TodoCreationDto dto = new((int)selectedUserId, todoTitle);
            await todoService.CreateAsync(dto);
            navMgr.NavigateTo(&quot;/&quot;);
        }
        catch (Exception e)
        {
            Console.WriteLine(e);
            msg = e.Message;
        }
    }
}
</code></pre>
<p>The first field holds the users. They are retrieved when the page is loaded, using the <code>OnInitializedAsync()</code> method, overridden from the ComponentBase super class.</p>
<p>The second field hold the selected User id. Initially no user is selected, so the value must be <code>null</code>.</p>
<p>The third field is for the Todo title.</p>
<p>And the fourth is for any messages, in case of errors and such.</p>
<p>The method <code>OnInitializedAsync()</code> just fetches all Users from the server.</p>
<p>The <code>Create()</code> method will first reset the <code>msg</code>. Then we check if User and Title is set. This is also checked on the server, but we do a basic check here, so we don't have to contact the server if the User have not filled out everything.<br />
Then a new <code>TodoCreationDto</code> is created, this class already exists in the Domain component, it is what the Web API requires. It is handed over to the ITodoService to be sent to the server.</p>
<p>In both methods we catch any potential errors from the layer below, and display the message through the <code>msg</code> field.</p>
<h4 id="navigationmanager">NavigationManager</h4>
<p>After the call to the <code>ITodoService::CreateAsync()</code> we do something different. For the CreateUser page, we would just display a message saying success. Here we take the opportunity to introduce a new helper class, the <code>NavigationManager</code></p>
<p>This class is injected like the services, see below. It is by default available, we do not need to register it as a service, and we can use it to navigate to a different page. So far, the user has been in control of navigating between pages in the app, by clicking the menu items.
But sometimes something happens, and we want to take the user to a different page.</p>
<p>The argument <code>(&quot;/&quot;)</code> is the URI of the page we want to display. For now, we navigate to the home page. Later we will change this, so we are taken to the Todo overview page. The argument will then be <code>(&quot;/ViewTodos&quot;)</code>.</p>
<p>No success message is shown to the user now, only in case of errors. Whether that is user friendly is less relevant for the example. It will be changed later, though.</p>
<h2 id="the-view">The View</h2>
<p>Again we have to do the if-else if-else thing to check for Users. If there are users, we display the input elements for creating a Todo.</p>
<p>It looks like this:</p>
<pre><code class="line-numbers language-razor">@page &quot;/CreateTodo&quot;
@using HttpClients.ClientInterfaces
@using Domain.Models
@using Domain.DTOs
@inject IUserService userService
@inject ITodoService todoService
@inject NavigationManager navMgr

&lt;div class=&quot;card&quot;&gt;
    @if (users == null)
    {
        &lt;label&gt;Loading users...&lt;/label&gt;
    }
    else if (!users.Any())
    {
        &lt;label&gt;No users, you cannot create a Todo without assignee.&lt;/label&gt;
    }
    else
    {
        &lt;h3&gt;Create Todo&lt;/h3&gt;
        &lt;div class=&quot;form-group field&quot;&gt;
            &lt;label&gt;Title:&lt;/label&gt;
            &lt;input type=&quot;text&quot; @bind=&quot;todoTitle&quot;/&gt;
        &lt;/div&gt;
        &lt;div class=&quot;form-group field&quot;&gt;
            &lt;label&gt;Assignee:&lt;/label&gt;
            &lt;select @bind=&quot;selectedUserId&quot;&gt;
                &lt;option&gt;Choose&lt;/option&gt;
                @foreach (User user in users)
                {
                    &lt;option value=&quot;@user.Id&quot;&gt;@user.UserName&lt;/option&gt;
                }
            &lt;/select&gt;
        &lt;/div&gt;
        &lt;div class=&quot;button-row&quot;&gt;
            @if (!string.IsNullOrEmpty(msg))
            {
                &lt;label style=&quot;color: red&quot;&gt;@msg&lt;/label&gt;
            }
            &lt;button @onclick=&quot;Create&quot; class=&quot;acceptbtn&quot;&gt;Create&lt;/button&gt;
        &lt;/div&gt;
    }
&lt;/div&gt;
</code></pre>
<p>Page directive first, then importing namespaces, and we inject both <code>IUserService</code>, <code>ITodoService</code>, and the <code>NavigationManager</code>.</p>
<p>Everything is wrapped in a <code>&lt;div&gt;</code>, we will make it card-ish, like we did with the create User page.</p>
<p>Then we have the if-else if-else. It is similar to the ViewUsers page, same purpose.<br />
If there are Users, the input elements are displayed.<br />
There is a header, <code>&lt;h3&gt;</code> and then a <code>&lt;div&gt;</code> containing a simple text input field, the value of which is bound to the field variable <code>todoTitle</code>.<br />
This time, we just use the default @bind, but don't specify an event. This means the value of todoTitle will be updated, when the input field is de-focused, i.e. you press enter, or click outside of it.</p>
<p>Then the next div to hold a drop down menu. In HTML that is a <code>&lt;select&gt;</code>. Here we bind the value of what is selected to the field <code>selectedUserId</code>.<br />
We use a <code>@foreach</code> to generate all the options in the <code>&lt;select&gt;</code> tag. The <code>value=&quot;@user.Id&quot;</code> in <em>line 31</em> specifies what will be pushed to the field variable <code>selectedUserId</code>. The <code>@user.UserName</code> is what will be displayed.<br />
I have included a &quot;dummy option&quot;, called &quot;Choose&quot; before the for-loop, just so that you have to make an active choice.</p>
<p>In the last div, we have the error message, and the button.</p>
<p>We could apply the same logic as seen in CreateUser page, where the button is disabled when there is no valid data. But here we see a simpler approach, just for some diversity.</p>
<h4 id="comment">Comment</h4>
<p>This simpler approach is not necessarily better. In general your UI becomes more user friendly, if you can block a user from doing something, rather than let them attempt something and get an error response.</p>
<p>So, not being able to click a button, when the input is not correct can be an improvement. However, sometimes it may not be clear why a button is disabled. So on the other hand, if you leave it enabled, the user can click it and get a message saying what the still need to fill out.<br />
You have to help your users, and spend some time figuring out the best way.</p>
<h2 id="styling">Styling</h2>
<p>Create a style-behind for <code>CreateTodo.razor</code>. Insert the following styles (actually just copied from the style of CreateUser.razor.css):</p>
<pre><code class="line-numbers language-css">.card {
    box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2);
    transition: 0.3s;
    width: 250px;
    padding: 25px;
    text-align: center;
    margin: auto;
    margin-top: 50px;
    border-radius: 15px;
}

.field {
    margin-top: 20px;
}

.acceptbtn {
    background-color: lightgreen;
    border-radius: 5px;
    padding: 5px;
    padding-left: 10px;
    padding-right: 10px;
}

.button-row {
    margin-top: 15px;
}
</code></pre>
<p>Yes, it is identical to what you have in another page. We will optimize below, after testing.</p>
<h2 id="test">Test</h2>
<p>Run the Web API and your Blazor app. Open the page to create a new Todo. It should look like this:</p>
<p><img src="Resources/CreateTodoPageView.png" alt="img.png" /></p>
<p>Do some sunny and rainy tests. Verify you get error messages as expected, and verify the Todo goes into the data.json file in WebAPI component, when succeeding in creating a Todo.</p>
<h2 id="refactoring-styles">Refactoring Styles</h2>
<p>Now, because we are using the same styles twice, it would be a good idea to centralize it, make the styles available app-wide.
If I wish to update the color of accept buttons, I would now have to do it in two places. Repeating code is rarely good.<br />
We could just copy the style into the existing default file here: BlazorWASM/wwwroot/css/app.css.<br />
This file is &quot;global&quot;, i.e. styles here are accessible across your app.
When doing style-behinds, those styles are available only to that specific page. Officially, I believe they are called &quot;isolated css&quot;</p>
<p>Alternatively we can create a new global style sheet, let's do that, so you see how it is done.</p>
<p>At this location: BlazorWASM/wwwroot/css create a new file: &quot;styles.css&quot;. Or whatever you want to call it.<br />
Copy the styles from your style-behind in here.</p>
<p>We then need to tell the app to load this style sheet too. Open BlazorWASM/wwwroot/index.html.</p>
<p>Inside the <code>&lt;head&gt;</code> tag add the highlighted line:</p>
<pre data-line="8"><code class="line-numbers language-html">&lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot; /&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no&quot; /&gt;
    &lt;title&gt;BlazorWASM&lt;/title&gt;
    &lt;base href=&quot;/&quot; /&gt;
    &lt;link href=&quot;css/bootstrap/bootstrap.min.css&quot; rel=&quot;stylesheet&quot; /&gt;
    &lt;link href=&quot;css/app.css&quot; rel=&quot;stylesheet&quot; /&gt;
    &lt;link href=&quot;css/styles.css&quot; rel=&quot;stylesheet&quot; /&gt;
    &lt;link href=&quot;BlazorWASM.styles.css&quot; rel=&quot;stylesheet&quot; /&gt;
&lt;/head&gt;
</code></pre>
<p>Notice how the already existing app.css is loaded in line 7. And by default a non-existing style-sheet with a name matching your project name is loaded in line 9. For whatever reason.</p>
<h3 id="delete-style-behinds">Delete style behinds.</h3>
<p>Now delete the two style behinds <code>CreateTodo.razor.css</code> and <code>CreateUser.razor.css</code>. Or do a &quot;soft-delete&quot; by just commenting out the content in those two files for now.</p>
<p>Sometimes a Blazor app does not reload new styles correctly, and you will have to press <kbd>ctrl</kbd>+<kbd>F5</kbd> in your browser to do a hard refresh. And maybe a clean-rebuild of the project too:</p>
<p><img src="Resources/CleanRebuild.png" alt="img.png" /></p>

</div>
<div class="tab">
<hr/><h1 id="view-all-todos">View All Todos</h1><hr/>
<p>Next up we work on the following user story:</p>
<blockquote>
<p>As a User I can view all or filtered Todos, so that I can remember what to do</p>
</blockquote>
<p>We want to see all todos, and potentially do some filtering.</p>
<p><a href="https://github.com/TroelsMortensen/WasmTodo/tree/013_ViewTodos">This feature is found here on GitHub</a></p>

</div>
<div class="tab">
<hr/><h1 id="get-all-todos">Get All Todos</h1><hr/>
<p>We start with the client layer, and first the interface.</p>
<p>We need to be able to retrieve Todos, and request them with filtering. We already have an endpoint for this.</p>
<h2 id="interface">Interface</h2>
<p>In ITodoService interface add the following method:</p>
<pre><code class="line-numbers language-csharp">Task&lt;ICollection&lt;Todo&gt;&gt; GetAsync(
        string? userName, 
        int? userId, 
        bool? completedStatus, 
        string? titleContains
    );
</code></pre>
<p>You don't really need to split it across multiple lines. I do this for readability when there are many arguments.</p>
<h2 id="implementation">Implementation</h2>
<p>Next up, we implement the method in TodoHttpClient.</p>
<p>The method for fetching the data initially looks like below. However, the filter is not yet applied. We do that later:</p>
<pre><code class="line-numbers language-csharp">public async Task&lt;ICollection&lt;Todo&gt;&gt; GetAsync(string? userName, int? userId, bool? completedStatus, string? titleContains)
{
    HttpResponseMessage response = await client.GetAsync(&quot;/todos&quot;);
    string content = await response.Content.ReadAsStringAsync();
    if (!response.IsSuccessStatusCode)
    {
        throw new Exception(content);
    }

    ICollection&lt;Todo&gt; todos = JsonSerializer.Deserialize&lt;ICollection&lt;Todo&gt;&gt;(content, new JsonSerializerOptions
    {
        PropertyNameCaseInsensitive = true
    })!;
    return todos;
}
</code></pre>
<p>It takes the four filter criteria, all nullable, in case we don't want to apply a specific filter. We currently use none of them. We will modify this code later, when we apply the filters.</p>
<p>It is the usual about making a GET request, checking the status code, and deserializing the response. You have seen this before.</p>

</div>
<div class="tab">
<hr/><h1 id="view-all-todos-page">View All Todos Page</h1><hr/>
<p>First, create a new Blazor page in the Pages directory. Call it &quot;ViewTodos&quot;.</p>
<p>This page is going to be a bit more complicated, we will expand it over a few iterations.</p>
<ul>
<li>Initially it will just display all Todos.</li>
<li>Then we add filtering functionality.</li>
<li>Then the next user story is about completing a Todo, so we expand this page for that.</li>
<li>We can edit Todos, which will be initiated in this page.</li>
<li>We will also be able to delete Todos, from this page.</li>
<li>And finally we will show a popup.</li>
</ul>
<p>All these things, one thing at a time.</p>
<p>First, we will just load and display all Todos.</p>
<h2 id="the-code">The Code</h2>
<p>We need a method to fetch the Todos. So the code block looks like this:</p>
<pre><code class="line-numbers language-csharp">@code {
    private IEnumerable&lt;Todo&gt;? todos;
    private string msg = &quot;&quot;;

    private async Task LoadTodos()
    {
        try
        {
            todos = await todoService.GetAsync(null, null, null, null);
        }
        catch (Exception e)
        {
            Console.WriteLine(e);
            msg = e.Message;
        }
    }
}
</code></pre>
<p>We have a field to hold the Todos, and a <code>msg</code> for any messages to the user.</p>
<p>The method will get the Todos from the <code>ITodoService</code>. The method takes the four filter criteria, but we have none, currently.
Therefore, the arguments are just <code>null</code>, meaning no filtering is applied.</p>
<h2 id="the-view">The View</h2>
<p>The view code is shown below. Same approach with if-else if-else in order to show Todos.</p>
<pre><code class="line-numbers language-csharp">@page &quot;/ViewTodos&quot;
@using Domain.Models
@using HttpClients.ClientInterfaces
@inject ITodoService todoService

&lt;h3&gt;Todos&lt;/h3&gt;

&lt;div&gt;
    &lt;button @onclick=&quot;LoadTodos&quot;&gt;Load&lt;/button&gt;
&lt;/div&gt;

@if (todos == null)
{
}
else if (!todos.Any())
{
    &lt;p&gt;No Todos to display&lt;/p&gt;
}
else
{
    &lt;table class=&quot;table&quot;&gt;
        &lt;thead&gt;
        &lt;tr&gt;
            &lt;th&gt;Todo ID&lt;/th&gt;
            &lt;th&gt;Owner ID&lt;/th&gt;
            &lt;th&gt;Title&lt;/th&gt;
            &lt;th&gt;Completed?&lt;/th&gt;
        &lt;/tr&gt;
        &lt;/thead&gt;
        &lt;tbody&gt;
        @foreach (var item in todos)
        {
            &lt;tr&gt;
                &lt;td&gt;@item.Id&lt;/td&gt;
                &lt;td&gt;@item.Owner.UserName&lt;/td&gt;
                &lt;td&gt;@item.Title&lt;/td&gt;
                &lt;td&gt;@item.IsCompleted&lt;/td&gt;
            &lt;/tr&gt;
        }
        &lt;/tbody&gt;
    &lt;/table&gt;
}
@if (!string.IsNullOrEmpty(msg))
{
    &lt;label style=&quot;color: red&quot;&gt;@msg&lt;/label&gt;
}
</code></pre>
<p>The usual at the top: page directive, imports, injects.</p>
<p>We have the button in line 9 to call the <code>LoadTodos()</code> method.</p>
<p>Then the usual checks we do, when we want to display a collection: if-else if-else.</p>
<p>The else-part is the only interesting thing here. We define a table. Lines 24-27 are the column titles.<br />
The rows are generated with a foreach-loop, iterating over the Todos, in line 31.<br />
Each row consists of some table data, each cell is in the <code>&lt;td&gt;</code> tags. Here we pull the data from the Todos to display in the view.<br />
Notice the <code>Owner</code> is a User object, therefore, we need to go a step deeper for the actual user name: <code>@item.Owner.UserName</code>.</p>
<h4 id="styling">Styling</h4>
<p>We will skip styling, the reader is welcome to apply some themself. Define the css in either a style-behind (we won't do other tables, so isolating the css might be fine), or use one of the global css files.</p>
<h2 id="test">Test</h2>
<p>This should be working now. Run your Web API and Blazor app, navigate to the View Users page, and press the load button. You should see your Todos displayed in the table.</p>
<p>We will now expand this page with filtering functionality.</p>

</div>
<div class="tab">
<hr/><h1 id="view-todos-with-filtering">View Todos With Filtering</h1><hr/>
<p><del><a href="">This part of the feature is in a new branch here</a></del> -&gt; apparently I forgot to create a new branch, so...</p>
<p><img src="Resources/Shrug.png" alt="" /></p>
<p>We will continue on the View Todos page, by adding some filtering functionality to it.</p>
<p>This requires four input fields in the view. The data of these should then be passed to the <code>ITodoService</code>.</p>
<p>Our Web API should already be able to handle things from there.</p>
<h2 id="icons">Icons</h2>
<p>We are going to use two icons, which will be clicked to show/hide the filter inputs.</p>
<p>First, create a directory called &quot;icons&quot; here:</p>
<p><img src="Resources/IconsFolder.png" alt="img.png" /></p>
<p>This directory will house our icons. Since they are inside the &quot;wwwroot&quot; we can easily use them in the pages.</p>
<p>Next, download the two following funnel icons, and place them into the directory. You should be able to right click them, and select to &quot;save as&quot;. <a href="https://github.com/TroelsMortensen/WasmTodo/tree/014_ViewTodosWithFilter/BlazorWASM/wwwroot/icons">Otherwise find them here</a></p>
<p><img src="Resources/funnel.png" alt="" /></p>
<p><img src="Resources/clear_funnel.png" alt="" /></p>
<p>We will use these icons as buttons to open/close the filters. Take a moment to appreciate the icons, I made them myself.</p>
<p><img src="Resources/IMadeIt.gif" alt="" /></p>
<h2 id="code-block">Code Block</h2>
<p>We must provide field variables to hold the data for the new input fields. They must be passed to the call to get Todos from the ITodoService.</p>
<p>It looks like this:</p>
<pre data-line="6-9,20"><code class="line-numbers language-csharp">@code {
    private IEnumerable&lt;Todo&gt;? todos;
    private string msg = &quot;&quot;;
    private bool doShowFilters = false;

    private string? usernameFilter;
    private int? userIdFilter;
    private string? completedStatusFilter;
    private string? titleContainsFilter;
    
    private async Task LoadTodos()
    {
        try
        {
            bool? completedFilterValue = null;
            if (!string.IsNullOrEmpty(completedStatusFilter) &amp;&amp; !completedStatusFilter.Equals(&quot;all&quot;))
            {
                completedFilterValue = bool.Parse(completedStatusFilter);
            }
            todos = await todoService.GetAsync(usernameFilter, userIdFilter, completedFilterValue, titleContainsFilter);
        }
        catch (Exception e)
        {
            Console.WriteLine(e);
            msg = e.Message;
        }
    }
}
</code></pre>
<p>In lines 15-19 we get the value of the input field for the completed status.
We are using a drop-down menu, with the values &quot;all&quot;, &quot;true&quot;, &quot;false&quot;. And so, if <code>all</code> is selected, the filter is not applied. Otherwise the value is parsed to a boolean.<br />
All four fields are nullable, so we can choose to not provide a value, to indicate a specific filter should be ignored.</p>
<p>Notice also the field variable <code>doShowFilters</code>, which is used to determine whether the filters should be shown or not.</p>
<h2 id="view">View</h2>
<p>We must update the view to display the four new required input fields. We will make a show/hide functionality using the funnel icons from above.</p>
<p>Below is shown the first part of the updated view, but the table definition is not shown, as it is not relevant for this.</p>
<pre><code class="line-numbers language-razor">@page &quot;/ViewTodos&quot;
@using Domain.Models
@using HttpClients.ClientInterfaces
@inject ITodoService todoService

&lt;h3&gt;Todos&lt;/h3&gt;
&lt;div class=&quot;filter-bar&quot;&gt;
    &lt;div class=&quot;filters-container&quot;&gt;
        &lt;img src=&quot;icons/@(doShowFilters ? &quot;clear_&quot; : &quot;&quot;)funnel.png&quot; class=&quot;funnel&quot; @onclick=&quot;@(() =&gt; doShowFilters = !doShowFilters)&quot; alt=&quot;Funnel&quot;/&gt;
        @if (doShowFilters)
        {
            &lt;div class=&quot;filter&quot;&gt;
                &lt;label&gt;Username:&lt;/label&gt;
                &lt;input type=&quot;text&quot; @bind=&quot;usernameFilter&quot;/&gt;
            &lt;/div&gt;
            &lt;div class=&quot;filter&quot;&gt;
                &lt;label&gt;User id:&lt;/label&gt;
                &lt;input type=&quot;number&quot; @bind=&quot;userIdFilter&quot;/&gt;
            &lt;/div&gt;
            &lt;div class=&quot;filter&quot;&gt;
                &lt;label&gt;Is completed?&lt;/label&gt;
                &lt;select @bind=&quot;completedStatusFilter&quot;&gt;
                    &lt;option value=&quot;all&quot;&gt;All&lt;/option&gt;
                    &lt;option value=&quot;true&quot;&gt;Yes&lt;/option&gt;
                    &lt;option value=&quot;false&quot;&gt;No&lt;/option&gt;
                &lt;/select&gt;
            &lt;/div&gt;
            &lt;div class=&quot;filter&quot;&gt;
                &lt;label&gt;Title contains:&lt;/label&gt;
                &lt;input type=&quot;text&quot; @bind=&quot;titleContainsFilter&quot;/&gt;
            &lt;/div&gt;
        }
    &lt;/div&gt;
&lt;/div&gt;

&lt;div&gt;
    &lt;button @onclick=&quot;LoadTodos&quot;&gt;Load&lt;/button&gt;
&lt;/div&gt;

... 
</code></pre>
<p>The new part is from the <code>&lt;div&gt;</code> tag, with the class of &quot;filter-bar&quot;. Here we create a container to hold the filter input fields.</p>
<p>The <code>&lt;img&gt;</code> tag displays either the &quot;funnel&quot; icon or the &quot;clear_funnel&quot; icon, based on the value of <code>doShowFilters</code>. This part here:</p>
<pre><code class="line-numbers language-razor">src=&quot;icons/@(doShowFilters ? &quot;clear_&quot; : &quot;&quot;)funnel.png&quot;
</code></pre>
<p>Inside the parenthesis is a &quot;ternary expression&quot;, it is a short-hand if-then-else. If <code>doShowFilters</code> is true, the &quot;clear_&quot; is returned, otherwise the &quot;&quot;. The value is then put together with <code>funnel.png</code>. So the src value will be either:</p>
<ul>
<li>clear_funnel.png</li>
<li>funnel_png</li>
</ul>
<p>There is an onclick handler attached, with the <code>@onclick</code>, containing the following lambda expression:</p>
<pre><code class="line-numbers language-csharp">() =&gt; doShowFilters = !doShowFilters
</code></pre>
<p>What this will do is simply to just flip the value of doShowFilters. If it is <code>false</code>, it will become <code>true</code> and vice versa.</p>
<p>Then we have the <code>@if</code>-statement checking if the filter inputs should be displayed. We have:</p>
<ol>
<li>First a text input for the User name.</li>
<li>Then a number input to filter by User ID.</li>
<li>Then a drop down, i.e. <code>&lt;select&gt;</code>, with three values: all, true, false. If all is selected, this filter is not used.</li>
<li>And finally a text input to check if the Title of a Todo contains the inserted text.</li>
</ol>
<p>The div and nested button below (lines 36-38) already existed, they are merely included so that you can see what part of the view is ne, i.e. most of the above.</p>
<h2 id="styling">Styling</h2>
<p>We do need a bit of styling, e.g. the icons are too large (they are .png files, and should have just been made smaller, e.g. 30 by 30 pixels), and the filters should be organized just a little bit.</p>
<p>Create a style-behind, &quot;ViewTodos.razor.css&quot;, and paste in the following style:</p>
<pre><code class="line-numbers language-css">.filter-bar {
    border: 1px solid #ccc;
    border-radius: 10px;
    padding: 5px;
    display: inline-block;
    margin: 10px;
}

.funnel{
    width:30px;
    height:30px;
    cursor: pointer;
}

.filter {
    border: 1px solid #ccc;
    border-radius: 5px;
    padding: 5px;
    margin: 5px;
    text-align: center;
}
</code></pre>
<p>You are obviously welcome to fiddle around, if you wish to make it prettier.</p>
<h2 id="todohttpclient">TodoHttpClient</h2>
<p>In this class we need to take the filter arguments and construct a string of query parameters to suffix to the URI.</p>
<p>We make the following changes. There is a new line of code in the existing <code>GetAsync()</code> method, the first line of the method body. We use the <code>query</code> in line 5 as the method argument.</p>
<p>And a new method.</p>
<pre data-line="3,5"><code class="line-numbers language-csharp">public async Task&lt;ICollection&lt;Todo&gt;&gt; GetAsync(string? userName, int? userId, bool? completedStatus, string? titleContains)
{
    string query = ConstructQuery(userName, userId, completedStatus, titleContains);

    HttpResponseMessage response = await client.GetAsync(&quot;/todos&quot;+query);
    string content = await response.Content.ReadAsStringAsync();
    if (!response.IsSuccessStatusCode)
    {
        throw new Exception(content);
    }

    ICollection&lt;Todo&gt; todos = JsonSerializer.Deserialize&lt;ICollection&lt;Todo&gt;&gt;(content, new JsonSerializerOptions
    {
        PropertyNameCaseInsensitive = true
    })!;
    return todos;
}

private static string ConstructQuery(string? userName, int? userId, bool? completedStatus, string? titleContains)
{
    string query = &quot;&quot;;
    if (!string.IsNullOrEmpty(userName))
    {
        query += $&quot;?username={userName}&quot;;
    }

    if (userId != null)
    {
        query += string.IsNullOrEmpty(query) ? &quot;?&quot; : &quot;&amp;&quot;;
        query += $&quot;userid={userId}&quot;;
    }

    if (completedStatus != null)
    {
        query += string.IsNullOrEmpty(query) ? &quot;?&quot; : &quot;&amp;&quot;;
        query += $&quot;completedstatus={completedStatus}&quot;;
    }

    if (!string.IsNullOrEmpty(titleContains))
    {
        query += string.IsNullOrEmpty(query) ? &quot;?&quot; : &quot;&amp;&quot;;
        query += $&quot;titlecontains={titleContains}&quot;;
    }

    return query;
}
</code></pre>
<p>So, the second method, <code>ConstructQuery(...)</code> is the interesting one.</p>
<p>It will check each filter argument, check if they are not null, in which case they should be ignore.
And otherwise include the needed filter argument in the query parameter string.</p>
<p>Results could for example be:</p>
<ul>
<li>&quot;?username=Troels&amp;titlecontains=hej&quot;</li>
<li>&quot;?userid=3&quot;</li>
<li>&quot;?completedstatus=false&amp;titlecontains=hej&quot;</li>
</ul>
<p>The query string must always start with a &quot;?&quot;, and each query is separated with &quot;&amp;&quot;.</p>
<p>This is achieved by all the ternary expressions, e.g. <code>query += string.IsNullOrEmpty(query) ? &quot;?&quot; : &quot;&amp;&quot;;</code>. The <code>query</code> variable is expanded upon for each if-statement.<br />
If <code>query</code> is empty, it means we are about to append the first query parameter, and the string must start with &quot;?&quot;. If the <code>query</code> is <em>not</em> empty, we are about to append another query parameter, and so we must insert &quot;&amp;&quot; to separate the existing with the new parameter.</p>
<p>The result of this method, the finished query string, is returned, and appended to &quot;/todos&quot;, so that they can be passed to the endpoint handling GET requests of &quot;/todos&quot;.</p>
<h6 id="thoughts">Thoughts</h6>
<p>As discussed in the tutorial of the Web API, when constructing the endpoint we are using here, it was discussed to instead use a POST with an object containing the query parameters. This might have been simpler.
And easier to expand upon.<br />
If we wish to add another query parameter, or remove one, we currently have to modify various things in: ViewTodos.razor, ITodoService, TodoHttpClient, TodosController. And also the TodoFileDao class.</p>
<p>However if the arguments were wrapped in an object, which would be created in ViewTodos.razor, it would be like a tunnel, and we would only have to modify the two ends, in this case: ViewTodos.razor, and TodoFileDao. So, in general it is better practice to wrap multiple simple type parameters into a single object.</p>
<h2 id="test">Test</h2>
<p>We are ready to test the filtering.</p>
<p>First, you may need to add a couple of Todos, so you have at least 10 with various values. The completed status must be manually changed from &quot;false&quot; to &quot;true&quot; in the <code>data.json</code> file, do this for a few Todos.</p>
<p>Run the Web API, then run the Blazor App.</p>
<p>Navigate to the page.</p>
<p>First just click load without applying filters, to verify that we didn't break anything.</p>
<p>Then play around with the filters, apply one or more in various combinations to verify the result is as expected.</p>

</div>
<div class="tab">
<hr/><h1 id="making-a-checkbox-component">Making a Checkbox Component</h1><hr/>
<p>We are about to let users complete Todos. We will do this in the existing ViewTodos page. The table has a column to display the status of a Todo, currently as a piece of text. We will change this to be a check-box.</p>
<p>This gives us an opportunity to create our own fancy checkbox as a component, to show an example of how to use components. So, before starting on the user story, we will make this fancy check box.</p>
<p><a href="https://github.com/TroelsMortensen/WasmTodo/tree/015_CheckBoxComponent">This part of the tutorial is found here</a></p>
<h2 id="what-are-components">What Are Components?</h2>
<p>Blazor is relying on a component structure. Here we talk about Blazor-components, not the components mentioned in the discussion of architecture, i.e. the projects in your solution.</p>
<p>You don't strictly need components, we have not really used them so far, and we have done just fine, but they can provide various benefits.</p>
<p>Various UI elements can be made into components, so that they can be reused, without you having to copy-paste code. This can be very convenient.</p>
<p>Consider the &quot;Create&quot;-button we used in both CreateTodo and CreateUser.
It looked the same, had the same styling, it could have the same functionality (with the disabling).<br />
Currently we have duplicated the HTML and code, but we could make the button into a component, and have the HTML, code, styling, and behaviour in just one place. Then it would be easy to use it all over our app, and if we needed to change something, e.g. make the color a slightly different shade of green, or add some disabling effect, or some other behaviour, everything is located in one place. We would need to only update on place. And so we would follow the <a href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself">DRY principle</a>, i.e. don't duplicate code.</p>
<p>You can create your own components, which we are about to. You can also import libraries of components made by others. Here are some popular ones, if you are curious.</p>
<ul>
<li>Blazor fluent UI, found <a href="https://www.blazorfluentui.net/">here</a></li>
<li>Radzen, found <a href="https://www.radzen.com/">here</a></li>
<li>Syncfusion, found <a href="https://www.syncfusion.com/blazor-components">here</a></li>
<li>Blazored, found <a href="https://giters.com/Blazored">here</a></li>
<li>AntBlazor, found <a href="https://antblazor.com/en-US/">here</a></li>
<li>MudBlazor, found <a href="https://mudblazor.com/">here</a></li>
</ul>
<p>We will make a component now, just a simple check box, and then we will use that in the next feature to complete Todos.</p>
<p><img src="Resources/ItWillBeGlorious.png" alt="img.png" /></p>

</div>
<div class="tab">
<hr/><h1 id="checkbox-component">Checkbox Component</h1><hr/>
<h2 id="purpose">Purpose</h2>
<p>The main purpose here is the introduction to the concept of Blazor components.</p>
<p>A secondary purpose is to show one way of passing parameters to a nested component, from a parent component/page. This will also be discussed again towards the end of the tutorial.</p>
<h2 id="lets-go">Let's Go</h2>
<p>We start by creating a new component file. It is the same as what we have done when creating pages, we just don't need the @page directive at the top. That is the only difference.</p>
<p>First, we might want to organize our files a bit, create a new directory inside Pages, call it &quot;UIComponents&quot;.</p>
<p>Inside this new directory, create a new component, call it &quot;FancyCheckBox&quot;.</p>
<p><img src="Resources/NewComponent.png" alt="img.png" /></p>
<p>And then:</p>
<p><img src="Resources/SelectComponent.png" alt="img.png" /></p>
<p>This will give you a file with the following content:</p>
<pre><code class="line-numbers language-razor">&lt;h3&gt;FancyCheckBox&lt;/h3&gt;

@code {
    
}
</code></pre>
<p>Notice, the only difference of a new Page and new Component, is that the Page has the @page directive at the top. We can manually add a @page directive, and turn this component into a page.</p>
<p>Remember, Pages can work as Components too, even though that may be less standard.</p>
<p>In this file, FancyCheckBox, we just want to have HTML for a checkbox, a little bit of functionality, and some styling, for the &quot;Fancy&quot; part.</p>
<h2 id="the-code">The Code</h2>
<p>We just need the initial value of the <code>Todo::IsCompleted</code>, and we need a call-back delegate.
When the value of this component changes, we want to set the value of the <code>Todo::IsCompleted</code> property.
Think observer pattern, so we use a delegate.
Or more specifically, we use a sub-class called <code>EventCallback&lt;..&gt;</code>, which is generally used in Blazor, in part because of async capability.</p>
<p>So, the code looks like this:</p>
<pre><code class="line-numbers language-csharp">@code {
    
    [Parameter]
    public bool IsCompleted { get; set; }
    
    [Parameter]
    public EventCallback&lt;bool&gt; OnChange { get; set; }
}
</code></pre>
<p>We have the two properties, one for the initial value, <code>IsCompleted</code>, and a delegate to notify interested parties of changes, the <code>OnChange</code>.<br />
But each have an attribute, <code>[Parameter]</code>, now what's that about?</p>
<p><img src="Resources/AMystery.png" alt="img.png" /></p>
<p>When you instantiate new classes in C#, they often have a constructor, so that you can pass arguments to the class.</p>
<p>What we have here is similar. Wherever we use this component (which may be many places across a large app),
we wish to provide it with some initial data, i.e. the value of <code>IsCompleted</code>, and we may want to subscribe methods to the <code>OnChange</code>. This must be done from the &quot;outside&quot; of this component.</p>
<p>We can set these properties from the outside, when we mark them with <code>[Parameter]</code>. We will see how shortly.</p>
<p>The point is, initially the checkbox value must be set to either true or false, given the value of the specific Todo. And we must subscribe a method to be invoked, whenever the checkbox is clicked, so that we may update the todo.</p>
<p>Let's take a look at that.</p>
<h2 id="the-view">The View</h2>
<p>Now, I style this specific checkbox visual from some online example, and it is obviously more fancy than what we need. We could just use the default HTML-checkbox, but that is dull. And I have been waiting for an opportunity to apply this. So, here we are</p>
<p>This is the view:</p>
<pre><code class="line-numbers language-razor">@namespace UIComponents

&lt;label class=&quot;checkbox-container&quot;&gt;
    &lt;input 
        type=&quot;checkbox&quot; 
        class=&quot;checkbox-input&quot; 
        checked=&quot;@IsCompleted&quot; 
        @onchange=&quot;@((arg) =&gt; OnChange.InvokeAsync((bool)arg.Value!))&quot;
    /&gt;
    &lt;span class=&quot;checkbox-span&quot;&gt;&lt;/span&gt;
&lt;/label&gt;
</code></pre>
<p>First, because the file is not located directly inside the Pages directory, we must define a namespace. We will use this namespace in other pages/components to import this functionality.</p>
<p>There is a surrounding label with some styling. Inside there is an input of type checkbox, and a span, which is used for for the graphics.<br />
Let's take a closer look at the <code>&lt;input ../&gt;</code>:</p>
<pre><code class="line-numbers language-razor">&lt;input 
    type=&quot;checkbox&quot; 
    class=&quot;checkbox-input&quot; 
    checked=&quot;@IsCompleted&quot; 
    @onchange=&quot;@((arg) =&gt; OnChange.InvokeAsync((bool)arg.Value!))&quot;
/&gt;
</code></pre>
<p>Line 2: We define the input type to be a checkbox.<br />
Line 3: We define the styling class.<br />
Line 4: We set the initial value of the checkbox to the value from the property.<br />
Line 5: We define what should happen, when the value changes: we provide a lambda expression, which just invokes the <code>OnChange</code>, i.e. we invoke subscribed methods.</p>
<p>Finally..</p>
<h2 id="the-styling">The Styling</h2>
<p>It looks like this, put it in a style-behind of the FancyCheckBox.</p>
<pre><code class="line-numbers language-css">.checkbox-container {
    display: inline-block;
    width: 30px;
    height: 30px;
    cursor: pointer;
}

.checkbox-input {
    position: absolute;
    transform: scale(0);
}

.checkbox-input:checked ~ .checkbox-span {
    transform: rotate(45deg);
    width: 15px;
    margin-left: 8px;
    border-color: #24c78e;
    border-top-color: transparent;
    border-left-color: transparent;
    border-radius: 0;
}

.checkbox-span {
    display: block;
    width: inherit;
    height: inherit;
    border: 3px solid #434343;
    border-radius: 6px;
    transition: all 0.375s;
}
</code></pre>
<p>I don't particularly care about what it does.</p>
<h2 id="initial-test">Initial Test</h2>
<p>Before actually taking it in use, let's test if the graphics work as expected.</p>
<p>Open the page Index.razor file.</p>
<p>Modify it to look like this:</p>
<pre><code class="line-numbers language-razor">@page &quot;/&quot;
@using UIComponents

&lt;PageTitle&gt;Index&lt;/PageTitle&gt;

&lt;h1&gt;Hello, world!&lt;/h1&gt;

Welcome to your new app.

&lt;SurveyPrompt Title=&quot;How is Blazor working for you?&quot;/&gt;

&lt;FancyCheckBox/&gt;
</code></pre>
<p>Notice the second line, where we import the namespace, defined in the FancyCheckBox component file.</p>
<p>And then the bottom line, where we insert the component. It almost looks like we are just using a normal HTML tag.</p>
<p>Your IDE, however, should color code it different from standard HTML. Here's what my theme looks like:</p>
<p><img src="Resources/ComponentHighlight.png" alt="img.png" /></p>
<p>Notice the component is in purple, same as the SurveyPrompt, which is another component, that came with the template project. <code>&lt;PageTitle&gt;</code> is again also a component, defined in the Blazor framework. Also notice the naming convention of components versus HTML: PascalCase vs alllowercase.</p>
<p>Now, go ahead and delete the line <code>@using UIComponents</code>, and you should see your component change color to that of HTML, in my case blue. The colors help to indicate that you may have forgotten to import a specific component, and so it will not show up in the UI, when running the app.This often happens.</p>
<p><strong>Put the using statement back again.</strong></p>
<p>When the UI is rendered, the content of the component is extracted, and inserted into the final page, so when you inspect the HTML of the UI in the browser, you will not see that some of the HTML came from a component.</p>
<p>You can duplicate the line of <code>&lt;FancyCheckBox/&gt;</code> a couple of times to get more checkboxes. That's the easy re-usability mentioned earlier.</p>
<p>Sometimes components are made for re-usability, but I find that often components are made because your page grows too large. You can then take parts of a page, and refactor out into a new component. This can be a very good way to organize your pages.</p>
<p>Now, the test. Run your Blazor app, we don't need the Web API for this, as we are not retrieving any data just yet.</p>
<p>Your front page should now look like this:</p>
<p><img src="Resources/CheckBoxInAction.gif" alt="" /></p>
<p>My god, is that fancy or what?!</p>
<p><img src="Resources/SoFancy.png" alt="img.png" /></p>
<p>Okay, we haven't provided any parameters to it just yet. So let's go and use it for real.</p>
<p>You may delete the component from the Index.razor page, if you wish.</p>

</div>
<div class="tab">
<hr/><h1 id="using-the-checkbox">Using the Checkbox</h1><hr/>
<p>We need to modify the ViewTodos page, so that instead of displaying a textual value, we use the new</p>
<p><img src="Resources/FancyCheckBoxMeme.png" alt="img.png" /></p>
<p><a href="https://github.com/TroelsMortensen/WasmTodo/tree/015_CheckBoxComponent">The code should be in this branch</a></p>
<h2 id="the-service">The Service</h2>
<p>First, we must create a new method in TodoHttpClient responsible for making update requests.</p>
<h4 id="interface">Interface</h4>
<p>Start by putting the following method into the interface <code>ITodoService</code>:</p>
<pre><code class="line-numbers language-csharp">    Task UpdateAsync(TodoUpdateDto dto);
</code></pre>
<p>We already have the <code>TodoUpdateDto</code> class, i.e. the argument, which is what the PATCH endpoint in your Web API needs.</p>
<h4 id="implementation">Implementation</h4>
<p>Now, we must implement the method in TodoHttpClient.</p>
<p>It is similar to the <code>CreateAsync()</code> method in this class. We must make a PATCH request, and check the response for error code.</p>
<p>However, where there is a <code>PostAsJson()</code> method, there is no <code>PatchAsJson</code> (which I find strange, but apparently you can <a href="https://docs.microsoft.com/en-us/dotnet/api/system.net.http.json.httpclientjsonextensions.patchasjsonasync?view=net-7.0">import it</a> as an <a href="https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/extension-methods">extension method</a>). So, we must use the client slightly differently.</p>
<p>This is then the method:</p>
<pre><code class="line-numbers language-csharp">public async Task UpdateAsync(TodoUpdateDto dto)
{
    string dtoAsJson = JsonSerializer.Serialize(dto);
    StringContent body = new StringContent(dtoAsJson, Encoding.UTF8, &quot;application/json&quot;);

    HttpResponseMessage response = await client.PatchAsync(&quot;/todos&quot;, body);
    if (!response.IsSuccessStatusCode)
    {
        string content = await response.Content.ReadAsStringAsync();
        throw new Exception(content);
    }
}
</code></pre>
<p>First the dto argument is serialized to JSON. We do this manually, like a lowly pleb. That was otherwise handled for us when using <code>PostAsJson(..)</code>.<br />
Then we create a <code>StringContent</code> to hold the data in the body of the request message. We provide as arguments first the &quot;dto as JSON&quot;, then the encoding, and finally the format of the string. We are sending JSON, so we pass &quot;application/json&quot;. I don't know why it must be prefixed with &quot;application/&quot;, maybe someone will some day google this, and tell me.</p>
<p>We make a Patch request with the client, providing endpoint URI and the content for the body.</p>
<p>Then the status is checked, and in case of errors from the server, we throw an exception, so we can provide feedback to the user. Business as usual.</p>
<h2 id="the-view">The View</h2>
<p>First, we must import the component in ViewTodos.razor at the top:</p>
<pre data-line="4"><code class="line-numbers language-razor">@page &quot;/ViewTodos&quot;
@using Domain.Models
@using HttpClients.ClientInterfaces
@using UIComponents
@using Domain.DTOs
@inject ITodoService todoService
</code></pre>
<p>Then we must modify the table definition to use the component. Here is the snippet:</p>
<pre data-line="20-22"><code class="line-numbers language-razor">...
else
{
    &lt;table class=&quot;table&quot;&gt;
        &lt;thead&gt;
        &lt;tr&gt;
            &lt;th&gt;Todo ID&lt;/th&gt;
            &lt;th&gt;Owner ID&lt;/th&gt;
            &lt;th&gt;Title&lt;/th&gt;
            &lt;th&gt;Completed?&lt;/th&gt;
        &lt;/tr&gt;
        &lt;/thead&gt;
        &lt;tbody&gt;
        @foreach (var item in todos)
        {
            &lt;tr&gt;
                &lt;td&gt;@item.Id&lt;/td&gt;
                &lt;td&gt;@item.Owner.UserName&lt;/td&gt;
                &lt;td&gt;@item.Title&lt;/td&gt;
                &lt;td&gt;
                    &lt;FancyCheckBox IsCompleted=&quot;@item.IsCompleted&quot; OnChange=&quot;@((status) =&gt; CompleteTodo(item, status))&quot;/&gt;
                &lt;/td&gt;
            &lt;/tr&gt;
        }
        &lt;/tbody&gt;
    &lt;/table&gt;
}
..
</code></pre>
<p>Notice lines 20-22. We previously displayed the <code>item.IsCompleted</code>. Now we use the FancyCheckBox component. This time we also set the properties.<br />
The <code>IsCompleted</code> property is set to the value of the <code>item</code> from the foreach loop.<br />
To the <code>OnChange</code> delegate we subscribe a lambda expression. The argument, <code>status</code>, is a bool, i.e. the value of the check box, and we pass that bool, along with the <code>item</code> variable to a method, yet to be created. See below.</p>
<p>So the component is initialized with the IsCompleted value of the <code>item</code>, and whenever we click the checkbox, the <code>CompleteTodo(..)</code> method is called. Let's define that method next.</p>
<h2 id="the-code-block">The Code Block</h2>
<p>We must add the new method to the code block, it looks like this:</p>
<pre><code class="line-numbers language-csharp">private async Task CompleteTodo(Todo item, bool status)
{
    TodoUpdateDto dto = new(item.Id)
    {
        IsCompleted = status
    };
    
    try
    {
        await todoService.UpdateAsync(dto);
    }
    catch (Exception e)
    {
        Console.WriteLine(e);
        msg = e.Message;
    }
}
</code></pre>
<p>First we create an instance of <code>TodoUpdateDto</code>. The ID must be set through the constructor, to indicate which Todo is to be updated.
The other properties are optional/nullable, so we only set the <code>IsCompleted</code>, because that is the only thing, we wish to change.</p>
<p>We pass the dto to the TodoHttpService, and display any error messages.</p>
<p>That should all, time for testing.</p>
<h2 id="testing">Testing</h2>
<p>Start Web API, start Blazor.</p>
<p>Navigate to View Todos page, load the list of todos.</p>
<p>Click on a check mark of an uncompleted Todo, and watch the box change to a checkmark. But is the data saved?</p>
<p>You just reload the page, or navigate to a different page and back again to reload the data. Be aware that modified Todos are at the bottom now.</p>
<h4 id="a-bug">A Bug?</h4>
<p><img src="Resources/ComputerBug.png" alt="img.png" /></p>
<p>Remember, on the server side we implemented a business rule stating that <em>completed Todo items cannot be uncompleted</em>.</p>
<p>Now, if you were to try to un-complete an item, that would sort of go medium-okay:</p>
<ul>
<li>You will see that check checkmark changes back to a box, indicating the Todo is no longer complete.</li>
<li>You will also see an error message below the table, indicating the Todo could <em>not</em> be un-completed.</li>
<li>If you refresh the page, reload the data, you will see that the change was <em>in fact not saved</em>.</li>
</ul>
<p>So, the server logic works. But the UI does not match the effect entirely.</p>
<h4 id="a-fix">A Fix?</h4>
<p>We could attempt to make it so that when you click the checkbox, it would attempt to change the value, but in case of errors it would not change.</p>
<p>In the FancyCheckBox component, instead of the lambda expression simply invoking the EventCallback, we could have the <code>@onchange</code> call a method in the code-block of FancyCheckBox, which would invoke the EventCallback, and catch exceptions.<br />
In case of an exception we would set back the IsCompleted property. Or specialize it even more, and just check here if the value is true, then it cannot be changed to false.</p>
<p>We would have to re-throw the exception caught in ViewTodos::CompleteTodo.</p>
<p>Is it important to fix this bug for the purpose of this tutorial? Not really. So, I'll leave it for now, and maybe come back to it later.</p>
<p><img src="Resources/DealWithIt.png" alt="img.png" /></p>

</div>
<div class="tab">
<hr/><h1 id="edit-todo">Edit Todo</h1><hr/>
<p>This isn't exactly a user story. However, we have the Web API endpoint which can update a Todo, so let's make the front end part of that functionality.<br />
<a href="https://github.com/TroelsMortensen/WasmTodo/tree/016_EditTodo">You can find the code in this branch</a></p>
<p>Furthermore, this will show a way to pass arguments to a page, which is important to know about.</p>
<p>For the View Todos page, we would potentially select some filters, and ask to load the data with the click of a button.<br />
Sometimes you want the page to auto-load something, but what that something is may vary. We already automatically load users in multiple pages.</p>
<p>Imaging this: Your Todo object has many more properties than the current version. The View Todos will provide an overview, but not show details for each Todo.<br />
To see details, we would click on a row in the table, or an icon in a row, to &quot;view details&quot;.</p>
<p>We would be taken to a different page, and that page should automatically display details for the specific Todo we selected.<br />
We don't want to have to search for a specific Todo on this next page, though. So we need to tell the page which Todo to load.</p>
<p>This is a common case, you will often need, so we include the feature here.</p>
<p>It requires a new page, and modifications to the ViewTodos.razor.</p>
<p>We already have a method in ITodoService to support this feature: <code>ITodoService::UpdateAsync</code>.<br />
We will need another method to Get a single Todo, by Id, though.</p>

</div>
<div class="tab">
<hr/><h1 id="get-todo-by-id">Get Todo By Id</h1><hr/>
<p>We need to be able to retrieve a single Todo, given it's ID. We could reuse the method, which returns a collection, but I prefer to have a specific method for this.</p>
<h2 id="the-interface">The Interface</h2>
<p>In ITodoService add the following method signature:</p>
<pre><code class="line-numbers language-csharp">Task&lt;TodoBasicDto&gt; GetByIdAsync(int id);
</code></pre>
<h2 id="the-implementation">The Implementation</h2>
<p>You must make a GET request, with the <code>id</code>, to the Web API. You will get a single <code>TodoBasicDto</code>, which is deserialized and returned. Check error status codes as always.</p>
<p>Give it a try yourself.</p>
<details>
<summary>hint</summary>
<pre><code class="line-numbers language-csharp">public async Task&lt;TodoBasicDto&gt; GetByIdAsync(int id)
{
    HttpResponseMessage response = await client.GetAsync($&quot;/todos/{id}&quot;);
    string content = await response.Content.ReadAsStringAsync();
    if (!response.IsSuccessStatusCode)
    {
        throw new Exception(content);
    }

    TodoBasicDto todo = JsonSerializer.Deserialize&lt;TodoBasicDto&gt;(content, 
        new JsonSerializerOptions
        {
            PropertyNameCaseInsensitive = true
        }
    )!;
    return todo;
}
</code></pre>
<p>This should be pretty standard, no big surprises here. Notice the null-suppressor &quot;!&quot; at the end of line 13. You have seen this before.</p>
</details>
<h4 id="comment">Comment</h4>
<p>Now, the Web API returns a <code>TodoBasicDto</code> instead of a Todo. That might be annoying, and we could consider changing it.
But let us stick with it for now, to minimize the required changes to existing code.</p>

</div>
<div class="tab">
<hr/><h1 id="edit-todo-page">Edit Todo Page</h1><hr/>
<p>First, inside Pages, create a new page: &quot;EditTodo&quot;.</p>
<p>The content is then:</p>
<pre><code class="line-numbers language-razor">@page &quot;/EditTodo/{id:int}&quot;

&lt;h3&gt;EditTodo&lt;/h3&gt;

@code {
    
}
</code></pre>
<p>Notice we are back to &quot;pages&quot;, as there is a @page directive at the top. Further notice I have added a bit extra:</p>
<pre><code class="line-numbers language-razor">@page &quot;/EditTodo/{id:int}&quot;
</code></pre>
<p>This means we can access this page with a sub-uri, e.g.:</p>
<ul>
<li>...localhost:port/EditTodo/7</li>
</ul>
<p>The idea is then, that the page will display Todo with ID 7.
I don't specifically need the <code>:int</code> part, but this is a constraint.
If we leave it out, e.g. <code>/EditTodo/{id}</code>, then <code>id</code> will be a string, and it must be assigned to a string property,
and we would have to parse it to an int afterwards.</p>
<h2 id="the-code-block">The Code Block</h2>
<p>We start with the code needed, there are several things going on, so you get the code in snippets. All goes into the code block.</p>
<h4 id="fields">Fields</h4>
<pre><code class="line-numbers language-csharp">[Parameter]
public int Id { get; set; }

private TodoUpdateDto dto = null!;
private string msg = &quot;&quot;;
private IEnumerable&lt;User&gt;? users;
</code></pre>
<p>It's a longer code block, with several things to notice.</p>
<p><strong>Lines 1-2</strong>: Here we define the int property to hold the ID of the Todo we wish to edit. Remember, the value for this property was provided through the URI to the page: in the @page directive, we specified <code>/{id:int}</code>.
Because the property has the same name (ignoring case) as the URI parameter, and is marked with the parameter attribute, the value from the URI will be pasted into the property when the page is accessed.</p>
<p><strong>Lines 4-6</strong>: Various properties. <code>dto</code> will hold the data of the Todo we wish to edit, and then the modified data. <code>msg</code> is as always for user feedback. <code>users</code> is used in a drop down to select a User, if we wish to reassign a Todo to a different User.</p>
<h3 id="loading-data">Loading data</h3>
<p>Then comes the first method:</p>
<pre><code class="line-numbers language-csharp">protected override async Task OnInitializedAsync()
{
    msg = &quot;&quot;;
    try
    {
        users = await userService.GetUsers();
        TodoBasicDto todoData = await todoService.GetByIdAsync(Id);
        User currentlyAssigned = users.First(user =&gt; user.UserName.Equals(todoData.OwnerName));

        dto = new(Id)
        {
            Title = todoData.Title,
            OwnerId = currentlyAssigned.Id
        };
    }
    catch (Exception e)
    {
        Console.WriteLine(e);
        msg = e.Message;
    }
}
</code></pre>
<p><strong>Line 6</strong>: We load the users, so they can be displayed in a drop-down if the user wish to reassign a Todo.</p>
<p><strong>Line 7</strong>: Here the specific Todo is fetched, given the <code>Id</code>.</p>
<p><strong>Line 8</strong>: The <code>TodoBasicDto</code> contains only the User name, not the User id. So, we need to find the User in the collection, given the User name.
The Id is used in the TodoUpdateDto. We can do this, because the server ensures, the User name is unique.</p>
<p><strong>Lines 10-14</strong>: The <code>dto</code> property is initialized to a new <code>TodoUpdateDto</code>, with the data from the fetched TodoBasicDto.
We ignore the <code>IsCompleted</code> property, because that is updated in the View Todos page.<br />
We will bind input fields in the View to the <code>dto</code>, so the input fields will initially have values matching the Todo we are about to edit.</p>
<p>Now all the data is loaded.</p>
<h3 id="updating-data">Updating data</h3>
<p>And finally the Update method. Once the user has modified the data as needed, they click a button, which will call this method:</p>
<pre><code class="line-numbers language-csharp">private async Task UpdateAsync()
{
    try
    {
        await todoService.UpdateAsync(dto);
        navMgr.NavigateTo(&quot;/ViewTodos&quot;);
    }
    catch (Exception e)
    {
        Console.WriteLine(e);
        msg = e.Message;
    }
}
</code></pre>
<p>We hand over the <code>dto</code> to the ITodoService, and then we navigate back to the View Todos page.</p>
<p>In the Add Todo page, we included some basic checks for the data not being null or empty. We might do the same here.
I will leave that to the reader. Remember, the server also checks this, so it is not strictly necessary to have here.</p>
<h2 id="the-view">The View</h2>
<p>The view will look pretty similar to the Add Todo page. The data which can be modified is the same as what was inserted when adding a Todo: Title and the User. So, we can steal much of the HTML to also make the page look similar.</p>
<p>We end up with this:</p>
<pre><code class="line-numbers language-razor">@page &quot;/EditTodo/{id:int}&quot;
@using Domain.DTOs
@using Domain.Models
@using HttpClients.ClientInterfaces
@using Microsoft.AspNetCore.Components
@inject ITodoService todoService
@inject IUserService userService
@inject NavigationManager navMgr

&lt;div class=&quot;card&quot;&gt;
    @if (users == null)
    {
        &lt;label&gt;Loading users...&lt;/label&gt;
    }
    else if (!users.Any())
    {
        &lt;label&gt;No users, you cannot create a Todo&lt;/label&gt;
    }
    else if (dto == null)
    {
        &lt;label&gt;Loading Todo data..&lt;/label&gt;
    }
    else
    {
        &lt;h3&gt;Update Todo&lt;/h3&gt;
        &lt;div class=&quot;form-group field&quot;&gt;
            &lt;label&gt;Title:&lt;/label&gt;
            &lt;input type=&quot;text&quot; @bind=&quot;dto.Title&quot;/&gt;
        &lt;/div&gt;
        &lt;div class=&quot;form-group field&quot;&gt;
            &lt;label&gt;Assignee:&lt;/label&gt;
            &lt;select @bind=&quot;dto.OwnerId&quot;&gt;
                &lt;option&gt;Choose&lt;/option&gt;
                @foreach (User user in users)
                {
                    &lt;option value=&quot;@user.Id&quot;&gt;@user.UserName&lt;/option&gt;
                }
            &lt;/select&gt;
        &lt;/div&gt;
        &lt;div class=&quot;button-row&quot;&gt;
            &lt;button @onclick=&quot;UpdateAsync&quot; class=&quot;acceptbtn&quot;&gt;Update&lt;/button&gt;
        &lt;/div&gt;
    }
    @if (!string.IsNullOrEmpty(msg))
    {
        &lt;label style=&quot;color: red&quot;&gt;@msg&lt;/label&gt;
    }
&lt;/div&gt;
</code></pre>
<p>We have the usual stuff at the top: page directive, using statements, injecting stuff.</p>
<p>We have the usual checks of things not being null or empty in the HTML,
because we might get errors trying to render something from a <code>null</code>-variable.
If there is no data, e.g. <code>!users.Any()</code>, the user should be informed.</p>
<p>The <code>else</code> part is the interesting stuff, again.</p>
<p>There is a text input field for the Title (line 28), with the data bound to the <code>dto.Title</code>.
Notice here how we don't need a string field variable in the code block, like we did in the Add Todo.<br />
Often it is cleaner to bind data to the properties of a data object, like a DTO.
This will potentially reduce the number of fields in the code block significantly,
simplifying the code, and making it easier to reset things if needed, by just assigning the DTO to a new instance.</p>
<p>We have also again the drop down menu of all the users, lines 32-38.</p>
<p>Then there's the button (40-42), and finally the message for user feedback (44-47).</p>
<h2 id="styling">Styling</h2>
<p>If you moved the styles of CreateTodo.razor and CreateUser.razor to the global style sheet, the above HTML will reuse that, and all will be fine. Otherwise you may have to create a style-behind for this page.</p>
<h2 id="testing">Testing</h2>
<p>And that should be all for that feature. Sort of, almost. We still cannot navigate to the page from the nav menu.<br />
But you can access the page by manually typing in the URI in the browser's address bar. Let's try that.</p>
<p>Run Web API, and Blazor app.</p>
<p>Type in here:</p>
<p><img src="Resources/ManualNavigation.png" alt="img.png" /></p>
<p>Notice, your port may be different. And make sure to put a number which matches the ID of an existing Todo.</p>
<p>Modify some values: update the Title, and assign it to another User. Click the button, which will then take you to the View Todos page. Load the data to inspect your modified Todo.
The Todo will now be at the bottom.</p>

</div>
<div class="tab">
<hr/><h1 id="navigate-to-the-edit-todo-page">Navigate to the Edit Todo Page</h1><hr/>
<p>The testing was done by manually typing in the URI in the address bar of the browser. That is inconvenient for a user.</p>
<p>We will add a column to the table in View Todos, with a button, which when clicked, will take you to the EditTodo page.</p>
<p><img src="Resources/LetsDoThis.png" alt="img.png" /></p>
<h2 id="icon">Icon</h2>
<p>We need a new icon to press. We will use this one:</p>
<p><img src="Resources/edit.gif" alt="" /></p>
<p>Download it like the funnel icons. Place it in the same folder: wwwroot/icons.</p>
<h6 id="you-need-not-appreciate-this-icon-as-much-as-the-funnels-as-i-did-not-make-it">You need not appreciate this icon as much as the funnels, as I did not make it.</h6>
<h2 id="the-view-first">The View First</h2>
<p>Open ViewTodos.razor. We will modify the table, here's the snippet part:</p>
<pre data-line="1,16,29-31"><code class="line-numbers language-razor">@inject NavigationManager navMgr


...


else
{
    &lt;table class=&quot;table&quot;&gt;
        &lt;thead&gt;
        &lt;tr&gt;
            &lt;th&gt;Todo ID&lt;/th&gt;
            &lt;th&gt;Owner ID&lt;/th&gt;
            &lt;th&gt;Title&lt;/th&gt;
            &lt;th&gt;Completed?&lt;/th&gt;
            &lt;th&gt;Edit&lt;/th&gt;
        &lt;/tr&gt;
        &lt;/thead&gt;
        &lt;tbody&gt;
        @foreach (var item in todos)
        {
            &lt;tr&gt;
                &lt;td&gt;@item.Id&lt;/td&gt;
                &lt;td&gt;@item.Owner.UserName&lt;/td&gt;
                &lt;td&gt;@item.Title&lt;/td&gt;
                &lt;td&gt;
                    &lt;FancyCheckBox IsCompleted=&quot;@item.IsCompleted&quot; OnChange=&quot;@((status) =&gt; CompleteTodo(item, status))&quot;/&gt;
                &lt;/td&gt;
                &lt;td&gt;
                    &lt;img src=&quot;icons/edit.gif&quot; class=&quot;funnel&quot; @onclick=&quot;@(() =&gt; navMgr.NavigateTo($&quot;/EditTodo/{item.Id}&quot;))&quot;/&gt;
                &lt;/td&gt;
            &lt;/tr&gt;
        }
        &lt;/tbody&gt;
    &lt;/table&gt;
}

...
</code></pre>
<p>Okay, we need a NavigationManager, so that is injected at the top of the page, along with the other inject statements.</p>
<p>Then we have the part of the view with the table definition. Notice the highlighted:</p>
<ul>
<li>There is a new column, defined by the new table header with &quot;Edit&quot; (line 16)</li>
<li>And then the content of that column is defined in the new <code>&lt;td&gt;</code> (lines 29-31).</li>
<li>We insert an image, the source being our gif above.</li>
<li>The style class is the same as the funnel-filter icons. That is just lazy, but it works for now, but the two types of icon has nothing to do with each other, so the style might change for funnels, without a need to change edit icon. We should at some point create a new &quot;edit-icon&quot;-style.<br />
When the icon is clicked, we use the NavigationManager to navigate to the page EditTodo, and we add the ID of the Todo displayed in this row.</li>
</ul>
<h2 id="testing-testing-1-2-testing">Testing, Testing, 1, 2, Testing</h2>
<p>Let's do this.</p>
<p>Run the usual, navigate to View Todos. At the right there is a new column with the edit gifs. Click on one, and pay attention to the data of that row, it should now be displayed on the EditTodo page.</p>

</div>
<div class="tab">
<hr/><h1 id="delete-todo-feature-introduction">Delete Todo Feature Introduction</h1><hr/>
<p>Next up, we have our final user story:</p>
<blockquote>
<p>As a User I can delete a Todo, so that I can clean up</p>
</blockquote>
<p>We will do this by again modifying the View Todos page, adding a new column with a little delete icon to be clicked.</p>
<p><a href="https://github.com/TroelsMortensen/WasmTodo/tree/007_DeleteTodo">The code for this feature is found here</a></p>

</div>
<div class="tab">
<hr/><h1 id="delete-todo-in-the-todo-service">Delete Todo in the Todo Service</h1><hr/>
<p>We start with the client layer.</p>
<h2 id="the-interface">The Interface</h2>
<p>First we define the method in the <code>ITodoService</code> interface. It does not need to return anything, and the argument is just the id of the Todo, we want to delete.</p>
<p>Put this method in the interface:</p>
<pre><code class="line-numbers language-csharp">Task DeleteAsync(int id);
</code></pre>
<h2 id="the-implementation">The Implementation</h2>
<p>Then we need the implementation of the method, in TodoHttpClient.</p>
<p>We already have a DELETE endpoint in the <code>TodosController</code>. Implement the Delete method in TodoHttpClient yourself.</p>
<details>
<summary>hint</summary>
<pre><code class="line-numbers language-csharp">public async Task DeleteAsync(int id)
{
    HttpResponseMessage response = await client.DeleteAsync($&quot;Todos/{id}&quot;);
    if (!response.IsSuccessStatusCode)
    {
        string content = await response.Content.ReadAsStringAsync();
        throw new Exception(content);
    }
}
</code></pre>
</details>

</div>
<div class="tab">
<hr/><h1 id="delete-todo-view">Delete Todo View</h1><hr/>
<p>We need to add a new column with an icon to the table in View Todos page.</p>
<p>We start with..</p>
<h2 id="the-code-block">The Code Block</h2>
<p>We need a new method in the code block of the View Todos page.</p>
<p>It should take an ID, pass it to the Todo Service so that the Server can delete it.<br />
Then we also want to update the data in the view to reflect this deletion, if successful.</p>
<p>The method looks like this:</p>
<pre><code class="line-numbers language-csharp">private async Task RemoveTodo(int todoId)
{
    msg = &quot;&quot;;
    try
    {
        await todoService.DeleteAsync(todoId);
        
        var list = new List&lt;Todo&gt;(todos!);
        list.RemoveAll(todo =&gt; todo.Id == todoId);
        todos = list.AsEnumerable();
    }
    catch (Exception e)
    {
        Console.WriteLine(e);
        msg = e.Message;
    }
}
</code></pre>
<p>Line 6 makes the call to the Todo Service.<br />
Lines 8-10 removes the deleted Todo from the <code>todos</code> collection, which holds the data shown in the view. This variable is an IEnumerable, which cannot be modified. So:</p>
<ul>
<li>First convert the IEnumerable to a List</li>
<li>Then remove from the List</li>
<li>Then assign <code>todos</code> to be the List converted to an IEnumerable.</li>
</ul>
<p>It is a bit inconvenient. We could have made the <code>TodoHttpClient::Get()</code> method return an ICollection or IList instead, which might be easier to work with. But I don't want to go back and refactor that. The reader is welcome to use that approach instead.</p>
<p>Alternatively we could just call <code>LoadTodos()</code> again, to reload the todos from the server. This requires an extra call across the network, which may be resource heavy. It is the quick fix, but probably not the most efficient solution.
If there is no need to call the server, then there is no need to call the server</p>
<h2 id="the-view">The View</h2>
<p>Open again ViewTodos.razor. We must edit the table. We will add another column with an icon to click, when a Todo should be deleted.</p>
<p>The table part of the view is shown here:</p>
<pre data-line="13,29-33"><code class="line-numbers language-razor">...

else
{
    &lt;table class=&quot;table&quot;&gt;
        &lt;thead&gt;
        &lt;tr&gt;
            &lt;th&gt;Todo ID&lt;/th&gt;
            &lt;th&gt;Owner ID&lt;/th&gt;
            &lt;th&gt;Title&lt;/th&gt;
            &lt;th&gt;Completed?&lt;/th&gt;
            &lt;th&gt;Edit&lt;/th&gt;
            &lt;th&gt;Delete?&lt;/th&gt;
        &lt;/tr&gt;
        &lt;/thead&gt;
        &lt;tbody&gt;
        @foreach (var item in todos)
        {
            &lt;tr&gt;
                &lt;td&gt;@item.Id&lt;/td&gt;
                &lt;td&gt;@item.Owner.UserName&lt;/td&gt;
                &lt;td&gt;@item.Title&lt;/td&gt;
                &lt;td&gt;
                    &lt;FancyCheckBox IsCompleted=&quot;@item.IsCompleted&quot; OnChange=&quot;@((status) =&gt; CompleteTodo(item, status))&quot;/&gt;
                &lt;/td&gt;
                &lt;td&gt;
                    &lt;img src=&quot;icons/edit.gif&quot; class=&quot;funnel&quot; @onclick=&quot;@(() =&gt; navMgr.NavigateTo($&quot;/EditTodo/{item.Id}&quot;))&quot;/&gt;
                &lt;/td&gt;
                &lt;td&gt;
                    &lt;label @onclick=&quot;@(() =&gt; RemoveTodo(item.Id))&quot; style=&quot;cursor:pointer; color: red; font-weight: bold&quot;&gt;
                        &amp;#x2717;
                    &lt;/label&gt;
                &lt;/td&gt;
            &lt;/tr&gt;
        }
        &lt;/tbody&gt;
    &lt;/table&gt;
}

...
</code></pre>
<p>Notice the new table column in line 13. And in lines 29-33 we define the content of that column to be an icon, given by the code <code>&amp;#x2717;</code>, which is a red X:</p>
<p><img src="Resources/XIcon.png" alt="img.png" /></p>
<p>Obviously we could have used an actual icon file, like the funnels or the edit. But this special <em>x</em> is fancy. And you know, we like fancy.</p>
<p>The <code>&lt;label&gt;</code> tag contains an <code>@onclick</code>-handler, i.e. a lambda expression to call the <code>RemoveTodo()</code> method defined above. I also have a bit of inline styling. You may move this to a css file, if you prefer. You probably have a style-behind for ViewTodos.razor.</p>
<h2 id="testing">Testing</h2>
<p>It is time to test the feature. Run the usual. Navigate to View Todos. Load all Todos.</p>
<p>First: Try to delete an un-completed Todo. The server should not allow you to. You should see the error message below the table.</p>
<p>Then: Delete a completed Todo. If you have none, then first complete a Todo. You should see the view be updated. To verify the deletion was saved on the server, navigate to a different page, and back, and reload the Todos.</p>

</div>
<div class="tab">
<hr/><h1 id="what-have-we-done-so-far">What Have We Done So Far?</h1><hr/>
<p>We started out with six user stories:</p>
<ol>
<li>As a user of the system I can add a new User, so that Todos can be assigned to Users.</li>
<li>As a User I can get a list of all existing Users, so that I can assign Todos to them</li>
<li>As a User I can add a new Todo, so that I can remember important things</li>
<li>As a User I can view all or filtered Todos, so that I can remember what to do</li>
<li>As a User I can complete a Todo, so that I can mark things as done</li>
<li>As a User I can delete a Todo, so that I can clean up</li>
</ol>
<p>We have now implemented these, along with an extra feature to edit a Todo. As such, we are done.</p>
<p>But there are a bit more complexity to be explored with regards to blazor components. The next few slides will cover more elaborate component usage.</p>

</div>
<div class="tab">
<hr/><h1 id="component-communication">Component Communication</h1><hr/>
<p>It has been mentioned before: Blazor is very modular when components are used. We have already done one component: the FancyCheckBox, the purpose of which was to provide a re-usable UI element.</p>
<p>The re-usability is a big motivator for using components. Another factor is clarity of the code. HTML tends to get a bit incomprehensible when the code grows to many lines. Pieces of the HTML can be split out into smaller components to organize the HTML in a different way.</p>
<p>When using components, we often need to pass data from one to another. There are different ways of doing that, you have seen some. We will cover more here.</p>
<h2 id="passing-data">Passing Data</h2>
<p>Depending on whether you have a page or a component, and also how pages/components are associated, passing data between them can follow various patterns. The purpose of this slide is to show the different ways of passing data back and forth between pages/components</p>
<h3 id="data-to-a-page">Data to a Page</h3>
<p>Whenever you navigate to a new page, sometimes we wish to provide data to that page, so that it can load and display the relevant data.</p>
<p>We have already seen an example of this: using a route parameter. This was covered in slide 30.</p>
<p>We can define a page URI which includes a single, simple parameter. Often just an int or a simple string. In that way it is somewhat similar to how we may define routes to endpoints in the Web API.</p>
<p>We must define the @page-directive, and a public property to hold the data:</p>
<pre><code class="line-numbers language-razor">@page &quot;/EditTodo/{id}

@code {
    [Parameter]
    public string Id {get;set;}
}
</code></pre>
<p>By default, the property is a string, but as seen we can put a constraint on the route argument: <code>{id:int}</code>, which converts it to an int.</p>
<p>This is the primary way of passing data to a page.</p>
<p>There is sort of an alternative, which uses an observer-like pattern (delegates). This will be covered later.</p>
<h4 id="with-query-parameters">With Query Parameters</h4>
<p>Similar to what we can do with Web API endpoints and query parameters, we can do that for the URI of a blazor page.</p>
<p><a href="https://www.coderschmoder.com/five-ways-to-pass-data-from-one-blazor-component-to-another/">This post covers that under the section &quot;QUERYSTRING PARAMETERS&quot;</a></p>
<p>You put nothing extra in the page directive, but have a couple of properties marked with [Parameter] and [SupplyParameterFromQuery]. Here's an example:</p>
<pre><code class="line-numbers language-razor">@page &quot;/displayemployee&quot;
&lt;h3&gt;Display  Employee&lt;/h3&gt;
&lt;p&gt;Employee Id: @Id&lt;/p&gt;
&lt;p&gt;Department: @Department&lt;/p&gt;
&lt;p&gt;Employee First Name: @FName&lt;/p&gt;
&lt;p&gt;Employee Last Name: @LName&lt;/p&gt;
@code {
    [Parameter]
    [SupplyParameterFromQuery]
    public int? Id { get; set; }
    [Parameter]
    [SupplyParameterFromQuery]
    public int? Department { get; set; }
    [Parameter]
    [SupplyParameterFromQuery]
    public string? LName { get; set; }
    [Parameter]
    [SupplyParameterFromQuery]
    public string? FName { get; set; }
}
</code></pre>
<p>The page can then be access with e.g.:</p>
<p>&quot;localhost:port/displayemployee?id=3&amp;lname=whatever&quot;</p>
<h3 id="data-to-a-child-component">Data to a Child Component</h3>
<p>When a component <code>CompA</code> is used inside a page (or other component) <code>PageB</code>,
the CompA is considered a &quot;child&quot; of the PageB, which is the &quot;parent&quot;.</p>
<p>This is the way we have used the FancyCheckBox.</p>
<p>Take this example (which I spent <em>way</em> too long time designing. Appreciate it.):</p>
<p><img src="Resources/ChildComponentImageExample.png" alt="img.png" /></p>
<p>There is a page displayed, with some text.
The &quot;cards&quot; (<a href="https://www.w3schools.com/howto/howto_css_cards.asp">a &quot;card&quot; is common concept</a>) each display some information about a student, and their profile-image.
This card could be defined as a component, we would then generate a number of &quot;card-components&quot; equal to the number of students,
and provide each card-component with a <code>Student</code> object containing the student information.</p>
<p>It might look something like this:</p>
<pre><code class="line-numbers language-razor">@foreach(Student stud in students) {
    &lt;StudentCard Student=&quot;@stud&quot;/&gt;
}
</code></pre>
<p>Where the body of the for-loop is the component.</p>
<p>In this way a <em>parent</em> (whether it is a page or component) can pass data to a <em>child</em>.<br />
This is somewhat similar as passing arguments to a constructor of a class. Here, we can pass variables as arguments as well.</p>
<p>The <code>Student</code> property in the <code>StudentCard</code> component must be marked <code>[Parameter]</code>, e.g.:</p>
<pre><code class="line-numbers language-razor">&lt;div class=&quot;student-card&quot;&gt;
    &lt;img src=&quot;@Student.ImgUrl&quot;/&gt;
    &lt;p&gt;@Student.Description&lt;/p&gt;
&lt;/div&gt;

@code{
    [Parameter]
    public Student Student {get;set;}
}
</code></pre>
<p>We used this approach with the FancyCheckBox, where we passed in the initial boolean value of the check-box.</p>
<h3 id="data-to-a-parent-component">Data to a Parent Component</h3>
<p>Sometimes a child-component needs to pass data back to a parent-component (or -page).
We do this using a delegate, more specifically the <code>EventCallback</code>. We did this in the in the FancyCheckBox. When the check-box was clicked, the EventCallback was invoked with the new value.</p>
<pre><code class="line-numbers language-razor">@code {
    [Parameter]
    public EventCallback&lt;bool&gt; OnChange { get; set; }
}
</code></pre>
<p>And subscribing a method to the EventCallback:</p>
<pre data-line="3"><code class="line-numbers language-razor">&lt;FancyCheckBox 
    IsCompleted=&quot;@item.IsCompleted&quot; 
    OnChange=&quot;@((status) =&gt; CompleteTodo(item, status))&quot;
/&gt;
</code></pre>
<p>We provide it with either a lambda-expression or a method reference.</p>
<h3 id="child-content">Child Content</h3>
<p>Sometimes, it is convenient to pass more than just data to a component. We can actually pass an entire snippet of HTML (with other components or razor-syntax).</p>
<p>Assume we make a Card component (like above), but it is intended to be reused for various types of cards across. It could be the students from the example above, but we might wish to use the same card for presenting other data. And maybe the card has some extra functionality, so that we cannot just achieve this with a <code>&lt;div class=&quot;card&quot;&gt;</code>.
Here are is the idea of the same card but with different content:</p>
<p><img src="Resources/DifferentCards.png" alt="img.png" /></p>
<p>Or, you can consider the slides of this tutorial: they behave similarly, have buttons at the top and bottom, but the content is different.</p>
<p>We can then define a component, which can receive the content as a kind of parameter. It might look like this:</p>
<pre><code class="line-numbers language-razor">&lt;MyFancyCard&gt;
    &lt;div class=&quot;student-card-content&gt;
        &lt;img src=..../&gt;
        &lt;p&gt;bla bla bla&lt;p&gt;
    &lt;/div&gt;
&lt;/MyFancyCard&gt;
</code></pre>
<p>The outer tag <code>&lt;MyFancyCard&gt;</code> is actually a component, with a closing &quot;tag&quot; in the last line. The inner content, lines 2-5, is the &quot;child-content&quot;, i.e. the content we wish to display in the card.</p>
<p>The <code>MyFancyCard</code> component might then be defined as:</p>
<pre><code class="line-numbers language-razor">&lt;div class=&quot;fancy-card&quot;&gt;
    @ChildContent
&lt;/div&gt;

@code {
    [Parameter]
    public RenderFragment ChildContent {get;set;}
    
    ...
}
</code></pre>
<p>The property must be exactly like this, the type, and the name. This property will then receive the HTML from above, and we can put it in the view of the component with a reference, as in line 2.</p>
<p>We will use this on the next slide to create a popup dialog.</p>
<h3 id="data-to-a-sibling-component">Data to a Sibling Component</h3>
<p>Finally, you may have a page containing two (or more) components. So the page has two child-components, but the components do not know about each other, i.e. neither component is parent/child of the other: They are siblings.<br />
The web site design above show multiple cards, each card a component, all cards at the same level in the HTML, so they are siblings.</p>
<p>If you are industrious with regards to refactoring your page into smaller components, you may end up in this situation, where you click a button in one component, and you wish to update the view in another component.</p>
<p>To achieve this, we use a &quot;state container&quot;. It a simple class, which has a delegate and a piece of data (or more delegates, and much data). Then we need a set-method to set the data, which will also invoke the delegate. The components will subscribe their own methods to the delegate, and upon invocation will update their view accordingly.</p>
<p>The state container must be registered as a <em>scoped service</em> in Program.cs, and injected into the components. Alternatively, <em>when using Blazor WASM</em>, a singleton pattern might also achieve this effect.</p>
<p>This could be an example of a state container:</p>
<pre><code class="line-numbers language-csharp">public class StateContainer{

    private int number = 0;
    public Action&lt;int&gt; OnChange {get;set;}
    
    public void SetNumber(int i){
        number = i;
        OnChange?.Invoke(number);
    }
}
</code></pre>
<p>The two components will interact with each other through this StateContainer:</p>
<p><img src="Resources/SetAndNotify.png" alt="img.png" /></p>
<p>This will be shown in action at the end of the tutorial.</p>
<h3 id="cascading-parameter">Cascading Parameter?</h3>
<p>You probably won't need this. You may google it.</p>

</div>
<div class="tab">
<hr/><h1 id="creating-a-popup">Creating a Popup</h1><hr/>
<p>The purpose of this functionality is to show another way of passing data to a component, i.e. using &quot;Child Content&quot;.</p>
<p>Currently, whenever you have successfully added a Todo, you are just being navigated to the View Todos page. A user might be confused, because no success message was displayed first.</p>
<p>We are going to create a success message shown in a popup. The popup will be a component, and the content and functionality of the popup will be arguments to the component.</p>
<p>There are several libraries, mentioned in step 32, which can do this, but let's start with our own approach. There are probably smarter ways to do this, but this approach is also to reiterate how to pass arguments to components.</p>
<h2 id="ui-element-type">UI Element Type</h2>
<p>There are different kinds of popup-types, and these kinds of popups have some common names based on how they are shown.
We will make a modal (or sometimes called toast). There is another called snackbar, and probably more variations.
It's good to know the names of these, if you need to google for examples.</p>
<h2 id="new-component">New Component</h2>
<p>First, create a new blazor component, inside the Pages/UIComponents directory. Call it &quot;Modal&quot;.</p>
<h2 id="the-code-and-view">The Code and View</h2>
<p>This is the entire component code:</p>
<pre><code class="line-numbers language-razor">@namespace UIComponents

@if (ShowModal)
{
    &lt;div class=&quot;modal-background&quot; style=&quot;display:block; height: 100%&quot;&gt;
        &lt;div class=&quot;modal-box&quot;&gt;

            @ChildContent

        &lt;/div&gt;
    &lt;/div&gt;
}

@code {

    [Parameter]
    public RenderFragment ChildContent { get; set; } = null!;
    
    [Parameter]
    public bool ShowModal { get; set; }
}
</code></pre>
<p>We define the namespace of the component at the top, because it is in a different directory than the pages.<br />
Then some <code>&lt;div&gt;</code>s to wrap things, with various styling, see below.</p>
<p>This piece of HTML (and css) was taken from an <a href="https://www.w3schools.com/howto/howto_css_modals.asp">example found on w3shcools</a>.</p>
<p>There isn't much here. The component is just a &quot;wrapper&quot;, which can take some HTML content, and show it in a popup.</p>
<p><strong>Line 6</strong> is important, it defines @ChildContent, and this means you can pass HTML/razor-syntax to a component, by setting the ChildContent. It has to be named like this, and the property must be defined as shown in the code above. How to use it will be shown later.</p>
<p>Everything is wrapped in an if-statement, so that the popup can be displayed or hidden.</p>
<p>In the code block, we have one parameter, which will be the content to be shown in the popup.</p>
<h2 id="the-style">The Style</h2>
<p>Next up, we need the styling. Add a style-behind. Paste in the following:</p>
<pre><code class="line-numbers language-css">.modal-background { /* This style class makes the background darker, and un-clickable */
    position: fixed; /* Stay in place */
    z-index: 1; /* Sit on top */
    left: 0;
    top: 0;
    width: 100%; /* Full width */
    height: 100%; /* Full height */
    overflow: auto; /* Enable scroll if needed */
    background-color: rgb(0,0,0); /* Fallback color */
    background-color: rgba(0, 0, 0, 0.47); /* Black w/ opacity */
    display:block;
}

/* Modal Content/Box */
.modal-box {
    background-color: #fefefe;
    margin: 15% auto; /* 15% from the top and centered */
    padding: 20px;
    border: 1px solid #000000;
    /*display:inline-block;*/
    width: 30%; /* Could be more or less, depending on screen size */
    min-width: 300px;
    border-radius: 25px;
    box-shadow: 0 5px 30px 15px #3f3f3f;
}
</code></pre>
<p>Again, it's stolen from the example, linked above, you may modify it if you please.</p>
<p>The <code>.modal-background</code> creates a black overlay over the rest of the UI.<br />
The <code>.modal-box</code> will display a <em>card</em> over the background.</p>
<p>That's the basic component. Next up, we need to use it for something.</p>

</div>
<div class="tab">
<hr/><h1 id="using-the-popup">Using the Popup</h1><hr/>
<p>Now, let us put the popup into action. As mentioned, we wish to display a message, when a Todo is succesfully added.</p>
<p>Open &quot;CreateTodo.razor&quot;.</p>
<p>We will have to modify various places.</p>
<p><a href="https://github.com/TroelsMortensen/WasmTodo/tree/018_PopupSuccessMessage">Code found in this branch</a></p>
<h2 id="the-view-of-createtodo">The View of CreateTodo</h2>
<p>We need to inject a <code>NavigationManager</code>, and import the UIComponents namespace, at the top:</p>
<pre><code class="line-numbers language-razor">@using UIComponents
@inject NavigationManager navMgr
</code></pre>
<p>Then we need to insert the Modal somewhere, you can just put it at the bottom of the view part:</p>
<pre><code class="line-numbers language-razor">&lt;Modal ShowModal=&quot;showModal&quot;&gt;
    &lt;p&gt;You have successfully added a new Todo item. You should be very proud of yourself!&lt;/p&gt;
    &lt;button @onclick=&quot;@Proceed&quot;&gt;Wonderful&lt;/button&gt;
&lt;/Modal&gt;
</code></pre>
<p>So, the content of the popup is just a short message, and button.
When the button is clicked, the user is taken to the View Todos page. We need to implement this method.</p>
<h2 id="the-code-in-createtodo">The Code in CreateTodo</h2>
<p>We will need a boolean field variable to manage whether the popup is displayed.</p>
<p>And we will need a method to call. The functionality of this method is just to navigate to the View Todos page.</p>
<p>Add this to the code block:</p>
<pre><code class="line-numbers language-csharp">private bool showModal;

private void Proceed()
{
    showModal = false;
    navMgr.NavigateTo(&quot;/ViewTodos&quot;);
}
</code></pre>
<p>In the method <code>Create</code>, after the Todo has been created, we reset the view:</p>
<pre><code class="line-numbers language-csharp">selectedUserId = null;
todoTitle = &quot;&quot;;
msg = &quot;Todo created&quot;;
</code></pre>
<p>This is no longer needed, as the user is taken away from the page. You may remove this.</p>
<p>Instead, we must set the <code>showModal</code> to <code>true</code>, so the try block looks like this:</p>
<pre><code class="line-numbers language-csharp">try
{
    TodoCreationDto dto = new((int)selectedUserId, todoTitle);
    await todoService.CreateAsync(dto);
    showModal = true;
}
</code></pre>
<p>Notice how the modal is displayed after the <code>CreateAsync(..)</code> returns, meaning the request was a success.<br />
If the request fails, and exception will be thrown from Todo Service, and the <code>showModal = true</code> is skipped.</p>
<h2 id="test">Test</h2>
<p>We should be ready test this new fancy feature.</p>
<p>Run the usual stuff.</p>
<p>Navigate to the Create Todo page.</p>

</div>
<div class="tab">
<hr/><h1 id="edit-todo-popup">Edit Todo Popup</h1><hr/>
<p>Here's a challenge for you, if you are brave enough, the tutorial will not contain the code for this.</p>
<p>Your task:</p>
<ul>
<li>Currently, when you click the Edit icon on ViewTodos, you are taken to a new page, where you can edit a todo.</li>
<li>Instead, when clicking this icon, a popup should be shown, where you can edit the todo.</li>
<li>It should contain the same input fields, and functionality.</li>
<li>When the accept button is clicked:
<ul>
<li>On success, close the popup</li>
<li>On failure display an error message inside the popup.</li>
</ul>
</li>
</ul>

</div>
<div class="tab">
<hr/><h1 id="state-container-example">State Container Example</h1><hr/>
<p>The purpose of this example is to show a way for communication between &quot;sibling&quot; components.</p>
<p>The idea is that we have a class, which is registered as a scoped service, i.e. the StateContainer class.<br />
It is injected into all the components, which wish to communicate.<br />
A component may call a method on the StateContainer, which will then invoke its internal delegate.<br />
Methods from the components are subscribed to this delegate.</p>
<p>We will just expand on the simple Counter example, which comes with the default Blazor template. So, this has nothing to do with the Todo tutorial.</p>
<p><a href="https://github.com/TroelsMortensen/WasmTodo/tree/019_StateContainer">The code is found in this branch.</a></p>
<h2 id="the-statecontainer">The StateContainer</h2>
<p>First, we need the state container, this class holds the shared data.</p>
<p>You can put it wherever, if you are implementing along here. I have created a new directory: BlazorWASM/StateContainers.</p>
<p>Here, I place a new class, &quot;CounterStateContainer&quot;. The code looks like this:</p>
<pre><code class="line-numbers language-csharp">namespace BlazorWASM.StateContainers;

public class CounterStateContainer
{
    public Action&lt;int&gt; OnChange { get; set; }

    private int count = 0;

    public void Increment()
    {
        count++;
        OnChange?.Invoke(count);
    }
}
</code></pre>
<p>We then register the CounterStateContainer as a scoped service in Program.cs.</p>
<pre><code class="line-numbers language-csharp">builder.Services.AddScoped&lt;CounterStateContainer&gt;();
</code></pre>
<h2 id="counter-component">Counter Component</h2>
<p>Create a new Component, e.g. &quot;CounterComponent&quot;. I've put mine in the UIComponents directory.</p>
<p>This is the code:</p>
<pre><code class="line-numbers language-razor">@using BlazorWASM.StateContainers
@namespace UIComponents
@inject CounterStateContainer stateContainer

&lt;div&gt;
    &lt;label&gt;Counter @Id&lt;/label&gt;
    &lt;label&gt;@count&lt;/label&gt;
    &lt;button @onclick=&quot;stateContainer.Increment&quot;&gt;Increment&lt;/button&gt;
&lt;/div&gt;

@code {
    [Parameter]
    public int Id { get; set; }

    private int count = 0;

    protected override void OnInitialized()
    {
        stateContainer.OnChange += i =&gt;
        {
            count = i;
            StateHasChanged();
        };
    }
}
</code></pre>
<p>The first line is to import the StateContainer. Then the namespace declaration.<br />
In the third line we inject the CounterStateContainer. Because it is registered as &quot;scoped&quot; in Program.cs, whenever a page/component requests an instance of CounterStateContainer, it will be the same instance. Until the app is refreshed. Then a new shared instance will be created.</p>
<p>The view is just a label with text, then a label to display the current count, and then a button.<br />
When the button is clicked, the <code>CounterStateContainer::Increment()</code> method is called. I have here made a method reference. Alternatively the same could be achieved with a lambda expresion:</p>
<pre><code class="line-numbers language-csharp">() =&gt; stateContainer.Increment()
</code></pre>
<p>The code block holds a Parameter int <code>Id</code>, so that multiple instances of the component can be distinguished. It's not really all that important.<br />
There is a field for the current <code>count</code>.</p>
<p>In the <code>OnInitialized</code> method, which is called when the component/page is rendered, we subscribe some functionality to the delegate in the CounterStateContainer.</p>
<p>First, the argument <code>i</code> is what the CounterStateContainer sends. We assign that to <code>count</code>. Then, we have to tell the component, that some change has occured, and it should update. We do this by calling <code>StateHasChanged()</code>. This is usually needed, when the change to a field comes from outside of the component, in this case the state container.<br />
When the changed is initiated internally in the component/page, it can usually figure out to update the view by itself.</p>
<p>The idea is to put two instances of this component into a page. When the button of one instance is clicked, the <code>Increment</code> method of CounterStateContainer is called, which will push out the new int value to interested parties, i.e. our components. They will then update their internal state, i.e. the <code>count</code> appropriately.</p>
<h2 id="counter-page">Counter Page</h2>
<p>Let's test this.</p>
<p>Create a new page, e.g. &quot;CounterExample&quot; in directory Pages.</p>
<p>It looks like his:</p>
<pre><code class="line-numbers language-razor">@page &quot;/CounterExample&quot;
@using UIComponents

&lt;CounterComponent Id=&quot;1&quot;/&gt;
&lt;br/&gt;
&lt;CounterComponent Id=&quot;2&quot;/&gt;

</code></pre>
<p>It is pretty empty, we just insert two instances of the CounterComponent, with different ids.</p>
<p>Run the app. No need for Web API.</p>
<p>Manually navigate to the page, by typing in the URI in the browser's address bar.</p>
<p>You should see something like below, and if you click either button, both counters are updated.</p>
<p><img src="Resources/SiblinbComponentInAction.gif" alt="" /></p>
<p>So, that is the very basics of communication between components/pages, which are do not have a parent-child structured relationship.</p>

</div>
<div class="tab">
<hr/><h1 id="conclusion">Conclusion</h1><hr/>
<p>This concludes the tutorial.</p>
<p>We now a working end-to-end Todo app.</p>
<p>You have seen how to:</p>
<ul>
<li>define different views with pages.</li>
<li>dynamically generate a view using HTML and razor syntax.</li>
<li>use the HttpClient to make requests of the Web API.</li>
<li>navigate between pages.</li>
<li>rearrange the template UI structure.</li>
<li>work with components in various ways .</li>
</ul>
<p>There is plenty more to learn, but with these basics you are off to a very good start.</p>
<h2 id="class-diagram">Class Diagram</h2>
<p>I display here again the class diagram, because now you have a better basis for understanding it.</p>
<p>You may notice, I have forgotten to suffix some methods with async, e.g. in <code>IUserService</code>, and several pages. It is not super important to fix, so that will probably not happen.
The fact that a method is asynchronous is also implied by the return type of Task.</p>
<p>Notice how pages (just normal classes in the diagram) are marked with the <strong>stereotype</strong> &quot;page&quot;, and components are marked with &quot;comp&quot;. In Astah this is done like this:</p>
<p><img src="Resources/AstahStereotype.png" alt="img.png" /></p>
<p>The grey boxes are components, identified by the little upside-down fork thingy at the top.</p>
<p><img src="Resources/ClassDiagram.svg" alt="" /></p>
<p>I have a habbit of color coding things:</p>
<ul>
<li>Components are grey</li>
<li>Directories are blue, with the blue becoming darker for each nested directory. See Pages and UIComponents.</li>
<li>Pages are light purple, and components are dark purple</li>
<li>Classes are white</li>
<li>Interfaces are green</li>
<li>I take care to collapse association arrows neatly, and sometimes it helps to provide different colors to different groupings of arrows, i.e. the red and blue.</li>
</ul>
<p>These are just my own conventions, you need not follow them. As long as you take care to make your diagrams readable.</p>

</div>



        
        <div style="overflow:auto; padding-bottom: 10px">
            <hr/>
            <div style="float:right;">
                <button type="button" id="prevBtn1" class="prev-button" onclick="nextPrev(-1)">Previous</button>
                <button type="button" id="nextBtn1" class="next-button" onclick="nextPrev(1)">Next&gt;</button>
            </div>
        </div>
        
    </div>
</div>
<script>
    showFirstOrSpecificTab();
</script>

</body>
</html>
